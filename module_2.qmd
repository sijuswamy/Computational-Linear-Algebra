
---
title: "Transforming Linear Algebra to Computational Language"
execute: 
  enabled: true
---
## Introduction 

In the first module, we established a solid foundation in matrix algebra by exploring pseudocode and implementing fundamental matrix operations using `Python`. We practiced key concepts such as matrix addition, subtraction, multiplication, and determinants through practical examples in image processing, leveraging the `SymPy` library for symbolic computation. 

As we begin the second module, **"Transforming Linear Algebra to Computational Language,"** our focus will shift towards applying these concepts with greater depth and actionable insight. This module is designed to bridge the theoretical knowledge from matrix algebra with practical computational applications. You will learn to interpret and utilize matrix operations, solve systems of equations, and analyze the rank of matrices within a variety of real-world contexts. 

A new concept we will introduce is the **Rank-Nullity Theorem**, which provides a fundamental relationship between the rank of a matrix and the dimensions of its null space. This theorem is crucial for understanding the solution spaces of linear systems and the properties of linear transformations. By applying this theorem, you will be able to gain deeper insights into the structure of solutions and the behavior of matrix transformations.

This transition will not only reinforce your understanding of linear algebra but also enhance your ability to apply these concepts effectively in computational settings. Through engaging examples and practical exercises, you will gain valuable experience in transforming abstract mathematical principles into tangible solutions, setting a strong groundwork for advanced computational techniques.

## Relearning of Terms and Operations in Linear Algebra

In this section, we will revisit fundamental matrix operations such as addition, subtraction, scaling, and more through practical examples. Our goal is to transform theoretical linear algebra into modern computational applications. We will demonstrate these concepts using `Python`, focusing on practical and industrial applications.

### Matrix Addition and Subtraction in Data Analysis

Matrix addition and subtraction are fundamental operations that help in combining datasets and analyzing differences. 

**Simple Example: Combining Quarterly Sales Data**

We begin with quarterly sales data from different regions and combine them to get the total sales. The sales data is given in @tbl-qtb. A ar plot of the total sales is shown in [Fig @fig-total1].


| Region | Q1   | Q2   | Q3   | Q4   |
|--------|------|------|------|------|
| A      | 2500 | 2800 | 3100 | 2900 |
| B      | 1500 | 1600 | 1700 | 1800 |

: Quarterly Sales Data {#tbl-qtb}

**From Scratch `Python` Implementation:**

```{python}
#| label: fig-total1
#| fig-cap: "Computing Total Sales using `Numpy` aggregation method"
import numpy as np
import matplotlib.pyplot as plt

# Quarterly sales data
sales_region_a = np.array([2500, 2800, 3100, 2900])
sales_region_b = np.array([1500, 1600, 1700, 1800])

# Combine sales data
total_sales = sales_region_a + sales_region_b

# Visualization
quarters = ['Q1', 'Q2', 'Q3', 'Q4']
plt.bar(quarters, total_sales, color='skyblue')
plt.xlabel('Quarter')
plt.ylabel('Total Sales')
plt.title('Combined Quarterly Sales Data for Regions A and B')
plt.show()
```

In the above `Python` code, we have performed the aggregation operation with the `NumPy` method. Same can be done in a more data analysis style using `pandas` inorder to handle tabular data meaningfully. In this approach, quarterly sales data of each region is stored as `DataFrames`(like an excel sheet). The we combine these two `DataFrames` into one. After that create a new row with index 'Total' and populate this row with sum of quarterly sales in Region A and Region B. Finally a bar plot is created using this 'Total' sales. Advantage of this approach is that we don't need the `matplotlib` library to create visualizations!. The EDA using this approach is shown in [Fig @fig-tot2].

```{python}
#| label: fig-tot2
#| fig-cap: "Computation of Total Sales using `Pandas` method"
import pandas as pd
import matplotlib.pyplot as plt

# DataFrames for quarterly sales data
df_a = pd.DataFrame({'Q1': [2500], 'Q2': [2800], 'Q3': [3100], 'Q4': [2900]}, index=['Region A'])
df_b = pd.DataFrame({'Q1': [1500], 'Q2': [1600], 'Q3': [1700], 'Q4': [1800]}, index=['Region B'])

# Combine data
df_combined = df_a.add(df_b, fill_value=0)
df_combined.loc["Total"] = df_combined.sum(axis=0)
# Visualization
df_combined.loc["Total"].plot(kind='bar', color=['green'])
plt.xlabel('Quarter')
plt.ylabel('Total Sales')
plt.title('Combined Quarterly Sales Data for Regions A and B')
plt.show()
```

We can extend this in to more advanced examples. Irrespective to the size of the data, for representation and aggregation tasks matrix models are best options and are used in industry as a standard. Let us consider an advanced example to analyse difference in stock prices. For this example we are using a simulated data. The python code for this simulation process is shown in [Fig @fig-sim].

```{python}
#| label: fig-sim
#| fig-cap: "Demonstration of Stock Price simulated from a Uniform Distribution"
import numpy as np
import matplotlib.pyplot as plt

# Simulated observed and predicted stock prices
observed_prices = np.random.uniform(100, 200, size=(100, 5))
predicted_prices = np.random.uniform(95, 210, size=(100, 5))

# Calculate the difference matrix
price_differences = observed_prices - predicted_prices

# Visualization
plt.imshow(price_differences, cmap='coolwarm', aspect='auto')
plt.colorbar()
plt.title('Stock Price Differences')
plt.xlabel('Stock Index')
plt.ylabel('Day Index')
plt.show()
```

Another important matrix operation relevant to data analytics and Machine Learning application is scaling. This is considered as a statistical tool to make various features (attributes) in to same scale so as to avoid unnecessary misleading impact in data analysis and its intepretation. In Machine Learning context, this pre-processing stage is inevitable so as to make the model relevant and usable. 

**Simple Example: Normalizing Employee Performance Data**


| Employee | Metric A   | Metric B   | 
|--------|--------------|------------|
| X      | 80           | 700        | 
| Y      | 90           | 800        | 
| Z      |100           |900         |
| A      |110           |1000        |
| B      |120           |1100        |

: Employee Performance Data {#tbl-EPD}

Using simple python code we can simulate the model for `min-max` scaling. The formula for `min-max` scaling is:
$$min_max(X)=\dfrac{X-min(X)}{max(X)-min(X)}$$

For example, while applying the `min-max` scaling in the first value of Metric A, the scaled value is 
$$min_max(80)\dfrac{80-80}{120-80}=0$$ 

Similarly

$$min_max(100)\dfrac{100-80}{120-80}=0.5$$

When we apply this formula to Metric A and Metric B, the scaled output from @tbl-EPD will be as follows:

| Employee | Metric A   | Metric B   | 
|--------|--------------|------------|
| X      | 0.00         | 0.00       | 
| Y      | 0.25         | 0.25       | 
| Z      | 0.50         | 0.50       |
| A      | 0.75         | 0.75       |
| B      | 1.00         | 1.00       |

: Employee Performance Data {#tbl-EPDu}

It is interesting to look into the scaled data! In the orginal table (@tbl-EPD) it is looked like Metric B is superior. But from the scaled table (@tbl-EPDu), it is clear that both the Metrics are representing same relative information. This will help us to identify the redundency in measure and so skip any one of the Metric before analysis!.

The same can be achieved through a matrix operation. The `Python` implementation of this scaling process is shown in [Fig @fig-totalsales].

```{python}
#| label: fig-totalsales
#| fig-cap: "Total sales using `pandas` method"
import numpy as np
import matplotlib.pyplot as plt

# Employee performance data with varying scales
data = np.array([[80, 700], [90, 800], [100, 900], [110, 1000], [120, 1100]])

# Manual scaling
min_vals = np.min(data, axis=0)
max_vals = np.max(data, axis=0)
scaled_data = (data - min_vals) / (max_vals - min_vals)

# Visualization
plt.figure(figsize=(8, 5))
plt.subplot(1, 2, 1)
plt.imshow(data, cmap='viridis')
plt.title('Original Data')
plt.colorbar()

plt.subplot(1, 2, 2)
plt.imshow(scaled_data, cmap='viridis')
plt.title('Scaled Data')
plt.colorbar()

plt.show()

```
From the first sub plot, it is clear that there is a significant difference in the distributions (Metric A and Metric B values). But the second sub plot shows that both the distributions have same pattern and the values ranges between 0 and 1. In short the visualization is more appealing and self explanatory in this case.

:::{.callout-note}
The `min-max` scaling method will confine the feature values (attributes) into the range $[0,1]$. So in effect all the features are scaled proportionally to the data spectrum.
:::

Similarly, we can use the `standard scaling` (transformation to normal distribution) using the transformation $\dfrac{x-\bar{x}}{\sigma}$. Scaling table is given as a practice task to the reader. The python code for this operation is shown in [Fig @fig-minmax].

```{python}
#| label: fig-minmax
#| fig-cap: "Min-max scaling using basic python"
# Standard scaling from scratch
def standard_scaling(data):
    mean = np.mean(data, axis=0)
    std = np.std(data, axis=0)
    scaled_data = (data - mean) / std
    return scaled_data

# Apply standard scaling
scaled_data_scratch = standard_scaling(data)

print("Standard Scaled Data (from scratch):\n", scaled_data_scratch)

# Visualization
plt.figure(figsize=(6, 5))
plt.subplot(1, 2, 1)
plt.imshow(data, cmap='viridis')
plt.title('Original Data')
plt.colorbar()

plt.subplot(1, 2, 2)
plt.imshow(scaled_data_scratch, cmap='viridis')
plt.title('Scaled Data')
plt.colorbar()

plt.show()
```
To understand the effect of standard scaling, let us consider [Fig @fig-comp1]. This plot create the frequency distribution of the data as a histogram along with the density function. From the first sub-plot, it is clear that the distribution has multiple modes (peaks). When we apply the standard scaling, the distribution become un-modal(only one peek). This is demonstrated in the second sub-plot.

```{python}
#| label: fig-comp1
#| fig-cap: "Impact of standard scaling on the distribution"
# Standard scaling from scratch
import seaborn as sns
# Create plots
plt.figure(figsize=(6, 5))

# Plot for original data
plt.subplot(1, 2, 1)
sns.histplot(data, kde=True, bins=10, palette="viridis")
plt.title('Original Data Distribution')
plt.xlabel('Value')
plt.ylabel('Frequency')

# Plot for standard scaled data
plt.subplot(1, 2, 2)
sns.histplot(scaled_data_scratch, kde=True, bins=10, palette="viridis")
plt.title('Standard Scaled Data Distribution')
plt.xlabel('Value')
plt.ylabel('Frequency')

plt.tight_layout()
plt.show()
```

A scatter plot showing the compare the impact of scaling on the given distribution is shown in [Fig @fig-scatter].

```{python}
#| label: fig-scatter
#| fig-cap: "Comparison of impact of scaling on the distribution"
# Plot original and scaled data
plt.figure(figsize=(6, 5))

# Original Data
plt.subplot(1, 3, 1)
plt.scatter(data[:, 0], data[:, 1], color='blue')
plt.title('Original Data')
plt.xlabel('Metric A')
plt.ylabel('Metric B')

# Standard Scaled Data
plt.subplot(1, 3, 2)
plt.scatter(scaled_data_scratch[:, 0], scaled_data_scratch[:, 1], color='green')
plt.title('Standard Scaled Data')
plt.xlabel('Metric A (Standard Scaled)')
plt.ylabel('Metric B (Standard Scaled)')

# Min-Max Scaled Data
plt.subplot(1, 3, 3)
plt.scatter(scaled_data[:, 0], scaled_data[:, 1], color='red')
plt.title('Min-Max Scaled Data')
plt.xlabel('Metric A (Min-Max Scaled)')
plt.ylabel('Metric B (Min-Max Scaled)')

plt.tight_layout()
plt.show()
```

From the [Fig @fig-scatter], it is clear that the scaling does not affect the pattern of the data, instead it just scale the distribution proportionally!

We can use the `scikit-learn` library for do the same thing in a very simple handy approach. The `python` code for this job is shown below.

```{python}
from sklearn.preprocessing import MinMaxScaler

# Min-max scaling using sklearn
scaler = MinMaxScaler()
min_max_scaled_data_sklearn = scaler.fit_transform(data)

print("Min-Max Scaled Data (using sklearn):\n", min_max_scaled_data_sklearn)
```
```{python}
from sklearn.preprocessing import StandardScaler

# Standard scaling using sklearn
scaler = StandardScaler()
scaled_data_sklearn = scaler.fit_transform(data)

print("Standard Scaled Data (using sklearn):\n", scaled_data_sklearn)

```
A scatter plot showing the impact on scaling is shown in [Fig @fig-comp2]. This plot compare the m`min-max` and `standard-scaling`.

```{python}
#| label: fig-comp2
#| fig-cap: "Camparison of Min-max and standard  scalings with original data"
# Plot original and scaled data
plt.figure(figsize=(6, 5))

# Original Data
plt.subplot(1, 3, 1)
plt.scatter(data[:, 0], data[:, 1], color='blue')
plt.title('Original Data')
plt.xlabel('Metric A')
plt.ylabel('Metric B')

# Standard Scaled Data
plt.subplot(1, 3, 2)
plt.scatter(scaled_data_sklearn[:, 0], scaled_data_sklearn[:, 1], color='green')
plt.title('Standard Scaled Data')
plt.xlabel('Metric A (Standard Scaled)')
plt.ylabel('Metric B (Standard Scaled)')

# Min-Max Scaled Data
plt.subplot(1, 3, 3)
plt.scatter(min_max_scaled_data_sklearn[:, 0], min_max_scaled_data_sklearn[:, 1], color='red')
plt.title('Min-Max Scaled Data')
plt.xlabel('Metric A (Min-Max Scaled)')
plt.ylabel('Metric B (Min-Max Scaled)')

plt.tight_layout()
plt.show()
```

### More on Matrix Product and its Applications

In the first module of our course, we introduced matrix products as scalar projections, focusing on how matrices interact through basic operations. In this section, we will expand on this by exploring different types of matrix products that have practical importance in various fields. One such product is the *Hadamard product*, which is particularly useful in applications ranging from image processing to neural networks and statistical analysis. We will cover the definition, properties, and examples of the Hadamard product, and then delve into practical applications with simulated data.

#### Hadamard Product

The Hadamard product (or element-wise product) of two matrices is a binary operation that combines two matrices of the same dimensions to produce another matrix of the same dimensions, where each element is the product of corresponding elements in the original matrices.

:::{.callout-important}
### Definition (Hadamard Product):
For two matrices $A$ and $B$ of the same dimension $m \times n$, the Hadamard product $A \circ B$ is defined as:

$$(A \circ B)_{ij} = A_{ij} \cdot B_{ij}$$

where $\cdot$ denotes element-wise multiplication.
:::

::: {.callout-note}
### Properties of Hadamard Product

1.  **Commutativity**: 
  $$A \circ B = B \circ A$$
  
2.  **Associativity**: 
  $$(A \circ B) \circ C = A \circ (B \circ C)$$
  
3.  **Distributivity**: 
  $$A \circ (B + C) = (A \circ B) + (A \circ C)$$
:::

Some simple examples to demonstrate the Hadamard product is given below.

Example 1: Basic Hadamard Product

Given matrices:

$$A = \begin{pmatrix}
1 & 2 \\
3 & 4
\end{pmatrix}, \quad
B = \begin{pmatrix}
5 & 6 \\
7 & 8
\end{pmatrix}$$

The Hadamard product $A \circ B$ is:
$$A \circ B = \begin{pmatrix}
1 \cdot 5 & 2 \cdot 6 \\
3 \cdot 7 & 4 \cdot 8
\end{pmatrix} = \begin{pmatrix}
5 & 12 \\
21 & 32
\end{pmatrix}$$

Example 2: Hadamard Product with Larger Matrices

Given matrices:

$$A = \begin{pmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{pmatrix}, \quad
B = \begin{pmatrix}
9 & 8 & 7 \\
6 & 5 & 4 \\
3 & 2 & 1
\end{pmatrix}$$

The Hadamard product $A \circ B$ is:

$$A \circ B = \begin{pmatrix}
1 \cdot 9 & 2 \cdot 8 & 3 \cdot 7 \\
4 \cdot 6 & 5 \cdot 5 & 6 \cdot 4 \\
7 \cdot 3 & 8 \cdot 2 & 9 \cdot 1
\end{pmatrix} = \begin{pmatrix}
9 & 16 & 21 \\
24 & 25 & 24 \\
21 & 16 & 9
\end{pmatrix}$$

In the following code chunks the computational process of Hadamard product is implemented in `Python`. Here both the from the scratch and use of external module versions are included.

**1. Compute Hadamard Product from Scratch (without Libraries)**

Here’s how you can compute the Hadamard product manually:

```{python}
# Define matrices A and B
A = [[1, 2, 3], [4, 5, 6]]
B = [[7, 8, 9], [10, 11, 12]]

# Function to compute Hadamard product
def hadamard_product(A, B):
    # Get the number of rows and columns
    num_rows = len(A)
    num_cols = len(A[0])
    
    # Initialize the result matrix
    result = [[0]*num_cols for _ in range(num_rows)]
    
    # Compute the Hadamard product
    for i in range(num_rows):
        for j in range(num_cols):
            result[i][j] = A[i][j] * B[i][j]
    
    return result

# Compute Hadamard product
hadamard_product_result = hadamard_product(A, B)

# Display result
print("Hadamard Product (From Scratch):")
for row in hadamard_product_result:
    print(row)
```

**2. Compute Hadamard Product Using `SymPy`**

Here’s how to compute the Hadamard product using `SymPy`:

```{python}
import sympy as sp

# Define matrices A and B
A = sp.Matrix([[1, 2, 3], [4, 5, 6]])
B = sp.Matrix([[7, 8, 9], [10, 11, 12]])

# Compute Hadamard product using SymPy
Hadamard_product_sympy = A.multiply_elementwise(B)

# Display result
print("Hadamard Product (Using SymPy):")
print(Hadamard_product_sympy)
```

**Practical Applications**

*Application 1: Image Masking*

The Hadamard product can be used for image masking. Here’s how you can apply a mask to an image and visualize it as shown in [Fig @fig-imgmask].

```{python}
#| label: fig-imgmask
#| fig-cap: "Demonstration of Masking in DIP using Hadamard Product"
import matplotlib.pyplot as plt
import numpy as np

# Simulated large image (2D array) using NumPy
image = np.random.rand(100, 100)

# Simulated mask (binary matrix) using NumPy
mask = np.random.randint(0, 2, size=(100, 100))

# Compute Hadamard product
masked_image = image * mask

# Plot original image and masked image
fig, ax = plt.subplots(1, 2, figsize=(12, 5))
ax[0].imshow(image, cmap='gray')
ax[0].set_title('Original Image')
ax[1].imshow(masked_image, cmap='gray')
ax[1].set_title('Masked Image')
plt.show()
```

Application 2: Element-wise Scaling in Neural Networks

The Hadamard product can be used for dropout^[A regularization techniques in Deep learning. This approach deactivate some selected neurons to control model over-fitting] in neural networks. A simple simulated example is given below.

```{python}
# Simulated large activations (2D array) using NumPy
activations = np.random.rand(100, 100)

# Simulated dropout mask (binary matrix) using NumPy
dropout_mask = np.random.randint(0, 2, size=(100, 100))

# Apply dropout
dropped_activations = activations * dropout_mask

# Display results
print("Original Activations:")
print(activations)
print("\nDropout Mask:")
print(dropout_mask)
print("\nDropped Activations:")
print(dropped_activations)
```

Application 3: Statistical Data Analysis

In statistics, the Hadamard product can be applied to scale covariance matrices. Here’s how we can compute the covariance matrix using matrix operations and apply scaling. Following `Python` code demonstrate this.

```{python}
import sympy as sp
import numpy as np

# Simulated large dataset (2D array) using NumPy
data = np.random.rand(100, 10)

# Compute the mean of each column
mean = np.mean(data, axis=0)

# Center the data
centered_data = data - mean

# Compute the covariance matrix using matrix product operation
cov_matrix = (centered_data.T @ centered_data) / (centered_data.shape[0] - 1)
cov_matrix_sympy = sp.Matrix(cov_matrix)

# Simulated scaling factors (2D array) using SymPy Matrix
scaling_factors = sp.Matrix(np.random.rand(10, 10))

# Compute Hadamard product
scaled_cov_matrix = cov_matrix_sympy.multiply(scaling_factors)

# Display results
print("Covariance Matrix:")
print(cov_matrix_sympy)
print("\nScaling Factors:")
print(scaling_factors)
print("\nScaled Covariance Matrix:")
print(scaled_cov_matrix)
```
#### Practice Problems

**Problem 1: Basic Hadamard Product**

Given matrices:
$$A=\begin{bmatrix}1&2\\3&4\end{bmatrix}$$
$$B=\begin{bmatrix}5&6\\7&8\end{bmatrix}$$

Find the Hadamard product $C=A\circ B$.

**Solution:**

$$C=\begin{bmatrix}
1\cdot5&2\cdot6\\
3\cdot7&4\cdot8
\end{bmatrix}=
\begin{bmatrix}
5&12\\
21&32
\end{bmatrix}$$

**Problem 2: Hadamard Product with Identity Matrix**

Given matrices:
$$A=\begin{bmatrix}1&2&3\\4&5&6\end{bmatrix}$$
$$I=\begin{bmatrix}1&0&0\\0&1&0\end{bmatrix}$$

Find the Hadamard product $C=A\circ I$.

**Solution:**

$$C=\begin{bmatrix}
1\cdot1&2\cdot0&3\cdot0\\
4\cdot0&5\cdot1&6\cdot0
\end{bmatrix}=
\begin{bmatrix}
1&0&0\\
0&5&0
\end{bmatrix}$$

**Problem 3: Hadamard Product with Zero Matrix**

Given matrices:
$$A=\begin{bmatrix}3&4\\5&6\end{bmatrix}$$
$$Z=\begin{bmatrix}0&0\\0&0\end{bmatrix}$$

Find the Hadamard product $C=A\circ Z$.

**Solution:**

$$C=\begin{bmatrix}
3\cdot0&4\cdot0\\
5\cdot0&6\cdot0
\end{bmatrix}=
\begin{bmatrix}
0&0\\
0&0
\end{bmatrix}$$

**Problem 4: Hadamard Product of Two Identity Matrices**

Given identity matrices:
$$I_2=\begin{bmatrix}1&0\\0&1\end{bmatrix}$$
$$I_3=\begin{bmatrix}1&0&0\\0&1&0\\0&0&1\end{bmatrix}$$

Find the Hadamard product $C=I_2\circ I_3$ (extend $I_2$ to match dimensions of $I_3$).

**Solution:**

Extend $I_2$ to $I_3$:
$$I_2=\begin{bmatrix}1&0&0\\0&1&0\\0&0&0\end{bmatrix}$$

$$C=\begin{bmatrix}
1\cdot1&0\cdot0&0\cdot0\\
0\cdot0&1\cdot1&0\cdot0\\
0\cdot0&0\cdot0&0\cdot1
\end{bmatrix}=
\begin{bmatrix}
1&0&0\\
0&1&0\\
0&0&0
\end{bmatrix}$$

**Problem 5: Hadamard Product with Random Matrices**

Given random matrices:
$$A=\begin{bmatrix}2&3\\1&4\end{bmatrix}$$
$$B=\begin{bmatrix}0&5\\6&2\end{bmatrix}$$

Find the Hadamard product $C=A\circ B$.

**Solution:**

$$C=\begin{bmatrix}
2\cdot0&3\cdot5\\
1\cdot6&4\cdot2
\end{bmatrix}=
\begin{bmatrix}
0&15\\
6&8
\end{bmatrix}$$

**Problem 6: Hadamard Product of 3x3 Matrices**

Given matrices:
$$A=\begin{bmatrix}1&2&3\\4&5&6\\7&8&9\end{bmatrix}$$
$$B=\begin{bmatrix}9&8&7\\6&5&4\\3&2&1\end{bmatrix}$$

Find the Hadamard product $C=A\circ B$.

**Solution:**

$$C=\begin{bmatrix}
1\cdot9&2\cdot8&3\cdot7\\
4\cdot6&5\cdot5&6\cdot4\\
7\cdot3&8\cdot2&9\cdot1
\end{bmatrix}=
\begin{bmatrix}
9&16&21\\
24&25&24\\
21&16&9
\end{bmatrix}$$

**Problem 7: Hadamard Product of Column Vectors**

Given column vectors:
$$u=\begin{bmatrix}2\\3\end{bmatrix}$$
$$v=\begin{bmatrix}5\\6\end{bmatrix}$$

Find the Hadamard product $w=u\circ v$.

**Solution:**

$$w=\begin{bmatrix}
2\cdot5\\
3\cdot6
\end{bmatrix}=
\begin{bmatrix}
10\\
18
\end{bmatrix}$$

**Problem 8: Hadamard Product with Non-Square Matrices**

Given matrices:
$$A=\begin{bmatrix}1&2\\3&4\\5&6\end{bmatrix}$$
$$B=\begin{bmatrix}7&8\\9&10\end{bmatrix}$$

Find the Hadamard product $C=A\circ B$ (extend $B$ to match dimensions of $A$).

**Solution:**

Extend $B$ to match dimensions of $A$:
$$B=\begin{bmatrix}7&8\\9&10\\7&8\end{bmatrix}$$

$$C=\begin{bmatrix}
1\cdot7&2\cdot8\\
3\cdot9&4\cdot10\\
5\cdot7&6\cdot8
\end{bmatrix}=
\begin{bmatrix}
7&16\\
27&40\\
35&48
\end{bmatrix}$$

**Problem 9: Hadamard Product in Image Processing**

Given matrices representing image pixel values:
$$A=\begin{bmatrix}10&20\\30&40\end{bmatrix}$$
$$B=\begin{bmatrix}0.5&1.5\\2.0&0.5\end{bmatrix}$$

Find the Hadamard product $C=A\circ B$.

**Solution:**

$$C=\begin{bmatrix}
10\cdot0.5&20\cdot1.5\\
30\cdot2.0&40\cdot0.5
\end{bmatrix}=
\begin{bmatrix}
5&30\\
60&20
\end{bmatrix}$$

**Problem 10: Hadamard Product in Statistical Data**

Given matrices representing two sets of statistical data:

$$A=\begin{bmatrix}5&6&7\\8&9&10\end{bmatrix}$$
$$B=\begin{bmatrix}1&2&3\\4&5&6\end{bmatrix}$$

Find the Hadamard product $C=A\circ B$.

**Solution:**

$$C=\begin{bmatrix}
5\cdot1&6\cdot2&7\cdot3\\
8\cdot4&9\cdot5&10\cdot6
\end{bmatrix}=
\begin{bmatrix}
5&12&21\\
32&45&60
\end{bmatrix}$$

#### Inner Product of Matrices

The inner product of two matrices is a generalized extension of the dot product, where each matrix is treated as a vector in a high-dimensional space. For two matrices $A$ and $B$ of the same dimension $m \times n$, the inner product is defined as the sum of the element-wise products of the matrices.

::: {.callout-important}
### Definition (Inner product)

For two matrices $A$ and $B$ of dimension $m \times n$, the inner product $\langle A, B \rangle$ is given by:

$$\langle A, B \rangle = \sum_{i=1}^{m} \sum_{j=1}^{n} A_{ij} \cdot B_{ij}$$

where $\cdot$ denotes element-wise multiplication.
:::


::: {.callout-important}
### Properties

1.  **Commutativity**: 
  $$\langle A, B \rangle = \langle B, A \rangle$$
  
2.  **Linearity**: 
  $$\langle A + C, B \rangle = \langle A, B \rangle + \langle C, B \rangle$$
  
3.  **Positive Definiteness**: 
  $$\langle A, A \rangle \geq 0$$
  with equality if and only if $A$ is a zero matrix.
:::


Some simple examples showing the mathematical process of calculating the inner product is given bellow.

**Example 1: Basic Inner Product**

Given matrices:

$$A = \begin{pmatrix}
1 & 2 \\
3 & 4
\end{pmatrix}, \quad
B = \begin{pmatrix}
5 & 6 \\
7 & 8
\end{pmatrix}$$

The inner product $\langle A, B \rangle$ is:

$$\langle A, B \rangle = 1 \cdot 5 + 2 \cdot 6 + 3 \cdot 7 + 4 \cdot 8 = 5 + 12 + 21 + 32 = 70$$

**Example 2: Inner Product with Larger Matrices**

Given matrices:

$$A = \begin{pmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{pmatrix}, \quad
B = \begin{pmatrix}
9 & 8 & 7 \\
6 & 5 & 4 \\
3 & 2 & 1
\end{pmatrix}$$

The inner product $\langle A, B \rangle$ is calculated as:
\begin{align*}
\langle A, B \rangle &= 1 \cdot 9 + 2 \cdot 8 + 3 \cdot 7 + 4 \cdot 6 + 5 \cdot 5 + 6 \cdot 4 + 7 \cdot 3 + 8 \cdot 2 + 9 \cdot 1\\
&= 9 + 16 + 21 + 24 + 25 + 24 + 21 + 16 + 9\\
&= 175
\end{align*}

#### Practice Problems

**Problem 1: Inner Product of 2x2 Matrices**

Given matrices:
$$A=\begin{bmatrix}1&2\\3&4\end{bmatrix}$$
$$B=\begin{bmatrix}5&6\\7&8\end{bmatrix}$$

**Solution:**

\begin{align*}
\langle A,B \rangle &= \sum_{i,j} A_{ij} B_{ij} \\
&= 1\cdot5 + 2\cdot6 + 3\cdot7 + 4\cdot8 \\
&= 5 + 12 + 21 + 32 \\
&= 70
\end{align*}

---

**Problem 2: Inner Product of 3x3 Matrices**

Given matrices:
$$A=\begin{bmatrix}1&0&2\\3&4&5\\6&7&8\end{bmatrix}$$
$$B=\begin{bmatrix}8&7&6\\5&4&3\\2&1&0\end{bmatrix}$$

**Solution:**

\begin{align*}
\langle A,B \rangle &= \sum_{i,j} A_{ij} B_{ij} \\
&= 1\cdot8 + 0\cdot7 + 2\cdot6 + \\
&\quad 3\cdot5 + 4\cdot4 + 5\cdot3 + \\
&\quad 6\cdot2 + 7\cdot1 + 8\cdot0 \\
&= 8 + 0 + 12 + 15 + 16 + 15 + 12 + 7 + 0 \\
&= 85
\end{align*}

---

**Problem 3: Inner Product of Diagonal Matrices**

Given diagonal matrices:
$$A=\begin{bmatrix}2&0&0\\0&3&0\\0&0&4\end{bmatrix}$$
$$B=\begin{bmatrix}5&0&0\\0&6&0\\0&0&7\end{bmatrix}$$

**Solution:**

\begin{align*}
\langle A,B \rangle &= \sum_{i,j} A_{ij} B_{ij} \\
&= 2\cdot5 + 0\cdot0 + 0\cdot0 + \\
&\quad 0\cdot0 + 3\cdot6 + 0\cdot0 + \\
&\quad 0\cdot0 + 0\cdot0 + 4\cdot7 \\
&= 10 + 0 + 0 + 0 + 18 + 0 + 0 + 0 + 28 \\
&= 56
\end{align*}

---

**Problem 4: Inner Product of Column Vectors**

Given column vectors:
$$u=\begin{bmatrix}1\\2\\3\end{bmatrix}$$
$$v=\begin{bmatrix}4\\5\\6\end{bmatrix}$$

**Solution:**

\begin{align*}
\langle u,v \rangle &= \sum_{i} u_i v_i \\
&= 1\cdot4 + 2\cdot5 + 3\cdot6 \\
&= 4 + 10 + 18 \\
&= 32
\end{align*}

---

**Problem 5: Inner Product with Random Matrices**

Given matrices:
$$A=\begin{bmatrix}3&2\\1&4\end{bmatrix}$$
$$B=\begin{bmatrix}5&7\\8&6\end{bmatrix}$$

**Solution:**

\begin{align*}
\langle A,B \rangle &= \sum_{i,j} A_{ij} B_{ij} \\
&= 3\cdot5 + 2\cdot7 + \\
&\quad 1\cdot8 + 4\cdot6 \\
&= 15 + 14 + 8 + 24 \\
&= 61
\end{align*}

---

**Problem 6: Inner Product of 2x3 and 3x2 Matrices**

Given matrices:
$$A=\begin{bmatrix}1&2&3\\4&5&6\end{bmatrix}$$
$$B=\begin{bmatrix}7&8\\9&10\\11&12\end{bmatrix}$$

**Solution:**

\begin{align*}
\langle A,B \rangle &= \sum_{i,j} A_{ij} B_{ij} \\
&= 1\cdot7 + 2\cdot8 + 3\cdot11 + \\
&\quad 4\cdot9 + 5\cdot10 + 6\cdot12 \\
&= 7 + 16 + 33 + 36 + 50 + 72 \\
&= 214
\end{align*}

---

**Problem 7: Inner Product with Transpose Operation**

Given matrices:
$$A=\begin{bmatrix}2&3\\4&5\end{bmatrix}$$
$$B=\begin{bmatrix}6&7\\8&9\end{bmatrix}$$

**Solution:**

\begin{align*}
\langle A,B \rangle &= \sum_{i,j} A_{ij} B_{ij} \\
&= 2\cdot6 + 3\cdot7 + \\
&\quad 4\cdot8 + 5\cdot9 \\
&= 12 + 21 + 32 + 45 \\
&= 110
\end{align*}

---

**Problem 8: Inner Product of Symmetric Matrices**

Given symmetric matrices:
$$A=\begin{bmatrix}1&2\\2&3\end{bmatrix}$$
$$B=\begin{bmatrix}4&5\\5&6\end{bmatrix}$$

**Solution:**

\begin{align*}
\langle A,B \rangle &= \sum_{i,j} A_{ij} B_{ij} \\
&= 1\cdot4 + 2\cdot5 + \\
&\quad 2\cdot5 + 3\cdot6 \\
&= 4 + 10 + 10 + 18 \\
&= 42
\end{align*}

---

**Problem 9: Inner Product with Complex Matrices**

Given matrices:
$$A=\begin{bmatrix}1+i&2-i\\3+i&4-i\end{bmatrix}$$
$$B=\begin{bmatrix}5-i&6+i\\7-i&8+i\end{bmatrix}$$

**Solution:**

\begin{align*}
\langle A,B \rangle &= \sum_{i,j} \text{Re}(A_{ij} \overline{B_{ij}}) \\
&= (1+i)\cdot(5+i) + (2-i)\cdot(6-i) + \\
&\quad (3+i)\cdot(7+i) + (4-i)\cdot(8+i) \\
&= (5+i+5i-i^2) + (12-i-6i+i^2) + \\
&\quad (21+i+7i-i^2) + (32+i-8i-i^2) \\
&= 5+5 + 12 - 6 + 21 + 32 - 2 \\
&= 62
\end{align*}

---

**Problem 10: Inner Product of 4x4 Matrices**

Given matrices:
$$A=\begin{bmatrix}1&2&3&4\\5&6&7&8\\9&10&11&12\\13&14&15&16\end{bmatrix}$$
$$B=\begin{bmatrix}16&15&14&13\\12&11&10&9\\8&7&6&5\\4&3&2&1\end{bmatrix}$$

**Solution:**

\begin{align*}
\langle A,B \rangle &= \sum_{i,j} A_{ij} B_{ij} \\
&= 1\cdot16 + 2\cdot15 + 3\cdot14 + 4\cdot13 + \\
&\quad 5\cdot12 + 6\cdot11 + 7\cdot10 + 8\cdot9 + \\
&\quad 9\cdot8 + 10\cdot7 + 11\cdot6 + 12\cdot5 + \\
&\quad 13\cdot4 + 14\cdot3 + 15\cdot2 + 16\cdot1 \\
&= 16 + 30 + 42 + 52 + 60 + 66 + 70 + 72 + \\
&\quad 72 + 70 + 66 + 60 + 52 + 42 + 30 + 16 \\
&= 696
\end{align*}

----

Now let's look into the computational part of *inner product*.

1. Compute Inner Product from Scratch (without Libraries)

Here’s how you can compute the inner product from the scratch:

```{python}
# Define matrices A and B
A = [[1, 2, 3], [4, 5, 6]]
B = [[7, 8, 9], [10, 11, 12]]

# Function to compute inner product
def inner_product(A, B):
    # Get the number of rows and columns
    num_rows = len(A)
    num_cols = len(A[0])
    
    # Initialize the result
    result = 0
    
    # Compute the inner product
    for i in range(num_rows):
        for j in range(num_cols):
            result += A[i][j] * B[i][j]
    
    return result

# Compute inner product
inner_product_result = inner_product(A, B)

# Display result
print("Inner Product (From Scratch):")
print(inner_product_result)
```

2. Compute Inner Product Using `NumPy`

Here’s how to compute the inner product using Numpy:

```{python}
import numpy as np
# Define matrices A and B
A = np.array([[1, 2, 3], [4, 5, 6]])
B = np.array([[7, 8, 9], [10, 11, 12]])
# calculating innerproduct
inner_product = (A*B).sum() # calculate element-wise product, then column sum

print("Inner Product (Using numpy):")
print(inner_product)
```

The same operation can be done using `SymPy` functions as follows.

```{python}
import sympy as sp
import numpy as np  
# Define matrices A and B
A = sp.Matrix([[1, 2, 3], [4, 5, 6]])
B = sp.Matrix([[7, 8, 9], [10, 11, 12]])

# Compute element-wise product
elementwise_product = A.multiply_elementwise(B)

# Calculate sum of each column
inner_product_sympy = np.sum(elementwise_product)

# Display result
print("Inner Product (Using SymPy):")
print(inner_product_sympy)
```

A vector dot product (in Physics) can be calculated using `SymPy` `.dot()` function as shown below. 

Let $A=\begin{pmatrix}1&2&3\end{pmatrix}$ and $B=\begin{pmatrix}4&5&6\end{pmatrix}$, then the dot product, $A\cdot B$ is computed as:

```{python}
import sympy as sp
A=sp.Matrix([1,2,3])
B=sp.Matrix([4,5,6])
display(A.dot(B)) # calculate fot product of A and B
```
:::{.callout-warning}
## A word of caution
In `SymPy` , `sp.Matrix([1,2,3])` create a column vector. But `np.array([1,2,3])` creates a row vector. So be careful while applying matrix/ dot product operations on these objects.
:::

The same dot product using `numpy` object can be done as follows:

```{python}
import numpy as np
A=np.array([1,2,3])
B=np.array([4,5,6])
display(A.dot(B.T))# dot() stands for dot product B.T represents the transpose of B
```
**Practical Applications**

Application 1: Signal Processing

In signal processing, the inner product can be used to measure the similarity between two signals. Here the most popular measure of similarity is the `cosine` similarity. This measure is defined as:

$$\cos \theta=\dfrac{A\cdot B}{||A|| ||B||}$$

Now consider two digital signals are given. It's cosine similarity measure can be calculated with a simulated data as shown below.

```{python}
import numpy as np

# Simulated large signals (1D array) using NumPy
signal1 = np.sin(np.random.rand(1000))
signal2 = np.cos(np.random.rand(1000))

# Compute inner product
inner_product_signal = np.dot(signal1, signal2)
#cosine_sim=np.dot(signal1,signal2)/(np.linalg.norm(signal1)*np.linalg.norm(signal2))
# Display result
cosine_sim=inner_product_signal/(np.sqrt(np.dot(signal1,signal1))*np.sqrt(np.dot(signal2,signal2)))
print("Inner Product (Using numpy):")
print(inner_product_signal)
print("Similarity of signals:")
print(cosine_sim)
```
Application 2: Machine Learning - Feature Similarity

In machine learning, the inner product is used to calculate the similarity between feature vectors.

```{python}
import numpy as np

# Simulated feature vectors (2D array) using NumPy
features1 = np.random.rand(100, 10)
features2 = np.random.rand(100, 10)

# Compute inner product for each feature vector
inner_products = np.einsum('ij,ij->i', features1, features2) # use Einstien's sum

# Display results
print("Inner Products of Feature Vectors:")
display(inner_products)
```

Application 3: Covariance Matrix in Statistics

The inner product can be used to compute covariance matrices for statistical data analysis. If $X$ is a given distribution and $x=X-\bar{X}$. Then the covariance of $X$ can be calculated as $cov(X)=\dfrac{1}{n-1}(x\cdot x^T)$ ^[Remember that the covariance of $X$ is defined as $Cov(X)=\dfrac{\sum (X-\bar{X})^2}{n-1}$]. The python code a simulated data is shown below.

```{python}
import sympy as sp
import numpy as np

# Simulated large dataset (2D array) using NumPy
data = np.random.rand(100, 10)

# Compute the mean of each column
mean = np.mean(data, axis=0)

# Center the data
centered_data = data - mean

# Compute the covariance matrix using matrix product operation
cov_matrix = (centered_data.T @ centered_data) / (centered_data.shape[0] - 1)
cov_matrix_sympy = sp.Matrix(cov_matrix)

# Display results
print("Covariance Matrix:")
display(cov_matrix_sympy)
```

These examples demonstrate the use of inner product and dot product in various applications.

#### Outer Product

The outer product of two vectors results in a matrix, and it is a way to combine these vectors into a higher-dimensional representation.

:::{.callout-note}

### Definition (Outer Product)

For two vectors $\mathbf{u}$ and $\mathbf{v}$ of dimensions $m$ and $n$ respectively, the outer product $\mathbf{u} \otimes \mathbf{v}$ is an $m \times n$ matrix defined as:

$$(\mathbf{u} \otimes \mathbf{v})_{ij} = u_i \cdot v_j$$

where $\cdot$ denotes the outer product operation. In matrix notation, for two column vectors $u,v$, 
$$u\otimes v=uv^T$$
:::


:::{.callout-note}
### Properties

1.  **Linearity**:
  $$(\mathbf{u} + \mathbf{w}) \otimes \mathbf{v} = (\mathbf{u} \otimes \mathbf{v}) + (\mathbf{w} \otimes \mathbf{v})$$
  
2.  **Distributivity**:
  $$\mathbf{u} \otimes (\mathbf{v} + \mathbf{w}) = (\mathbf{u} \otimes \mathbf{v}) + (\mathbf{u} \otimes \mathbf{w})$$
  
3.  **Associativity**:
  $$(\mathbf{u} \otimes \mathbf{v}) \otimes \mathbf{w} = \mathbf{u} \otimes (\mathbf{v} \otimes \mathbf{w})$$

:::

Some simple examples of outer product is given below.

**Example 1: Basic Outer Product**

Given vectors:

$$\mathbf{u} = \begin{pmatrix}
1 \\
2
\end{pmatrix}, \quad
\mathbf{v} = \begin{pmatrix}
3 \\
4 \\
5\end{pmatrix}$$

The outer product $\mathbf{u} \otimes \mathbf{v}$ is:

$$\mathbf{u} \otimes \mathbf{v} = \begin{pmatrix}
1 \cdot 3 & 1 \cdot 4 & 1 \cdot 5 \\
2 \cdot 3 & 2 \cdot 4 & 2 \cdot 5
\end{pmatrix} = \begin{pmatrix}
3 & 4 & 5 \\
6 & 8 & 10
\end{pmatrix}$$

**Example 2: Outer Product with Larger Vectors**

Given vectors:
$$\mathbf{u} = \begin{pmatrix}
1 \\
2 \\
3
\end{pmatrix}, \quad
\mathbf{v} = \begin{pmatrix}
4 \\
5
\end{pmatrix}$$

The outer product $\mathbf{u} \otimes \mathbf{v}$ is:

$$\mathbf{u} \otimes \mathbf{v} = \begin{pmatrix}
1 \cdot 4 & 1 \cdot 5 \\
2 \cdot 4 & 2 \cdot 5 \\
3 \cdot 4 & 3 \cdot 5
\end{pmatrix} = \begin{pmatrix}
4 & 5 \\
8 & 10 \\
12 & 15
\end{pmatrix}$$


#### Practice Problems

**Find the outer product of A and B where A and B are given as follows:**

**Problem 1:**

Find the outer product of:
$$A=\begin{bmatrix}1\\2\end{bmatrix}$$
$$B=\begin{bmatrix}3&4\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}1\\2\end{bmatrix} \otimes \begin{bmatrix}3&4\end{bmatrix} \\
&= \begin{bmatrix}
1 \cdot 3 & 1 \cdot 4 \\
2 \cdot 3 & 2 \cdot 4
\end{bmatrix} \\
&= \begin{bmatrix}
3 & 4 \\
6 & 8
\end{bmatrix}
\end{align*}

---

**Problem 2:**

Find the outer product of:
$$A=\begin{bmatrix}1\\2\\3\end{bmatrix}$$
$$B=\begin{bmatrix}4&5&6\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}1\\2\\3\end{bmatrix} \otimes \begin{bmatrix}4&5&6\end{bmatrix} \\
&= \begin{bmatrix}
1 \cdot 4 & 1 \cdot 5 & 1 \cdot 6 \\
2 \cdot 4 & 2 \cdot 5 & 2 \cdot 6 \\
3 \cdot 4 & 3 \cdot 5 & 3 \cdot 6
\end{bmatrix} \\
&= \begin{bmatrix}
4 & 5 & 6 \\
8 & 10 & 12 \\
12 & 15 & 18
\end{bmatrix}
\end{align*}

---

**Problem 3:**

Find the outer product of:
$$A=\begin{bmatrix}1&2\end{bmatrix}$$
$$B=\begin{bmatrix}3\\4\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}1&2\end{bmatrix} \otimes \begin{bmatrix}3\\4\end{bmatrix} \\
&= \begin{bmatrix}
1 \cdot 3 & 1 \cdot 4 \\
2 \cdot 3 & 2 \cdot 4
\end{bmatrix} \\
&= \begin{bmatrix}
3 & 4 \\
6 & 8
\end{bmatrix}
\end{align*}

---

**Problem 4:**

Find the outer product of:
$$A=\begin{bmatrix}0\\1\end{bmatrix}$$
$$B=\begin{bmatrix}1&-1\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}0\\1\end{bmatrix} \otimes \begin{bmatrix}1&-1\end{bmatrix} \\
&= \begin{bmatrix}
0 \cdot 1 & 0 \cdot -1 \\
1 \cdot 1 & 1 \cdot -1
\end{bmatrix} \\
&= \begin{bmatrix}
0 & 0 \\
1 & -1
\end{bmatrix}
\end{align*}

---

**Problem 5:**

Find the outer product of:
$$A=\begin{bmatrix}2\\3\end{bmatrix}$$
$$B=\begin{bmatrix}5&-2\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}2\\3\end{bmatrix} \otimes \begin{bmatrix}5&-2\end{bmatrix} \\
&= \begin{bmatrix}
2 \cdot 5 & 2 \cdot -2 \\
3 \cdot 5 & 3 \cdot -2
\end{bmatrix} \\
&= \begin{bmatrix}
10 & -4 \\
15 & -6
\end{bmatrix}
\end{align*}

---

**Problem 6:**

Find the outer product of:
$$A=\begin{bmatrix}1\\0\\1\end{bmatrix}$$
$$B=\begin{bmatrix}2&-1&0\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}1\\0\\1\end{bmatrix} \otimes \begin{bmatrix}2&-1&0\end{bmatrix} \\
&= \begin{bmatrix}
1 \cdot 2 & 1 \cdot -1 & 1 \cdot 0 \\
0 \cdot 2 & 0 \cdot -1 & 0 \cdot 0 \\
1 \cdot 2 & 1 \cdot -1 & 1 \cdot 0
\end{bmatrix} \\
&= \begin{bmatrix}
2 & -1 & 0 \\
0 & 0 & 0 \\
2 & -1 & 0
\end{bmatrix}
\end{align*}

---

**Problem 7:**

Find the outer product of:
$$A=\begin{bmatrix}1\\-1\end{bmatrix}$$
$$B=\begin{bmatrix}2&0\\3&-1\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &=\begin{bmatrix}1\\-1\end{bmatrix}\otimes \begin{bmatrix}2&0\\3&-1\end{bmatrix}\\
&= \begin{bmatrix}
2 & 3&0&-1 \\
-2&-3&0&1
\end{bmatrix}
\end{align*}
---

**Problem 8:**

Find the outer product of:
$$A=\begin{bmatrix}3\\4\end{bmatrix}$$
$$B=\begin{bmatrix}1&-2&3\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}3\\4\end{bmatrix} \otimes \begin{bmatrix}1&-2&3\end{bmatrix} \\
&= \begin{bmatrix}
3 \cdot 1 & 3 \cdot -2 & 3 \cdot 3 \\
4 \cdot 1 & 4 \cdot -2 & 4 \cdot 3
\end{bmatrix} \\
&= \begin{bmatrix}
3 & -6 & 9 \\
4 & -8 & 12
\end{bmatrix}
\end{align*}

---

**Problem 9:**

Find the outer product of:
$$A=\begin{bmatrix}2\\3\\-1\end{bmatrix}$$
$$B=\begin{bmatrix}4&-2\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}2\\3\\-1\end{bmatrix} \otimes \begin{bmatrix}4&-2\end{bmatrix} \\
&= \begin{bmatrix}
2 \cdot 4 & 2 \cdot -2 \\
3 \cdot 4 & 3 \cdot -2 \\
-1 \cdot 4 & -1 \cdot -2
\end{bmatrix} \\
&= \begin{bmatrix}
8 & -4 \\
12 & -6 \\
-4 & 2
\end{bmatrix}
\end{align*}

---

**Problem 10:**

Find the outer product of:
$$A=\begin{bmatrix}0\\5\end{bmatrix}$$
$$B=\begin{bmatrix}3&1\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}0\\5\end{bmatrix} \otimes \begin{bmatrix}3&1\end{bmatrix} \\
&= \begin{bmatrix}
0 \cdot 3 & 0 \cdot 1 \\
5 \cdot 3 & 5 \cdot 1
\end{bmatrix} \\
&= \begin{bmatrix}
0 & 0 \\
15 & 5
\end{bmatrix}
\end{align*}

----

**1. Compute Outer Product of Vectors from Scratch (without Libraries)**

Here’s how you can compute the outer product manually:

```{python}
# Define vectors u and v
u = [1, 2]
v = [3, 4, 5]

# Function to compute outer product
def outer_product(u, v):
    # Initialize the result
    result = [[a * b for b in v] for a in u]
    return result

# Compute outer product
outer_product_result = outer_product(u, v)

# Display result
print("Outer Product of Vectors (From Scratch):")
for row in outer_product_result:
    print(row)
```

**2. Compute Outer Product of Vectors Using SymPy**

Here’s how to compute the outer product using `SymPy`:

```{python}
import sympy as sp

# Define vectors u and v
u = sp.Matrix([1, 2])
v = sp.Matrix([3, 4, 5])

# Compute outer product using SymPy
outer_product_sympy = u * v.T

# Display result
print("Outer Product of Vectors (Using SymPy):")
display(outer_product_sympy)
```

**Outer Product of Matrices**
 
The outer product of two matrices extends the concept from vectors to higher-dimensional tensors. For two matrices $A$ and $B$, the outer product results in a higher-dimensional tensor and is generally expressed as block matrices.

:::{.callout-note}
### Definition (Outer Product of Matrices)

For two matrices $A$ of dimension $m \times p$ and $B$ of dimension $q \times n$, the outer product $A \otimes B$ results in a tensor of dimension $m \times q \times p \times n$. The entries of the tensor are given by:

$$(A \otimes B)_{ijkl} = A_{ij} \cdot B_{kl}$$

where $\cdot$ denotes the outer product operation.
:::

:::{.callout-note}

### Properties

1.  **Linearity**:
  $$(A + C) \otimes B = (A \otimes B) + (C \otimes B)$$
  
2.  **Distributivity**:
  $$A \otimes (B + D) = (A \otimes B) + (A \otimes D)$$
  
3. **Associativity**:

  $$(A \otimes B) \otimes C = A \otimes (B \otimes C)$$
:::

Here are some simple examples to demonstrate the mathematical procedure to find outer product of matrices.

**Example 1: Basic Outer Product of Matrices**

Given matrices:
$$
A = \begin{pmatrix}
1 & 2 \\
3 & 4
\end{pmatrix}, \quad
B = \begin{pmatrix}
5 \\
6
\end{pmatrix}$$

The outer product $A \otimes B$ is:

$$A \otimes B = \begin{pmatrix}
1 \cdot 5 & 1 \cdot 6 \\
2 \cdot 5 & 2 \cdot 6 \\
3 \cdot 5 & 3 \cdot 6 \\
4 \cdot 5 & 4 \cdot 6
\end{pmatrix} = \begin{pmatrix}
5 & 6 \\
10 & 12 \\
15 & 18 \\
20 & 24
\end{pmatrix}$$

**Example 2: Outer Product with Larger Matrices**

Given matrices:

$$A = \begin{pmatrix}
1 & 2 & 3 \\
4 & 5 & 6
\end{pmatrix}, \quad
B = \begin{pmatrix}
7 \\
8
\end{pmatrix}$$

The outer product $A \otimes B$ is:

$$A \otimes B = \begin{pmatrix}
1 \cdot 7 & 1 \cdot 8 \\
2 \cdot 7 & 2 \cdot 8 \\
3 \cdot 7 & 3 \cdot 8 \\
4 \cdot 7 & 4 \cdot 8 \\
5 \cdot 7 & 5 \cdot 8 \\
6 \cdot 7 & 6 \cdot 8
\end{pmatrix} = \begin{pmatrix}
7 & 8 \\
14 & 16 \\
21 & 24 \\
28 & 32 \\
35 & 40 \\
42 & 48
\end{pmatrix}$$

Example 3: Compute the outer product of the following vectors $\mathbf{u} = [0, 1, 2]$ and $\mathbf{v} = [2, 3, 4]$.

To find the outer product, we calculate each element $(i, j)$ as the product of the $(i)$-th element of $\mathbf{u}$ and the $(j)$-th element of $\mathbf{v}$. Mathematically:

$$\mathbf{u} \otimes \mathbf{v} = \begin{bmatrix}
0 \cdot 2 & 0 \cdot 3 & 0 \cdot 4 \\
1 \cdot 2 & 1 \cdot 3 & 1 \cdot 4 \\
2 \cdot 2 & 2 \cdot 3 & 2 \cdot 4
\end{bmatrix}
= \begin{bmatrix}
0 & 0 & 0 \\
2 & 3 & 4 \\
4 & 6 & 8
\end{bmatrix}$$

**1. Compute Outer Product of Matrices from Scratch (without Libraries)**

Here’s how you can compute the outer product manually:

```{python}
# Define matrices A and B
A = [[1, 2], [3, 4]]
B = [[5], [6]]

# Function to compute outer product
def outer_product_matrices(A, B):
    m = len(A)
    p = len(A[0])
    q = len(B)
    n = len(B[0])
    result = [[0] * (n * p) for _ in range(m * q)]

    for i in range(m):
        for j in range(p):
            for k in range(q):
                for l in range(n):
                    result[i*q + k][j*n + l] = A[i][j] * B[k][l]

    return result

# Compute outer product
outer_product_result_matrices = outer_product_matrices(A, B)

# Display result
print("Outer Product of Matrices (From Scratch):")
for row in outer_product_result_matrices:
    print(row)
```

Here is the `Python` code to compute the outer product of these vectors using the `NumPy` function `.outer()`:

```{python}
import numpy as np

# Define vectors
u = np.array([[1,2],[3,4]])
v = np.array([[5],[4]])

# Compute outer product
outer_product = np.outer(u, v)

print("Outer Product of u and v:")
display(outer_product)
```

**Example 3: Real-world Application in Recommendation Systems**

In recommendation systems, the outer product can represent user-item interactions. A simple context is here. Let the user preferences of items is given as $u=[4, 3, 5]$ and the item scores is given by $v=[2, 5, 4]$. Now the recommendation score can be calculated as the outer product of these two vectors. Calculation of this score is shown below.
The outer product $\mathbf{u} \otimes \mathbf{v}$ is calculated as follows:

$$\mathbf{u} \otimes \mathbf{v} = \begin{bmatrix}
4 \cdot 2 & 4 \cdot 5 & 4 \cdot 4 \\
3 \cdot 2 & 3 \cdot 5 & 3 \cdot 4 \\
5 \cdot 2 & 5 \cdot 5 & 5 \cdot 4
\end{bmatrix}
= \begin{bmatrix}
8 & 20 & 16 \\
6 & 15 & 12 \\
10 & 25 & 20
\end{bmatrix}$$

The python code for this task is given below.

```{python}
import numpy as np
import matplotlib.pyplot as plt

# Define the user and product ratings vectors
user_ratings = np.array([4, 3, 5])
product_ratings = np.array([2, 5, 4])

# Compute the outer product
predicted_ratings = np.outer(user_ratings, product_ratings)

# Print the predicted ratings matrix
print("Predicted Ratings Matrix:")
display(predicted_ratings)

# Plot the result
plt.imshow(predicted_ratings, cmap='coolwarm', interpolation='nearest')
plt.colorbar()
plt.title('Predicted Ratings Matrix (Recommendation System)')
plt.xlabel('Product Ratings')
plt.ylabel('User Ratings')
plt.xticks(ticks=np.arange(len(product_ratings)), labels=product_ratings)
plt.yticks(ticks=np.arange(len(user_ratings)), labels=user_ratings)
plt.show()
```

:::{.callout-note}
### Additional Properties & Definitions

1. **Definition and Properties**

   Given two vectors:
   - $\mathbf{u} \in \mathbb{R}^m$
   - $\mathbf{v} \in \mathbb{R}^n$

   The outer product $\mathbf{u} \otimes \mathbf{v}$ results in an $m \times n$ matrix where each element $(i, j)$ of the matrix is calculated as:
   $$(\mathbf{u} \otimes \mathbf{v})_{ij} = u_i \cdot v_j$$

2. **Non-Symmetry**

   The outer product is generally not symmetric. For vectors $\mathbf{u}$ and $\mathbf{v}$, the matrix $\mathbf{u} \otimes \mathbf{v}$ is not necessarily equal to $\mathbf{v} \otimes \mathbf{u}$:
   $$\mathbf{u} \otimes \mathbf{v} \neq \mathbf{v} \otimes \mathbf{u}$$

3. **Rank of the Outer Product**

   The rank of the outer product matrix $\mathbf{u} \otimes \mathbf{v}$ is always 1, provided neither $\mathbf{u}$ nor $\mathbf{v}$ is a zero vector. This is because the matrix can be expressed as a single rank-1 matrix.

4. **Distributive Property**

   The outer product is distributive over vector addition. For vectors $\mathbf{u}_1, \mathbf{u}_2 \in \mathbb{R}^m$ and $\mathbf{v} \in \mathbb{R}^n$:
   $$(\mathbf{u}_1 + \mathbf{u}_2) \otimes \mathbf{v} = (\mathbf{u}_1 \otimes \mathbf{v}) + (\mathbf{u}_2 \otimes \mathbf{v})$$

5. **Associativity with Scalar Multiplication**

   The outer product is associative with scalar multiplication. For a scalar $\alpha$ and vectors $\mathbf{u} \in \mathbb{R}^m$ and $\mathbf{v} \in \mathbb{R}^n$:
   $$\alpha (\mathbf{u} \otimes \mathbf{v}) = (\alpha \mathbf{u}) \otimes \mathbf{v} = \mathbf{u} \otimes (\alpha \mathbf{v})$$

6. **Matrix Trace**

   The trace of the outer product of two vectors is given by:
   $$\text{tr}(\mathbf{u} \otimes \mathbf{v}) = (\mathbf{u}^T \mathbf{v})= (\mathbf{v}^T \mathbf{u})$$
   Here, $\text{tr}$ denotes the trace of a matrix, which is the sum of its diagonal elements.

7. **Matrix Norm**

   The Frobenius norm of the outer product matrix can be expressed in terms of the norms of the original vectors:
   $$\| \mathbf{u} \otimes \mathbf{v} \|_F = \| \mathbf{u} \|_2 \cdot \| \mathbf{v} \|_2$$
   where $\| \cdot \|_2$ denotes the Euclidean norm.

:::

**Example Calculation in `Python`**

Here’s how to compute and visualize the outer product properties using `Python`:

```{python}
#| label: fig-op
#| fig-cap: "Demonstration of Outer Product and its Properties"
import numpy as np
import matplotlib.pyplot as plt

# Define vectors
u = np.array([1, 2, 3])
v = np.array([4, 5])

# Compute outer product
outer_product = np.outer(u, v)

# Display results
print("Outer Product Matrix:")
print(outer_product)

# Compute and display rank
rank = np.linalg.matrix_rank(outer_product)
print(f"Rank of Outer Product Matrix: {rank}")

# Compute Frobenius norm
frobenius_norm = np.linalg.norm(outer_product, 'fro')
print(f"Frobenius Norm: {frobenius_norm}")

# Plot the result
plt.imshow(outer_product, cmap='viridis', interpolation='nearest')
plt.colorbar()
plt.title('Outer Product Matrix')
plt.xlabel('Vector v')
plt.ylabel('Vector u')
plt.xticks(ticks=np.arange(len(v)), labels=v)
plt.yticks(ticks=np.arange(len(u)), labels=u)
plt.show()
```

#### Kronecker Product

In mathematics, the Kronecker product, sometimes denoted by $\otimes$, is an operation on two matrices of arbitrary size resulting in a *block matrix*. It is a specialization of the tensor product (which is denoted by the same symbol) from vectors to matrices and gives the matrix of the tensor product linear map with respect to a standard choice of basis. The Kronecker product is to be distinguished from the usual matrix multiplication, which is an entirely different operation. The Kronecker product is also sometimes called *matrix direct product*.

:::{.callout-note}
If $A$ is an $m \times n$ matrix and $B$ is a $p \times q$ matrix, then the Kronecker product $A\otimes B$ is the $pm \times qn$ block matrix defined as: Each
$a_{ij}$ of $A$ is replaced by the matrix $a_{ij}B$. Symbolically this will result in a block matrix defined by:

$$A\otimes B=\begin{bmatrix}A \otimes B = \begin{bmatrix}
a_{11}B & a_{12}B & \cdots & a_{1n}B \\
a_{21}B & a_{22}B & \cdots & a_{2n}B \\
\vdots & \vdots & \ddots & \vdots \\
a_{m1}B & a_{m2}B & \cdots & a_{mn}B
\end{bmatrix} \end{bmatrix}$$
:::

:::{.callout-note}

#### Properties of the Kronecker Product

1. **Associativity**

   The Kronecker product is associative. For matrices $A \in \mathbb{R}^{m \times n}$, $B \in \mathbb{R}^{p \times q}$, and $C \in \mathbb{R}^{r \times s}$:
   $$(A \otimes B) \otimes C = A \otimes (B \otimes C)$$

2. **Distributivity Over Addition**

   The Kronecker product distributes over matrix addition. For matrices $A \in \mathbb{R}^{m \times n}$, $B \in \mathbb{R}^{p \times q}$, and $C \in \mathbb{R}^{p \times q}$:
   $$A \otimes (B + C) = (A \otimes B) + (A \otimes C)$$

3. **Mixed Product Property**

   The Kronecker product satisfies the mixed product property with the matrix product. For matrices $A \in \mathbb{R}^{m \times n}$, $B \in \mathbb{R}^{p \times q}$, $C \in \mathbb{R}^{r \times s}$, and $D \in \mathbb{R}^{r \times s}$:
   $$(A \otimes B) (C \otimes D) = (A C) \otimes (B D)$$

4. **Transpose**

   The transpose of the Kronecker product is given by:
   $$(A \otimes B)^T = A^T \otimes B^T$$

5. **Norm**

   The Frobenius norm of the Kronecker product can be computed as:
  $$\| A \otimes B \|_F = \| A \|_F \cdot \| B \|_F$$
   where $\| \cdot \|_F$ denotes the Frobenius norm.
:::

----

:::{.callout-tip}


#### Frobenius Norm

The Frobenius norm, also known as the Euclidean norm for matrices, is a measure of a matrix's magnitude. It is defined as the square root of the sum of the absolute squares of its elements. Mathematically, for a matrix $A$ with elements $a_{ij}$, the Frobenius norm is given by:

$$\|A\|_F = \sqrt{\sum_{i,j} |a_{ij}|^2}$$

:::

Example 1: Calculation of Frobenius Norm

Consider the matrix $A$:

$$A = \begin{bmatrix}
1 & 2 \\
3 & 4
\end{bmatrix}$$

To compute the Frobenius norm:

$$\|A\|_F = \sqrt{1^2 + 2^2 + 3^2 + 4^2}
= \sqrt{1 + 4 + 9 + 16}
= \sqrt{30}
\approx 5.48$$

Example 2: Frobenius Norm of a Sparse Matrix

Consider the sparse matrix $B$:

$$B = \begin{bmatrix}
0 & 0 & 0 \\
0 & 5 & 0 \\
0 & 0 & 0
\end{bmatrix}$$

To compute the Frobenius norm:

$$\|B\|_F = \sqrt{0^2 + 0^2 + 0^2 + 5^2 + 0^2 + 0^2}
= \sqrt{25}
= 5$$

Example 3: Frobenius Norm in a Large Matrix

Consider the matrix $C$ of size $3 \times 3 $:

$$C = \begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{bmatrix}$$

To compute the Frobenius norm:

\begin{align*}
\|C\|_F &= \sqrt{1^2 + 2^2 + 3^2 + 4^2 + 5^2 + 6^2 + 7^2 + 8^2 + 9^2}\\
&= \sqrt{1 + 4 + 9 + 16 + 25 + 36 + 49 + 64 + 81}
&= \sqrt{285}
&\approx 16.88
\end{align*}

**Applications of the Frobenius Norm**

- *Application 1: Image Compression:* In image processing, the Frobenius norm can measure the difference between the original and compressed images, indicating how well the compression has preserved the original image quality.

- *Application 2: Matrix Factorization:* In numerical analysis, Frobenius norm is used to evaluate the error in matrix approximations, such as in Singular Value Decomposition (SVD). A lower Frobenius norm of the error indicates a better approximation.

- *Application 3: Error Measurement in Numerical Solutions:* In solving systems of linear equations, the Frobenius norm can be used to measure the error between the true solution and the computed solution, providing insight into the accuracy of numerical methods.

The `linalg` sub module of `NumPy` library can be used to calculate various norms. Basically norm is the generalized form of Euclidean distance.

```{python}
import numpy as np

# Example 1: Simple Matrix
A = np.array([[1, 2], [3, 4]])
frobenius_norm_A = np.linalg.norm(A, 'fro')
print(f"Frobenius Norm of A: {frobenius_norm_A:.2f}")

# Example 2: Sparse Matrix
B = np.array([[0, 0, 0], [0, 5, 0], [0, 0, 0]])
frobenius_norm_B = np.linalg.norm(B, 'fro')
print(f"Frobenius Norm of B: {frobenius_norm_B:.2f}")

# Example 3: Large Matrix
C = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
frobenius_norm_C = np.linalg.norm(C, 'fro')
print(f"Frobenius Norm of C: {frobenius_norm_C:.2f}")
```
**Frobenius norm of Kronecker product**

Let us consider two matrices,

$$A = \begin{bmatrix}
1 & 2 \\
3 & 4
\end{bmatrix}$$

and

$$B = \begin{bmatrix}
0 & 5 \\
6 & 7
\end{bmatrix}$$

The Kronecker product $C = A \otimes B$ is:

$$C = \begin{bmatrix}
1 \cdot B & 2 \cdot B \\
3 \cdot B & 4 \cdot B
\end{bmatrix}
= \begin{bmatrix}
\begin{bmatrix}
0 & 5 \\
6 & 7
\end{bmatrix} & \begin{bmatrix}
0 \cdot 2 & 5 \cdot 2 \\
6 \cdot 2 & 7 \cdot 2
\end{bmatrix} \\
\begin{bmatrix}
0 \cdot 3 & 5 \cdot 3 \\
6 \cdot 3 & 7 \cdot 3
\end{bmatrix} & \begin{bmatrix}
0 \cdot 4 & 5 \cdot 4 \\
6 \cdot 4 & 7 \cdot 4
\end{bmatrix}
\end{bmatrix}$$

This expands to:

$$C = \begin{bmatrix}
0 & 5 & 0 & 10 \\
6 & 7 & 12 & 14 \\
0 & 15 & 0 & 20 \\
18 & 21 & 24 & 28
\end{bmatrix}$$

*Computing the Frobenius Norm*

To compute the Frobenius norm of $C$:

$$\|C\|_F = \sqrt{\sum_{i=1}^{4} \sum_{j=1}^{4} |c_{ij}|^2}$$

$$\|C\|_F = \sqrt{0^2 + 5^2 + 0^2 + 10^2 + 6^2 + 7^2 + 12^2 + 14^2 + 0^2 + 15^2 + 0^2 + 20^2 + 18^2 + 21^2 + 24^2 + 28^2}$$

$$\|C\|_F = \sqrt{0 + 25 + 0 + 100 + 36 + 49 + 144 + 196 + 0 + 225 + 0 + 400 + 324 + 441 + 576 + 784}$$

$$\|C\|_F = \sqrt{2896}$$
$$\|C\|_F \approx 53.87$$

----

#### Practice Problems

**Find the Kronecker product of A and B where A and B are given as follows:**

**Problem 1:**

Find the Kronecker product of:
$$A=\begin{bmatrix}1&2\\3&4\end{bmatrix}$$
$$B=\begin{bmatrix}0&1\\1&0\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}1&2\\3&4\end{bmatrix} \otimes \begin{bmatrix}0&1\\1&0\end{bmatrix} \\
&= \begin{bmatrix}
1 \cdot \begin{bmatrix}0&1\\1&0\end{bmatrix} & 2 \cdot \begin{bmatrix}0&1\\1&0\end{bmatrix} \\
3 \cdot \begin{bmatrix}0&1\\1&0\end{bmatrix} & 4 \cdot \begin{bmatrix}0&1\\1&0\end{bmatrix}
\end{bmatrix} \\
&= \begin{bmatrix}
0 & 1 & 0 & 2 \\
1 & 0 & 2& 0\\
0 & 3 & 0 & 4 \\
3 & 0 & 4 & 0
\end{bmatrix}
\end{align*}

---

**Problem 2:**

Find the Kronecker product of:
$$A=\begin{bmatrix}1&0\\0&1\end{bmatrix}$$
$$B=\begin{bmatrix}2&3\\4&5\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}1&0\\0&1\end{bmatrix} \otimes \begin{bmatrix}2&3\\4&5\end{bmatrix} \\
&= \begin{bmatrix}
1 \cdot \begin{bmatrix}2&3\\4&5\end{bmatrix} & 0 \cdot \begin{bmatrix}2&3\\4&5\end{bmatrix} \\
0 \cdot \begin{bmatrix}2&3\\4&5\end{bmatrix} & 1 \cdot \begin{bmatrix}2&3\\4&5\end{bmatrix}
\end{bmatrix} \\
&= \begin{bmatrix}
2 & 3 & 0 & 0 \\
4 & 5 & 0 & 0 \\
0 & 0 & 2 & 3 \\
0 & 0 & 4 & 5
\end{bmatrix}
\end{align*}

---

**Problem 3:**

Find the Kronecker product of:
$$A=\begin{bmatrix}1&2\end{bmatrix}$$
$$B=\begin{bmatrix}3\\4\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}1&2\end{bmatrix} \otimes \begin{bmatrix}3\\4\end{bmatrix} \\
&= \begin{bmatrix}
1 \cdot \begin{bmatrix}3\\4\end{bmatrix} & 2 \cdot \begin{bmatrix}3\\4\end{bmatrix}
\end{bmatrix} \\
&= \begin{bmatrix}
3 & 6 \\
4 & 8
\end{bmatrix}
\end{align*}

---

**Problem 4:**

Find the Kronecker product of:
$$A=\begin{bmatrix}0&1\end{bmatrix}$$
$$B=\begin{bmatrix}1&-1\\2&0\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}0&1\end{bmatrix} \otimes \begin{bmatrix}1&-1\\2&0\end{bmatrix} \\
&= \begin{bmatrix}
0 \cdot \begin{bmatrix}1&-1\\2&0\end{bmatrix} & 1 \cdot \begin{bmatrix}1&-1\\2&0\end{bmatrix}
\end{bmatrix} \\
&= \begin{bmatrix}
0 & 0 &1&-1\\
0 & 0&2&0 \\
\end{bmatrix}
\end{align*}

---

**Problem 5:**

Find the Kronecker product of:
$$A=\begin{bmatrix}2\\3\end{bmatrix}$$
$$B=\begin{bmatrix}4&-2\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}2\\3\end{bmatrix} \otimes \begin{bmatrix}4&-2\end{bmatrix} \\
&= \begin{bmatrix}
2 \cdot \begin{bmatrix}4&-2\end{bmatrix} \\
3 \cdot \begin{bmatrix}4&-2\end{bmatrix}
\end{bmatrix} \\
&= \begin{bmatrix}
8 & -4 \\
12 & -6
\end{bmatrix}
\end{align*}

---

**Problem 6:**

Find the Kronecker product of:
$$A=\begin{bmatrix}1&-1\\0&2\end{bmatrix}$$
$$B=\begin{bmatrix}0&1\\1&0\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}1&-1\\0&2\end{bmatrix} \otimes \begin{bmatrix}0&1\\1&0\end{bmatrix} \\
&= \begin{bmatrix}
1 \cdot \begin{bmatrix}0&1\\1&0\end{bmatrix} & -1 \cdot \begin{bmatrix}0&1\\1&0\end{bmatrix} \\
0 \cdot \begin{bmatrix}0&1\\1&0\end{bmatrix} & 2 \cdot \begin{bmatrix}0&1\\1&0\end{bmatrix}
\end{bmatrix} \\
&= \begin{bmatrix}
0 & 1 & 0 & -1 \\
1 & 0 & -1 & 0 \\
0 & 0 & 0 & 2 \\
0 & 0 & 2 & 0
\end{bmatrix}
\end{align*}

---

**Problem 7:**

Find the Kronecker product of:
$$A=\begin{bmatrix}2\end{bmatrix}$$
$$B=\begin{bmatrix}3&4\\5&6\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}2\end{bmatrix} \otimes \begin{bmatrix}3&4\\5&6\end{bmatrix} \\
&= 2 \cdot \begin{bmatrix}3&4\\5&6\end{bmatrix} \\
&= \begin{bmatrix}
6 & 8 \\
10 & 12
\end{bmatrix}
\end{align*}

---

**Problem 8:**

Find the Kronecker product of:
$$A=\begin{bmatrix}0&1\end{bmatrix}$$
$$B=\begin{bmatrix}1&0\\0&1\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}0&1\end{bmatrix} \otimes \begin{bmatrix}1&0\\0&1\end{bmatrix} \\
&= \begin{bmatrix}
0 \cdot \begin{bmatrix}1&0\\0&1\end{bmatrix} & 1 \cdot \begin{bmatrix}1&0\\0&1\end{bmatrix}
\end{bmatrix} \\
&= \begin{bmatrix}
0 & 0 \\
0 & 1
\end{bmatrix}
\end{align*}

---

**Problem 9:**

Find the Kronecker product of:
$$A=\begin{bmatrix}1&0\\0&1\end{bmatrix}$$
$$B=\begin{bmatrix}1&1\\1&1\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}1&0\\0&1\end{bmatrix} \otimes \begin{bmatrix}1&1\\1&1\end{bmatrix} \\
&= \begin{bmatrix}
1 \cdot \begin{bmatrix}1&1\\1&1\end{bmatrix} & 0 \cdot \begin{bmatrix}1&1\\1&1\end{bmatrix} \\
0 \cdot \begin{bmatrix}1&1\\1&1\end{bmatrix} & 1 \cdot \begin{bmatrix}1&1\\1&1\end{bmatrix}
\end{bmatrix} \\
&= \begin{bmatrix}
1 & 1 & 0 & 0 \\
1 & 1 & 0 & 0 \\
0 & 0 & 1 & 1 \\
0 & 0 & 1 & 1
\end{bmatrix}
\end{align*}

---

**Problem 10:**

Find the Kronecker product of:
$$A=\begin{bmatrix}2&-1\\3&4\end{bmatrix}$$
$$B=\begin{bmatrix}0&5\\-2&3\end{bmatrix}$$

**Solution:**

\begin{align*}
A \otimes B &= \begin{bmatrix}2&-1\\3&4\end{bmatrix} \otimes \begin{bmatrix}0&5\\-2&3\end{bmatrix} \\
&= \begin{bmatrix}
2 \cdot \begin{bmatrix}0&5\\-2&3\end{bmatrix} & -1 \cdot \begin{bmatrix}0&5\\-2&3\end{bmatrix} \\
3 \cdot \begin{bmatrix}0&5\\-2&3\end{bmatrix} & 4 \cdot \begin{bmatrix}0&5\\-2&3\end{bmatrix}
\end{bmatrix} \\
&= \begin{bmatrix}
0 & 10 & 0 & -5 \\
-4 & 6 & 2 & -3 \\
0 & 15 & 0 & 20 \\
-6 & 9 & -8 & 12
\end{bmatrix}
\end{align*}

----

#### Connection Between Outer Product and Kronecker Product

1. **Conceptual Connection:**

   - The **outer product** is a special case of the **Kronecker product**. Specifically, if $\mathbf{A}$ is a column vector and $\mathbf{B}$ is a row vector, then $\mathbf{A}$ is a $m \times 1$ matrix and $\mathbf{B}$ is a $1 \times n$ matrix. The Kronecker product of these two matrices will yield the same result as the outer product of these vectors.

   - For matrices $\mathbf{A}$ and $\mathbf{B}$, the Kronecker product involves taking the outer product of each element of $\mathbf{A}$ with the entire matrix $\mathbf{B}$.

2. **Mathematical Formulation:**

   - Let $\mathbf{A} = \begin{bmatrix}a_{11} & a_{12}\\ a_{21} & a_{22}\end{bmatrix}$ and $\mathbf{B} = \begin{bmatrix}b_{11} & b_{12}\\ b_{21} & b_{22}\end{bmatrix}$. Then:

   $$
   \mathbf{A} \otimes \mathbf{B} = \begin{bmatrix}
   a_{11} \mathbf{B} & a_{12} \mathbf{B} \\
   a_{21} \mathbf{B} & a_{22} \mathbf{B}
   \end{bmatrix}
   $$

   - If $\mathbf{A} = \mathbf{u} \mathbf{v}^T$ where $\mathbf{u}$ is a column vector and $\mathbf{v}^T$ is a row vector, then the Kronecker product of $\mathbf{u}$ and $\mathbf{v}^T$ yields the same result as the outer product $\mathbf{u} \otimes \mathbf{v}$.


:::{.callout-note}
**Summary**

- The **outer product** is a specific case of the **Kronecker product** where one of the matrices is a vector (either row or column). 
- The **Kronecker product** generalizes the outer product to matrices and is more versatile in applications involving tensor products and higher-dimensional constructs.

:::

#### Matrix Multiplication as Kronecker Product

Given matrices $\mathbf{A}$ and $\mathbf{B}$, where:
- $\mathbf{A}$ is an $m \times n$ matrix
- $\mathbf{B}$ is an $n \times p$ matrix

The product $\mathbf{C} = \mathbf{A} \mathbf{B}$ can be expressed using Kronecker products as:

$$
\mathbf{C} = \sum_{k=1}^n (\mathbf{A}_{:,k} \otimes \mathbf{B}_{k,:})
$$

where:
- $\mathbf{A}_{:,k}$ denotes the $k$-th column of matrix $\mathbf{A}$
- $\mathbf{B}_{k,:}$ denotes the $k$-th row of matrix $\mathbf{B}$

**Example:**

Let:

$$
\mathbf{A} = \begin{bmatrix}
1 & 2 \\
3 & 4
\end{bmatrix}
$$

and:

$$
\mathbf{B} = \begin{bmatrix}
0 & 1 \\
1 & 0
\end{bmatrix}
$$

To find $\mathbf{C} = \mathbf{A} \mathbf{B}$ using Kronecker products:

1. **Compute the Kronecker Product of Columns of $\mathbf{A}$ and Rows of $\mathbf{B}$:**

   - For column $\mathbf{A}_{:,1} = \begin{bmatrix} 1 \\ 3 \end{bmatrix}$ and row $\mathbf{B}_{1,:} = \begin{bmatrix} 0 & 1 \end{bmatrix}$:
     $$
     \mathbf{A}_{:,1} \otimes \mathbf{B}_{1,:} = \begin{bmatrix}
     0 & 1 \\
     0 & 3
     \end{bmatrix}
     $$

   - For column $\mathbf{A}_{:,2} = \begin{bmatrix} 2 \\ 4 \end{bmatrix}$ and row $\mathbf{B}_{2,:} = \begin{bmatrix} 1 & 0 \end{bmatrix}$:
     $$\mathbf{A}_{:,2} \otimes \mathbf{B}_{2,:} = \begin{bmatrix}
     2 & 0 \\
     4 & 0
     \end{bmatrix}$$
     
2. **Sum the Kronecker Products:**

   $$\mathbf{C} = \begin{bmatrix}
   0 & 1 \\
   0 & 3
   \end{bmatrix}
   +
   \begin{bmatrix}
   2 & 0 \\
   4 & 0
   \end{bmatrix}
   =
   \begin{bmatrix}
   2 & 1 \\
   4 & 3
   \end{bmatrix}$$

----

In the previous block we have discussed the Frobenius norm and its applications. Now came back to the discussions on the Kronecker product. The Kronecker product is particularly useful in scenarios where interactions between different types of data need to be modeled comprehensively. In recommendation systems, it allows us to integrate user preferences with item relationships to improve recommendation accuracy.

In addition to recommendation systems, Kronecker products are used in various fields such as:

-  Signal Processing: For modeling multi-dimensional signals.
- Machine Learning: In building features for complex models.
- Communication Systems: For modeling network interactions.

By understanding the Kronecker product and its applications, we can extend it to solve complex problems and enhance systems across different domains. To understand the practical use of Kronecker product in a Machine Learning scenario let us consider the following problem statement and its solution.

:::{.callout-note}
### Problem statement
In the realm of recommendation systems, predicting user preferences for various product categories based on past interactions is a common challenge. Suppose we have data on user preferences for different products and categories. We can use this data to recommend the best products for each user by employing mathematical tools such as the Kronecker product. The User Preference and Category relationships are given in @tbl-UPM and @tbl-CRM
.


| User/Item  | Electronics | Clothing | Books |
|------------|-------------|----------|-------|
| User 1     | 5           | 3        | 4     |
| User 2     | 2           | 4        | 5     |
| User 3     | 3           | 4        | 4     |

: User Preference {#tbl-UPM}


| Category/Feature | Feature 1 | Feature 2 | Feature 3 |
|------------------|-----------|-----------|-----------|
| Electronics      | 1         | 0         | 0         |
| Clothing         | 0         | 1         | 1         |
| Books            | 0         | 1         | 1         |

: Category Relationships {#tbl-CRM}

 Predict user preferences for different product categories using the Kronecker product matrix.
:::

>**Solution Procedure**

1. *Compute the Kronecker Product:*
   Calculate the Kronecker product of matrices $U$ and $C$ to obtain matrix $K$.

   To model the problem, we use the Kronecker product of the user preference matrix $U$ and the category relationships matrix $C$. This product allows us to predict the user’s rating for each category by combining their preferences with the category features.

  *Formulating Matrices*

   User Preference Matrix (U):
   - Dimension: $3\times 3$ (3 users, 3 items)
   - from the User preference data, we can create the User Preference Matrix as follows:

  $$U = \begin{pmatrix}5 & 3 & 4 \\2 & 4 & 5 \\3 & 4 & 4 \end{pmatrix}$$

   Category Relationships Matrix (C):
   - Dimension: $3 \times 3$ (3 categories)
   - from the Category Relationships data, we can create the Category Relationship Matrix as follows:

  $$C = \begin{pmatrix}1 & 0 & 0 \\ 0 & 1 & 1 \\ 0 & 1 & 1\end{pmatrix}$$

  *Kronecker Product Calculation*

The Kronecker product $K$ of $U$ and $C$ is calculated as follows:

  1. **Matrix Dimensions:**
   - $U$ is $3 \times 3$ (3 users, 3 items).
   - $C$ is $3 \times 3$ (3 categories, 3 features).

  2. **Calculate Kronecker Product:**
   - For each element $u_{ij}$ in $U$, multiply by the entire matrix $C$.

   The Kronecker product $K$ is computed as:

  $$K = U \otimes C$$

   Explicitly, the Kronecker product $K$ is:

  $$K = \begin{pmatrix}5 \cdot C & 3 \cdot C & 4 \cdot C \\ 2 \cdot C & 4 \cdot C & 5 \cdot C \\    3 \cdot C & 4 \cdot C & 4 \cdot C\end{pmatrix}$$

   As an example the blocks in first row are:

  $$5 \cdot C = \begin{pmatrix}
   5 & 0 & 0 \\
   0 & 5 & 5 \\
   0 & 5 & 5
   \end{pmatrix}, \quad
   3 \cdot C = \begin{pmatrix}
   3 & 0 & 0 \\
   0 & 3 & 3 \\
   0 & 3 & 3
   \end{pmatrix}, \quad
   4 \cdot C = \begin{pmatrix}
   4 & 0 & 0 \\
   0 & 4 & 4 \\
   0 & 4 & 4
   \end{pmatrix}$$

   Combining these blocks:

  $$K = \begin{pmatrix}
   5 & 0 & 0 & 3 & 0 & 0 & 4 & 0 & 0\\
   0 & 5 & 5 & 0 & 3 & 3 & 0 & 4 & 4\\
   0 & 5 & 5 & 0 & 3 & 3 & 0 & 4 & 4\\
   2 & 0 & 0 & 4 & 0 & 0 & 5 & 0 & 0\\
   0 & 2 & 2 & 0 & 4 & 4 & 0 & 5 & 5\\
   0 & 2 & 2 & 0 & 4 & 4 & 0 & 5 & 5\\
   3 & 0 & 0 & 4 & 0 & 0 & 4 & 0 & 0\\
   0 & 3 & 3 & 0 & 4 & 4 & 0 & 4 & 4\\
   0 & 3 & 3 & 0 & 4 & 4 & 0 & 4 & 4\end{pmatrix}$$

2. **Interpret the Kronecker Product Matrix:**
   The resulting matrix $K$ represents all possible combinations of user preferences and category features.

3. **Predict Ratings:**
   For each user, use matrix $K$ to predict the rating for each category by summing up the values in the corresponding rows.

4. **Generate Recommendations:**
   Identify the top categories with the highest predicted ratings for each user.

The `python` code to solve this problem computationally is given below.

```{python}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Define the matrices
U = np.array([[5, 3, 4],
              [2, 4, 5],
              [3, 4, 4]])

C = np.array([[1, 0, 0],
              [0, 1, 1],
              [0, 1, 1]])

# Compute the Kronecker product
K = np.kron(U, C)

# Create a DataFrame to visualize the Kronecker product matrix
df_K = pd.DataFrame(K, 
                    columns=['Electronics_F1', 'Electronics_F2', 'Electronics_F3', 
                             'Clothing_F1', 'Clothing_F2', 'Clothing_F3', 
                             'Books_F1', 'Books_F2', 'Books_F3'],
                    index=['User 1 Electronics', 'User 1 Clothing', 'User 1 Books', 
                           'User 2 Electronics', 'User 2 Clothing', 'User 2 Books', 
                           'User 3 Electronics', 'User 3 Clothing', 'User 3 Books'])

# Print the Kronecker product matrix
print("Kronecker Product Matrix (K):\n", df_K)

# Predict ratings and create recommendations
def recommend(user_index, top_n=3):
    """ Recommend top_n categories for a given user based on Kronecker product matrix. """
    user_ratings = K[user_index * len(C):(user_index + 1) * len(C), :]
    predicted_ratings = np.sum(user_ratings, axis=0)
    recommendations = np.argsort(predicted_ratings)[::-1][:top_n]
    return recommendations

# Recommendations for User 1
user_index = 0  # User 1
top_n = 3
recommendations = recommend(user_index, top_n)

print(f"\nTop {top_n} recommendations for User {user_index + 1}:")
for rec in recommendations:
    print(df_K.columns[rec])
```

A simple visualization of this recomendation system is shown in [Fig @fig-reco].

```{python}
#| label: fig-reco
#| fig-cap: "EDA for the Recommendation System"
# Visualization
def plot_recommendations(user_index):
    """ Plot the predicted ratings for each category for a given user. """
    user_ratings = K[user_index * len(C):(user_index + 1) * len(C), :]
    predicted_ratings = np.sum(user_ratings, axis=0)
    categories = df_K.columns
    plt.figure(figsize=(6, 5))
    plt.bar(categories, predicted_ratings)
    plt.xlabel('Categories')
    plt.ylabel('Predicted Ratings')
    plt.title(f'Predicted Ratings for User {user_index + 1}')
    plt.xticks(rotation=45)
    plt.show()

# Plot recommendations for User 1
plot_recommendations(user_index)
```

This micro project illustrate one of the popular use of Kronecker product on ML application.

### Matrix Measures of Practical Importance

Matrix measures, such as rank and determinant, play crucial roles in linear algebra. While both rank and determinant provide valuable insights into the properties of a matrix, they serve different purposes. Understanding their roles and applications is essential for solving complex problems in computer science, engineering, and applied mathematics.

#### Determinant

Determinant of a $2\times 2$ matrix $A=\begin{pmatrix}a&b\\c&d\end{pmatrix}$ is defined as $|A|=ad-bc$. Determinant of higher order square matrices can be found using the Laplace method or Sarrus method.

The determinant of a matrix provides information about the matrix's invertibility and scaling factor for volume transformation. Specifically:

1. *Invertibility:* A matrix is invertible if and only if its determinant is non-zero.

2. *Volume Scaling:* The absolute value of the determinant gives the scaling factor by which the matrix transforms volume.
3. *Parallelism:* If the determinant of a matrix composed of vectors is zero, the vectors are linearly dependent, meaning they are parallel or redundant.
4. *Redundancy:*  A zero determinant indicates that the vectors span a space of lower dimension than the number of vectors, showing redundancy.

:::{.callout-important}
## Least Possible Values of Determinant

1. *Least Positive Determinant:* For a $1\times 1$ matrix, the smallest non-zero determinant is any positive value, typically $\epsilon$, where  $\epsilon$ is a small positive number.
2. Least Non-Zero Determinant: For higher-dimensional matrices, the smallest non-zero determinant is a non-zero value that represents the smallest area or volume spanned by the matrix's rows or columns. For example a $2\times 2$ matrix with determinant $\epsilon$ could be:
$$B=\begin{pmatrix}\epsilon&0\\ 0&\epsilon\end{pmatrix}$$
Here, $\epsilon$ is a small positive number, indicating a very small but *non-zero* area.
:::

Now let's look into the most important matrix measure for advanced application in Linear Algebra.

As we know the matrix is basically a representation tool that make things abstract- remove unnecessary details. Then the matrix itself can be represented in many ways. This is the real story telling with this most promising mathematical structure. Consider a context of collecting feedback about a product in three aspects- cost, quality and practicality. For simplicity in calculation, we consider responses from 3 customers only. The data is shown in @tbl-RT.

| User   | Cost | Quality | Practicality |
|--------|------|---------|--------------|
| User-1 | 1    | 4       | 5            |
| User-2 | 3    | 2       | 5            |
| User-3 | 2    | 1       | 3            |

: User rating of a consumer product {#tbl-RT}

It's perfect and nice looking. But both mathematics and a computer can't handle this table as it is. So we create an abstract representation of this data- the rating matrix. Using the traditional approach, let's represent this rating data as:
$$A=\begin{bmatrix}1&4&5\\3&2&5\\2&1&3\end{bmatrix}$$

Now both the column names and row indices were removed and the data is transformed into the abstract form. This representation has both advantages and disadvantages. Be positive! So we are focused only in the advantages.

Just consider the product. Its sales fully based on its features. So the product sales perspective will be represented in terms of the features- cost, quality and practicality. These features are columns of our rating matrix. Definitly peaple will have different rating for these features. Keeping all these in mind let's introduce the concept of *linear combination*. This leads to a new matrix product as shown below.
\begin{align*}
Ax&=\begin{bmatrix}1&4&5\\3&2&5\\2&1&3\end{bmatrix}x\\
&=\begin{bmatrix}1&4&5\\3&2&5\\2&1&3\end{bmatrix}\cdot\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}\\
&=\begin{bmatrix}1\\3\\2\end{bmatrix}x_1+\begin{bmatrix}1\\3\\2\end{bmatrix}x_1+\begin{bmatrix}4\\2\\1\end{bmatrix}x_2+\begin{bmatrix}5\\5\\3\end{bmatrix}x_3
\end{align*}

As the number of users increases, the product sales perspective become more informative. In short the span of the features define the feature space of the product. In real cases, a manufacture wants to know what are the features really inflence the customers. This new matrix product will help the manufactures to identify that features! 

So we are going to define this new matrix product as the feature space, that will provide more insights to this context as:

$$A=CR$$

Where $C$ is the column space and $R$ is the row reduced Echelon form of $A$. But the product is not the usual scalar projection, Instead the weight of linear combination of elements in the column space.

Let's formally illustrate this in our example. From the first observation itself, it is clear that last column is just the sum of first and second columns (That is in our context the feature 'practicality' is just depends on 'cost' and 'quality'. meaningful?). So only first columns are independent and so spans the column space. 

$$C=\begin{bmatrix}1&4\\3&2\\2&1\end{bmatrix}$$

Now look into the matrix $R$. Applying elementary row tansformations, $A$ will transformed into:

$$R=\begin{bmatrix}1&0&1\\0&1&1\\0&0&0\end{bmatrix}$$

Hence we can form a decomposition for the given rating matrix, $A$ as:
\begin{align*}
A&=CR\\
&=\begin{bmatrix}1&4\\3&2\\2&1\end{bmatrix}\begin{bmatrix}1&0&1\\0&1&1\\\mbox{}&&\end{bmatrix}
\end{align*}


This decomposition says that there are only two independent features (columns) and the third feature (column) is the sum of first two features (columns). 

:::{.callout-important}
#### Interpretation of the $R$ matrix

Each column in the $R$ matrix represents the weights for linear combination of vectors in the column space to get that column in $A$. In this example, third column of $R$ is $\begin{bmatrix}1\\1\end{bmatrix}$. This means that third column of $A$ will be $1\times C_1+1\times C_2$ of the column space, $C$!
:::

This first matrix decompostion donate a new type of matrix product (outer product) and a new measure- the number of independent columns and number of independent rows. This count is called the *rank* of the matrix $A$. In the case of features, if the rank of the column space is less than the number of features then definitly a less number of feature set will perfectly represent the data. This will help us to reduce the dimension of the dataset and there by reducing computational complexities in data analysis and machine Learning jobs.

In the above discussion, we consider only the columns of $A$. Now we will mention the row space. It is the set of all linearly independent rows of $A$. For any matrix $A$, both the row space and column space are of same rank. This correspondance is a helpful result in many practical applications. 

Now we consider a stable equation, $Ax=0$. With the usual notation of dot product, it implies that $x$ is orthogonal to $A$. Set of all those independent vectors which are orthogonal to $A$ constitute a new space of interest. It is called the *null space* of $A$. If $A$ represents a linear transformation, then the null space will be populated by those non-zero vectors which are *nullified* by the transformation $A$. As a summary of this discussion, the row space and null space of a matrix $A$ creates an orthogonal system. Considering the relationship between $A$ and $A^T$, it is clear that row space of $A$ is same as the column space of $A^T$ and vice verse are. So we can restate the orthogonality as: 'the null space of $A$ is orthogonal to the column space of $A^T$' and 'the null space of $A^T$ is orthogonal to the column space of $A$'. Mathematically this property can be represents as follows.

::: {#note-ortho .callout-note}

\begin{align*}
\mathcal{N}(A)&\perp \mathcal{C}(A^T)\\
\mathcal{N}(A^T)&\perp \mathcal{C}(A)
\end{align*}
:::

In the given example, solving $Ax=0$  we get $x=\begin{bmatrix}1&1&-1\end{bmatrix}^T$. 

So the rank of $\mathcal{N}(A)=1$. Already we have rank of $A=2$. This leads to an interesting result:

$$\text{Rank}(A)+\text{Rank}(\mathcal{N}(A))=3$$

This observation can be framed as a theorem.

### Rank Nullity Theorem

The rank-nullity theorem is a fundamental theorem in linear algebra that is important for understanding the connections between mathematical operations in engineering, physics, and computer science. It states that the sum of the rank and nullity of a matrix equals the number of columns in the matrix. The rank is the maximum number of linearly independent columns, and the nullity is the dimension of the nullspace. 

:::{#thm-RNT }

#### Rank Nullitty Theorem

The Rank-Nullity Theorem states that for any $m \times n$ matrix $A$, the following relationship holds:

$$
\text{Rank}(A) + \text{Nullity}(A) = n
$$

where:
- **Rank** of $A$ is the dimension of the column space of $A$, which is also equal to the dimension of the row space of $A$.
- **Nullity** of $A$ is the dimension of the null space of $A$, which is the solution space to the homogeneous system $A \mathbf{x} = \mathbf{0}$.
:::

*Steps to Formulate for Matrix $A$*

1. **Find the Rank of $A$**:
   The rank of a matrix is the maximum number of linearly independent columns (or rows). It can be determined by transforming $A$ into its row echelon form or reduced row echelon form (RREF).

2. **Find the Nullity of $A$**:
   The nullity is the dimension of the solution space of $A \mathbf{x} = \mathbf{0}$. This can be found by solving the homogeneous system and counting the number of free variables.

3. **Apply the Rank-Nullity Theorem**:
   Use the rank-nullity theorem to verify the relationship.

-----

*Example 1:* Calculate the rank and nullity of $A=\begin{bmatrix}
   1 & 4 & 5 \\
   3 & 2 & 5 \\
   2 & 1 & 3
   \end{bmatrix}$ and verify the rank nullity theorem.

1. **Row Echelon Form**:

   Perform Gaussian elimination on $A$:

   $$A = \begin{bmatrix}
   1 & 4 & 5 \\
   3 & 2 & 5 \\
   2 & 1 & 3
   \end{bmatrix}$$

   Perform row operations to get it to row echelon form:

   - Subtract 3 times row 1 from row 2:
     $$\begin{bmatrix}
     1 & 4 & 5 \\
     0 & -10 & -10 \\
     2 & 1 & 3
     \end{bmatrix}$$

   - Subtract 2 times row 1 from row 3:
     $$\begin{bmatrix}
     1 & 4 & 5 \\
     0 & -10 & -10 \\
     0 & -7 & -7
     \end{bmatrix}$$

   - Add $\frac{7}{10}$ times row 2 to row 3:
     $$\begin{bmatrix}
     1 & 4 & 5 \\
     0 & -10 & -10 \\
     0 & 0 & 0
     \end{bmatrix}$$

   The matrix is now in row echelon form.

   **Rank** is the number of non-zero rows, which is 2.

2. **Find the Nullity**:
   The matrix $A$ has 3 columns. The number of free variables in the solution of $A \mathbf{x} = \mathbf{0}$ is $3 - \text{Rank}$. 

   So,
   $$\text{Nullity}(A) = 3 - 2 = 1$$

3. **Apply the Rank-Nullity Theorem**:
   $$\text{Rank}(A) + \text{Nullity}(A) = 2 + 1 = 3$$

   This matches the number of columns of $A$, confirming the theorem.

### Fundamental Subspaces

In section @note-ortho, we have seen that for any matrix $A$, there is two pairs of inter-related orthogonal spaces. This leads to the concept of Fundamental sup spaces. 

Matrices are not just arrays of numbers; they can represent linear transformations too. A linear transformation maps vectors from one vector space to another while preserving vector addition and scalar multiplication. The matrix $A$ can be viewed as a representation of a linear transformation $T$ from $\mathbb{R}^n$ to $\mathbb{R}^m$ where:

$$T(\mathbf{x}) = A \mathbf{x}$$

In this context:

- The column space of $A$ represents the range of $T$, which is the set of all possible outputs.
- The null space of $A$ represents the kernel of $T$, which is the set of vectors that are mapped to the zero vector.

**The Four Fundamental Subspaces**

Understanding the four fundamental subspaces helps in analyzing the properties of a linear transformation. These subspaces are:

:::{#def-FFS}
#### Four Fundamental Subspaces

Let $T:\mathbb{R^n}\longrightarrow \mathbb{R^m}$ be a linear transformation and $A$ represents the matrix of transformation. The four fundamental subspaces are defined as:

1. **Column Space (Range)**: The set of all possible outputs of the transformation. For matrix $A$, this is the span of its columns. It represents the image of $\mathbb{R}^n$ under $T$.

2. **Null Space (Kernel)**: The set of all vectors that are mapped to the zero vector by the transformation. For matrix $A$, this is the solution space of $A \mathbf{x} = \mathbf{0}$.

3. **Row Space**: The span of the rows of $A$. This space is crucial because it helps in understanding the rank of $A$. The dimension of the row space is equal to the rank of $A$, which represents the maximum number of linearly independent rows.

4. **Left Null Space**: The set of all vectors $\mathbf{y}$ such that $A^T \mathbf{y} = \mathbf{0}$. It provides insight into the orthogonal complement of the row space.
:::

```{mermaid}
graph TD
    MatrixA[Matrix A] -->|Contains Columns| ColumnSpace[Column Space]
    MatrixA -->|Contains Rows| RowSpace[Row Space]
    MatrixA -->|Contains Vectors Mapping to Zero| NullSpace[Null Space]
    MatrixA -->|Contains Vectors Orthogonal to Row Space| LeftNullSpace[Left Null Space]
    ColumnSpace -->|Orthogonal Complement| NullSpace
    RowSpace -->|Orthogonal Complement| LeftNullSpace
```
This idea is depicted as a 'Big picture of the four sub spaces of a matrix' in the Strang's text book on Linear algebra for every one [@strang2020linear]. This 'Big Picture' is shown in [Fig- @fig-big-pic].

![The Big Pictue of Fundamental Subspaces](https://i.pinimg.com/originals/fb/c5/f9/fbc5f91d82681dd7341dda6915d11e92.png){#fig-big-pic fig-align="center" width=80% .lightbox}

A video session from Strang's session is here:

{{< video https://youtu.be/rwLOfdfc4dw?si=DsJb8KJTF05hHc76 >}}


#### Practice Problems

**Problem 1:** Express the vector $(1,-2,5)$ as a linear combination of the vectors $(1,1,1)$, $(1,2,3)$ and $(2,-1,1)$.

**Problem 2:** Show that the feature vector $(2,-5,3)$ is not linearly associated with the features $(1,-3,2)$, $(2,-4,-1)$ and $(1,-5,7)$.

**Problem 3:** Show that the feature vectors $(1,1,1)$, $(1,2,3)$ and $(2,-1,1)$ are non-redundant.

**Problem 4:** Prove that the features $(1,-1,1)$, $(0,1,2)$ and $(3,0,-1)$ form basis for the feature space.

**Problem 5:** Check whether the vectors $(1,2,1)$, $(2,1,4)$ and $(4,5,6)$ form a basis for $\mathbb{R}^3$.

**Problem 6:** Find the four fundamental subspaces of the feature space created by $(1,2,1)$, $(2,1,4)$ and $(4,5,6)$.

**Problem 7:** Find the four fundamental subspaces and its dimensions of the matrix $\begin{bmatrix}1&2&4\\2&1&5\\1&4&6\end{bmatrix}$.

**Problem 8:** Express $A=\begin{bmatrix}1&2&-1\\3&1&-1\\2&-1&0\end{bmatrix}$ as the Kronecker product of the column space and the row space in the form $A=C\otimes R$.

**Problem 9:** Find the four fundamental subspaces of $A=\begin{bmatrix} 1&2&0&2&5\\-2&-5&1&-1&-8\\0&-3&3&4&1\\3&6&0&-7&2\end{bmatrix}$.

**Problem 10:** Find the four fundamental subspaces of $A=\begin{bmatrix}-1&2&-1&5&6\\4&-4&-4&-12&-8\\2&0&-6&-2&4\\-3&1&7&-2&12\end{bmatrix}$.

**Problem 11:** Express $A=\begin{bmatrix}2&3&-1&-1\\1&-1&-2&-4\\3&1&3&-2\\6&3&0&-7\end{bmatrix}$ in $A=C\otimes R$, where $C$ is the column space and $R$ is the row space of $A$.

**Problem 12:** Express $A=\begin{bmatrix}0&1&-3&-1\\1&0&1&1\\3&1&0&2\\1&1&-2&0\end{bmatrix}$ in $A=C\otimes R$, where $C$ is the column space and $R$ is the row space of $A$.

**Problem 13:** Show that the feature vectors $(2,3,0)$, $(1,2,0)$ and $(8,13,0)$ are redundant and hence find the relationship between them.

**Problem 14:** Show that the feature vectors $(1,2,1)$, $(4,1,2)$, $(-3,8,1)$ and $(6,5,4)$ are redundant and hence find the relationship between them.

**Problem 15:** Show that the feature vectors $(1,2,-1,0)$, $(1,3,1,2)$, $(4,2,1,0)$ and $(6,1,0,1)$ are redundant and hence find the relationship between them.

:::{.callout-important}
**Three Parts of the *Fundamental theorem***
The fundamental theorem of linear algebra relates all four of the fundamental subspaces in a number of different ways. There are main parts to the theorem:

**Part 1:(Rank nullity theorem)** The column and row spaces of an $m\times n$ matrix $A$ both have dimension $r$, the rank of the matrix. The nullspace has dimension $n−r$, and the left nullspace has dimension $m−r$.

**Part 2:(Orthogonal subspaces)** The nullspace and row space are orthogonal. The left nullspace and the column space are also orthogonal.

**Part 3:(Matrix decomposition)** The final part of the fundamental theorem of linear algebra constructs an orthonormal basis, and demonstrates a singular value decomposition: any matrix $M$ can be written in the form $M=U\Sigma V^T$ , where $U_{m\times m}$ and $V_{n\times n}$ are unitary matrices, $\Sigma_{m\times n}$ matrix with nonnegative values on the diagonal.

This part of the fundamental theorem allows one to immediately find a basis of the subspace in question.
This can be summarized in the following table.

| Subspace               | Subspace of   | Symbol                | Dimension | Basis                                      |
|:-----------------------:|:-------------:|:----------------------:|:----------:|:------------------------------------------:|
| Column space           | $\mathbb{R}^m$ | $\operatorname{im}(A)$ | $r$        | First $r$ columns of $U$                   |
| Nullspace (kernel)     | $\mathbb{R}^n$ | $\ker(A)$             | $n - r$    | Last $n - r$ columns of $V$                |
| Row space              | $\mathbb{R}^n$ | $\operatorname{im}(A^T)$ | $r$        | First $r$ columns of $V$                   |
| Left nullspace (kernel)| $\mathbb{R}^m$ | $\ker(A^T)$           | $m - r$    | Last $m - r$ columns of $U$                |

:::

#### Rank and Solution of System of Linear Equations

In linear algebra, the rank of a matrix is a crucial concept for understanding the structure of a system of linear equations. It provides insight into the solutions of these systems, helping us determine the number of independent equations and the nature of the solution space.

:::{#def-soln}

#### Rank and System Consistency

The rank of a matrix $A$ is defined as the maximum number of linearly independent rows or columns. When solving a system of linear equations represented by $A\mathbf{x} = \mathbf{b}$, where $A$ is an $m \times n$ matrix and $\mathbf{b}$ is a vector, the rank of $A$ plays a crucial role in determining the solution's existence and uniqueness.

**Consistency of the System**

1. **Consistent System:** A system of linear equations is consistent if there exists at least one solution. This occurs if the rank of the coefficient matrix $A$ is equal to the rank of the augmented matrix $[A|\mathbf{b}]$. Mathematically, this can be expressed as:
   $$\text{rank}(A) = \text{rank}([A|\mathbf{b}])$$
   If this condition is met, the system has solutions. The solutions can be:
   - **Unique** if the rank equals the number of variables.
   - **Infinitely many** if the rank is less than the number of variables.

2. **Inconsistent System:** A system is inconsistent if there are no solutions. This occurs when:
   $$\text{rank}(A) \ne \text{rank}([A|\mathbf{b}])$$
   In this case, the equations represent parallel or conflicting constraints that cannot be satisfied simultaneously.
:::