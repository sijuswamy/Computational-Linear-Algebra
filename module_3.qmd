
---
title: "Python Libraries for Computational Linear Algebra"
execute: 
  enabled: true
jupyter: python3
---

In the first two modules, we gained a foundational understanding of `Python` programming and the basics of linear algebra, including fundamental subspaces such as row space, column space, and null space, both theoretically and through Python implementations. These essential concepts provided the groundwork for solving linear algebra problems manually and computationally. Now, as we move into Module 3, the focus shifts toward leveraging advanced `Python` libraries to handle more complex and large-scale computations in linear algebra efficiently.

This module introduces the powerful computational tools available in `Python`, such as `NumPy`, `SymPy`, `SciPy`, and `Matplotlib`. These libraries are designed to enhance the ability to perform both numerical and symbolic operations on matrices, vectors, and systems of equations. With `NumPy`'s high-performance array operations, `SymPy`'s symbolic computation abilities, and `SciPy`'s extensive collection of scientific routines, students will be able to compute solutions for real-world problems with ease. The module also incorporates visualization techniques through `Matplotlib`, allowing students to graphically represent mathematical solutions, interpret data, and communicate their findings effectively. This module empowers students to move beyond manual calculations and explore advanced problem-solving strategies computationally.

## Introduction to NumPy

In this section, we will introduce **NumPy**, the core library for scientific computing in Python. NumPy provides support for arrays, matrices, and a host of mathematical functions to operate on these structures. This is particularly useful for linear algebra computations, making it an essential tool in computational mathematics. The library also serves as the foundation for many other Python libraries like SciPy, Pandas, and Matplotlib.

### Purpose of Using NumPy

The primary purpose of NumPy is to enable efficient numerical computations involving large datasets, vectors, and matrices. With NumPy, one can perform mathematical operations on arrays and matrices in a way that is highly optimized for performance, both in terms of memory and computational efficiency [@harris2020array].

Some key advantages of using NumPy include:

- **Efficient handling of large datasets**: Arrays in NumPy are optimized for performance and consume less memory compared to native Python lists.
- **Matrix operations**: NumPy provides built-in functions for basic matrix operations, allowing one to perform tasks like matrix multiplication, transpose, and inversion easily.
- **Linear algebra**: It includes functions for solving systems of equations, finding eigenvalues and eigenvectors, computing matrix factorizations, and more.

## Basic Operations in NumPy

This section will present several examples of using NumPy array manipulation to access data and subarrays, and to split, reshape, and join the arrays.
While the types of operations shown here may seem a bit dry and pedantic, they comprise the building blocks of many other examples used throughout the book.
Get to know them well!

We'll cover a few categories of basic array manipulations here:

- *Attributes of arrays*: Determining the size, shape, memory consumption, and data types of arrays
- *Indexing of arrays*: Getting and setting the value of individual array elements
- *Slicing of arrays*: Getting and setting smaller subarrays within a larger array
- *Reshaping of arrays*: Changing the shape of a given array
- *Joining and splitting of arrays*: Combining multiple arrays into one, and splitting one array into many

::: {.callout-note}
### Loading `numpy` to a python programme

>Syntax 

```{.python}
import numpy as "name of instance"
```

eg: ``` import numpy as np```

:::

#### Array Creation

At the core of NumPy is the **ndarray** object, which represents arrays and matrices. Here's how to create arrays using NumPy:

```python
import numpy as np

# Creating a 1D array
arr = np.array([1, 2, 3, 4, 5])

# Creating a 2D matrix
matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

print("1D Array: \n", arr)
print("2D Matrix: \n", matrix)
```
### Define different types of `numpy` arrays

As the first step to understand different types of arrays in `NumPy` let us consider the following examples.

#### 1D Array (Vector)
In NumPy, a one-dimensional (1D) array is similar to a list or vector in mathematics. It consists of a single row or column of numbers, making it an ideal structure for storing sequences of values.

```{python}
import numpy as np

# Creating a 1D array
arr = np.array([1, 2, 3, 4])
print(arr)
```

Here, `np.array()` is used to create a 1D array (or vector) containing the values `[1, 2, 3, 4]`. The array represents a single sequence of numbers, and it is the basic structure of `NumPy`. 

:::{.callout-note}
### Use:
 A 1D array can represent many things, such as a vector in linear algebra, a list of numbers, or a single dimension of data in a machine learning model.
:::

#### 2D Array (Matrix)

A two-dimensional (2D) array is equivalent to a matrix in mathematics. It consists of rows and columns and is often used to store tabular data or perform matrix operations.

```{python}
from IPython.display import display, HTML
# Creating a 2D array (Matrix)
matrix = np.array([[1, 2, 3], [4, 5, 6]])
display(matrix)
```

In this example, the 2D array (or matrix) is created using `np.array()` by providing a list of lists, where each list represents a row in the matrix. The result is a matrix with two rows and three columns.

:::{.callout-note}
### Use:
 Matrices are fundamental structures in linear algebra. They can represent anything from transformation matrices in graphics to coefficients in systems of linear equations.
:::

#### Zero Arrays
Zero arrays are used to initialize matrices or arrays with all elements set to zero. This can be useful when creating placeholder arrays where the values will be computed or updated later.

```{python}
# Creating an array of zeros
zero_matrix = np.zeros((3, 3))
print(zero_matrix)
```

The `np.zeros()` function creates an array filled with zeros. In this example, we create a 3x3 matrix with all elements set to zero.

:::{.callout-note}
### Use:
 Zero arrays are commonly used in algorithms that require the allocation of memory for arrays that will be updated later.
:::

#### Identity Matrix
An identity matrix is a square matrix with ones on the diagonal and zeros elsewhere. It plays a crucial role in linear algebra, especially in solving systems of linear equations and matrix factorizations.

```{python}
# Creating an identity matrix
identity_matrix = np.eye(3)
print(identity_matrix)
```


The `np.eye(n)` function creates an identity matrix with the specified size. In this case, we create a 3x3 identity matrix, where all diagonal elements are 1, and off-diagonal elements are 0.

#### Arange Function

The `np.arange()` function is used to create an array with evenly spaced values within a given range. It's similar to Python's built-in ``range() function but returns a NumPy array instead of a list.

```{python}
# Creating an array using arange
arr = np.arange(1, 10, 2)
print(arr)
```

Here, `np.arange(1, 10, 2)` generates an array of numbers starting at 1, ending before 10, with a step size of 2. The result is `[1, 3, 5, 7, 9]`.

:::{.callout-note}
### Use:
 This function is useful when creating arrays for loops, data generation, or defining sequences for analysis.
:::

#### Linspace Function
The `np.linspace()` function generates an array of evenly spaced values between a specified start and end, with the number of intervals defined by the user.

```{python}
# Creating an array using linspace
arr = np.linspace(0, 1, 5)
print(arr)
```

`np.linspace(0, 1, 5)` creates an array with 5 evenly spaced values between 0 and 1, including both endpoints. The result is `[0. , 0.25, 0.5 , 0.75, 1. ]`.
:::{.callout-note}
### Use:
 linspace() is often used when you need a specific number of evenly spaced points within a range, such as for plotting functions or simulating data.
:::

#### Reshaping Arrays

The `reshape()` function changes the shape of an existing array without changing its data. It's useful when you need to convert an array to a different shape for computations or visualizations.

```{python}
# Reshaping an array
arr = np.arange(1, 10)
reshaped_arr = arr.reshape(3, 3)
print(reshaped_arr)
```

In this example, a 1D array with 9 elements is reshaped into a 3x3 matrix using the `reshape()` method. The data remains the same but is now structured in a 2D form.

:::{.callout-note}
### Use:
*Reshaping* is critical in linear algebra and machine learning when working with input data of different dimensions.
:::

#### Random Arrays

NumPy's random module is used to generate arrays with random values. These arrays are useful in simulations, testing algorithms, and initializing variables in machine learning.

```{python}
# Creating a random array
random_arr = np.random.rand(3, 3)
print(random_arr)
```

`np.random.rand(3, 3)` creates a 3x3 matrix with random values between 0 and 1. The `rand()` function generates random floats in the range $[0, 1)$.

:::{.callout-note}
### Use:
 Random arrays are commonly used for initializing weights in machine learning algorithms, simulating stochastic processes, or for testing purposes.
:::

:::{.callout-important}
### Syntax


- **One-Dimensional Array:** `np.array([list of values])`  
- **Two-Dimensional Array:** `np.array([[list of values], [list of values]])`  
- **Zero Array:** `np.zeros(shape)`  
  - `shape` is a tuple representing the dimensions (e.g., `(3, 3)` for a 3x3 matrix).
- **Identity Matrix:** `np.eye(n)`  
  - `n` is the size of the matrix.
- **Arrange Function:** `np.arange(start, stop, step)`  
  - `start` is the starting value, `stop` is the end value (exclusive), and `step` is the increment.
- **Linspace Function:** `np.linspace(start, stop, num)`  
  - `start` and `stop` define the range, and `num` is the number of evenly spaced values.
- **Reshaping Arrays:** `np.reshape(array, new_shape)`  
  - `array` is the existing array, and `new_shape` is the desired shape (e.g., `(3, 4)`).
- **Random Arrays without Using rand:** `np.random.randint(low, high, size)`  
  - `low` and `high` define the range of values, and `size` defines the shape of the array.

:::

### Review Questions

**Q1: What is the purpose of using `np.array()` in NumPy?**  
**Ans:** `np.array()` is used to create arrays in NumPy, which can be 1D, 2D, or multi-dimensional arrays.

**Q2: How do you create a 2D array in NumPy?**  
**Ans:** A 2D array can be created using `np.array([[list of values], [list of values]])`.

**Q3: What is the difference between `np.zeros()` and `np.eye()`?**  
**Ans:** `np.zeros()` creates an array filled with zeros of a specified shape, while `np.eye()` creates an identity matrix of size `n`.

**Q4: What is the syntax to create an evenly spaced array using `np.linspace()`?**  
**Ans:** The syntax is `np.linspace(start, stop, num)`, where `num` specifies the number of evenly spaced points between `start` and `stop`.

**Q5: How can you reshape an array in NumPy?**  
**Ans:** Arrays can be reshaped using `np.reshape(array, new_shape)`, where `new_shape` is the desired shape for the array.

**Q6: How do you create a random integer array in a specific range using NumPy?**  
**Ans:** You can use `np.random.randint(low, high, size)` to generate a random array with integers between `low` and `high`, and `size` defines the shape of the array.

**Q7: What does the function `np.arange(start, stop, step)` do?**  
**Ans:** It generates an array of values from `start` to `stop` (exclusive) with a step size of `step`.

**Q8: What is array broadcasting in NumPy?**  
**Ans:** Array broadcasting allows NumPy to perform element-wise operations on arrays of different shapes by automatically expanding the smaller array to match the shape of the larger array.

**Q9: How do you generate a zero matrix of size 4x4 in NumPy?**  
**Ans:** A zero matrix of size 4x4 can be generated using `np.zeros((4, 4))`.

**Q10: What is the difference between `np.arange()` and `np.linspace()`?**  
**Ans:** `np.arange()` generates values with a specified step size, while `np.linspace()` generates evenly spaced values over a specified range and includes the endpoint.

---

### Tensors in NumPy

A tensor is a generalized concept of matrices and vectors. In mathematical terms, tensors are multi-dimensional arrays, and their dimensionality (or rank) is what differentiates them from simpler structures like scalars (rank 0), vectors (rank 1), and matrices (rank 2). A tensor with three dimensions or more is often referred to as a higher-order tensor.

In practical terms, tensors can be seen as multi-dimensional arrays where each element is addressed by multiple indices. Tensors play a significant role in machine learning and deep learning frameworks, where operations on these multi-dimensional data structures are common.

#### Types of Tensors:

1. *Scalar (0-D Tensor)*: A single number.

Example: 5
Rank: 0
Shape: ()

2. *Vector (1-D Tensor)*: An array of numbers.

Example: [1, 2, 3]
Rank: 1
Shape: (3)

3. *Matrix (2-D Tensor)*: A 2D array (rows and columns).

Example: [[1, 2, 3], [4, 5, 6]]
Rank: 2
Shape: (2, 3)

4. *3-D Tensor*: An array of matrices.

Example: [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]
Rank: 3
Shape: (2, 2, 3)

5. *N-D Tensor*: A tensor with N dimensions, where $N > 3$.

Example: A 4-D tensor could represent data with shape `(n_samples, n_channels, height, width)` in image processing.

#### Creating Tensors Using NumPy

In `NumPy`, tensors are represented as multi-dimensional arrays. You can create tensors in a way similar to how you create arrays, but you extend the dimensions to represent higher-order tensors.

**Creating a 1D Tensor (Vector)**

A 1D tensor is simply a vector. You can create one using `np.array()`:

```{python}
import numpy as np
vector = np.array([1, 2, 3])
print(vector)
```

**Creating a 2D Tensor (Matrix)**

A 2D tensor is a matrix:

```{python}
matrix = np.array([[1, 2, 3], [4, 5, 6]])
print(matrix)
```

**Creating a 3D Tensor**

To create a 3D tensor (a stack of matrices):

```{python}
tensor_3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
print(tensor_3d)
```

**Creating a 4D Tensor**

In applications like deep learning, a 4D tensor is often used to represent a batch of images, where the dimensions could be (batch_size, channels, height, width):

```{python}
tensor_4d = np.random.randint(10, size=(2, 3, 4, 5))  # 2 batches, 3 channels, 4x5 images
print(tensor_4d)
```

:::{.callout-note}
### General Syntax for Creating Tensors Using NumPy
```{.python}
np.array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)
```
- object: An array-like object (nested lists) that you want to convert to a tensor.
- dtype: The desired data type for the tensor elements.
- copy: Whether to copy the data (default True).
- order: Row-major (C) or column-major (F) order.
- ndmin: Specifies the minimum number of dimensions for the tensor.
::::

In the next section we will discuss the various attributes of the `NumPy` array.

#### Attributes of arrays

Each array has attributes ``ndim`` (the number of dimensions), ``shape`` (the size of each dimension), and ``size`` (the total size of the array):

To illustrate this attributes, consider the following arrays:

```{python}
#np.random.seed(0)  # seed for reproducibility

x1 = np.random.randint(10, size=6)  # One-dimensional array
x2 = np.random.randint(10, size=(3, 4))  # Two-dimensional array
x3 = np.random.randint(10, size=(3, 4, 5))  # Three-dimensional array
```

The array attributes of $x_3$ is shown below.

```{python}
print("x3 ndim: ", x3.ndim)
print("x3 shape:", x3.shape)
print("x3 size: ", x3.size)
```

Another useful attribute are the ``dtype`` which return the data type of the array , ``itemsize``, which lists the size (in bytes) of each array element, and ``nbytes``, which lists the total size (in bytes) of the array: 

```{python}
print("dtype:", x3.dtype)
print("itemsize:", x3.itemsize, "bytes")
print("nbytes:", x3.nbytes, "bytes")
```

### Array Indexing: Accessing Single Elements

If you are familiar with Python's standard list indexing, indexing in `NumPy` will feel quite familiar.
In a one-dimensional array, the $i^{th}$ value (counting from zero) can be accessed by specifying the desired index in square brackets, just as with Python lists:

To demonstrate indexing, let us consider the one dimensional array:

```{python}
x1=np.array([8, 5, 4, 7,4,1])
```
The fourth element of `x1` can be accessed as 

```{python}
print(x1[3])
```
Now the second element from the end of the the arrray `x1` can be accessed as:

```{python}
print(x1[-2])
```

#### Acessing elements in multi-dimensional arrays

In a multi-dimensional array, items can be accessed using a comma-separated tuple of indices. An example is shown below.

```{python}
x2=np.array([[3, 3, 9, 2],
       [5, 2, 3, 5],
       [7, 2, 7, 1]])
print(x2)# list the 2-D array
```

Now print the third element in the first row, we will use the following code.

```{python}
x2[0, 2] ## access the element in first row and thrid column
```

```{python}
x2[2, -1] ## access the element in the 3rd row and last column
```

#### Modification of array elements

Values can also be modified using any of the above index notation. An example is shown below.

```{python}
x2[2, -1]=20 ## replace the 3rd row last column element of x2 by 20
print(x2)
```
:::{.callout-note}
### Homogenity of data in `NumPy` arrays

Keep in mind that, unlike Python lists, NumPy arrays have a fixed type. This means, for example, that if you attempt to insert a floating-point value to an integer array, the value will be silently truncated. Don't be caught unaware by this behavior!

:::


#### Array Slicing: Accessing Subarrays

Just as we can use square brackets to access individual array elements, we can also use them to access subarrays with the *slice* notation, marked by the colon (``:``) character.
The NumPy slicing syntax follows that of the standard Python list; to access a slice of an array ``x``, use this:
``` python
x[start:stop:step]
```
If any of these are unspecified, they default to the values ``start=0``, ``stop=``*``size of dimension``*, ``step=1``.

We'll take a look at accessing sub-arrays in one dimension and in multiple dimensions.

**1. One-dimensional subarrays**

```{python}
x = np.arange(0,10)
x
```

```{python}
x[1:6]  # first five elements
```

```{python}
x[5:]  # elements after index 5
```

```{python}
x[4:7]  # middle sub-array
```

```{python}
x[::2]  # every other element with step 2 (alternate elements)
```

**2. Multi-dimensional subarrays (slicing)**

Multi-dimensional slices work in the same way, with multiple slices separated by commas.
For example:

```{python}
# creating a two dimensional array
x2=np.array([[1,2,3],[3,4,5],[5,6,7]])
print(x2)
```

```{python}
# selecting first 3 rows and first two columns from x2
print(x2[:3,:2])
```

```{python}
print(x2[:3:2,:3:2]) # slice alternate elements in first three rows and first three columns
```
:::{.callout-note}
### Accessing array rows and columns

One commonly needed routine is accessing of single rows or columns of an array.
This can be done by combining indexing and slicing, using an empty slice marked by a single colon (``:``)
:::

For example *all the elements* in first column can be accessed as:

```{python}
print(x2[:, 0])  # first column of x2
```

#### Creating copies of arrays

Despite the nice features of array views, it is sometimes useful to instead explicitly copy the data within an array or a subarray. This can be most easily done with the `copy()` method.

This concept can be illustrated through an example. Consider the array `x2` previously defined:

```{python}
print(x2)
```
Now take a copy of a slice of `x2` as follows.

```{python}
# create a copy of subarray and store it with the new name
x2_sub_copy = x2[:2, :2].copy()
print(x2_sub_copy)
```

Now the changes happend in the copy will not affect the orginal array. For example, replace one element in the copy slice and check how it is refelected in both arrays.

```{python}
x2_sub_copy[0, 0] = 42
print(x2_sub_copy)
```

```{python}
print(x2)
```

#### More on reshaping

Another useful type of operation is reshaping of arrays.
The most flexible way of doing this is with the ``reshape`` method. There are various approaches in reshaping of arrays.
For example, if you want to put the numbers 1 through 9 in a $3 \times 3$ grid, you can do the following:

```{python}
np.arange(1, 10)
```

```{python}
grid = np.arange(1, 10).reshape((9, 1))
print(grid)
```

:::{.callout-note}
Note that for this to work, the size of the initial array must match the size of the reshaped array. Where possible, the reshape method will use a no-copy view of the initial array, but with non-contiguous memory buffers this is not always the case.

Another common reshaping pattern is the conversion of a one-dimensional array into a two-dimensional row or column matrix. This can be done with the reshape method, or more easily done by making use of the newaxis keyword within a slice operation:
:::

**More Examples**

```{python}
x = np.array([1, 2, 3])
print(x)
```
Now check the dimension of the array created.

```{python}
x.shape
```

Reshaping the array as a matrix.

```{python}
# row vector via reshape
x1=x.reshape((1, 3))
x1.shape
```
We can achieve the same using the `newaxis` function as shown below.

```{python}
# row vector via newaxis
print(x[np.newaxis, :])
```

Some other similar operations are here.

```{python}
# column vector via reshape
x.reshape((3, 1))
```

```{python}
# column vector via newaxis
x[:, np.newaxis]
```

### Array Concatenation and Splitting

All of the preceding routines worked on single arrays. It's also possible to combine multiple arrays into one, and to conversely split a single array into multiple arrays. We'll take a look at those operations here.

#### Concatenation of arrays

Concatenation, or joining of two arrays in NumPy, is primarily accomplished using the routines ``np.concatenate``, ``np.vstack``, and ``np.hstack``.
``np.concatenate`` takes a tuple or list of arrays as its first argument, as we can see here:

```{python}
x = np.array([1, 2, 3])
y = np.array([3, 2, 1])
np.concatenate([x, y])
```

Another example is shown here:

```{python}
np.concatenate([y, y, y])
```

It can also be used for two-dimensional arrays:

```{python}
grid1 = np.array([[1, 2, 3],
                 [4, 5, 6]])
grid2=np.array([[5,5,5],[7,7,7]])
# concatenate along the first axis
nm=np.concatenate([grid1, grid2],axis=0)
nm.shape
print(nm)
```
Row-wise concatenation is showm below.

```{python}
# concatenate along the second axis (horrizontal) (zero-indexed)
np.concatenate([grid1, grid2], axis=1)
```
For working with arrays of mixed dimensions, it can be clearer to use the `np.vstack` (vertical stack) and `np.hstack` (horizontal stack) functions:


```{python}
x = np.array([1, 2, 3])
grid = np.array([[9, 8, 7],
                 [6, 5, 4]])

# vertically stack the arrays
grid
```

Now the new vector `x` has the same number of columns of `grid`. So we can only vertically stack it `grid`. For this the numpy function `vstack` will be used as follows.

```{python}
grid2=np.vstack([grid,x])
print(grid2)
```
Similarly the horrizontal stacking can be shown as follows.

```{python}
# horizontally stack the arrays
y = np.array([[99],
              [99],[3]])
np.hstack([grid2, y])
```

#### Splitting of arrays

The opposite of concatenation is splitting, which is implemented by the functions ``np.split``, ``np.hsplit``, and ``np.vsplit``.  For each of these, we can pass a list of indices giving the split points:

Let's begin with one dimensional arrays. First we split this array at specified locations and save it into sub arrays.

```{python}
x = [1, 2, 3, 99, 99, 3, 2, 1]
```
Now split the list into two sub lists at index 2

```{python}
x1,x2=np.split(x,[2])
```
Now see the sub-arrays:

```{python}
print("the first array is:", x1)
print("the second array is:", x2)
```

More sub arrays can be created by passing the splitting locations as a list as follows.

```{python}
x1,x2,x3=np.split(x,[2,4])
print(x1,"\n",x2,'\n',x3)
```
:::{.callout-note}
 Notice that $N$ split-points, leads to $N + 1$ subarrays.
 The related functions ``np.hsplit`` and ``np.vsplit`` are similar:
:::

Now use the `vsplit` and `hsplit` functions on multi dimensional arrays.

```{python}
grid = np.arange(16).reshape((4, 4))
grid
```

```{python}
# vsplit
upper, lower = np.vsplit(grid, [2])
print(upper)
print(lower)
```

```{python}
#hsplit
left, right = np.hsplit(grid, [2])
print("Left array:\n",left,"\n Right array:\n",right)
```

### Review Questions

**Short Answer Questions (SAQ)**

**Q1: What is the main purpose of the NumPy library in Python?**  
**Ans:** The main purpose of NumPy is to provide support for large, multi-dimensional arrays and matrices, along with a collection of mathematical functions to perform operations on these arrays efficiently.

**Q2: How can a 1D array be created in NumPy?**  
**Ans:** A 1D array can be created using `np.array()` function, like:  
```python
np.array([1, 2, 3])
```

**Q3: How do you access the shape of a NumPy array?**

**Ans:** You can access the shape of a NumPy array using the .shape attribute.
For example, array.shape gives the dimensions of the array.

**Q4: What does the np.reshape() function do?**

**Ans:** The np.reshape() function reshapes an array to a new shape without changing its data.

**Q5: Explain the difference between vstack() and hstack() in NumPy.**

**Ans:** vstack() vertically stacks arrays (along rows), while hstack() horizontally stacks arrays (along columns).

**Q6: How does NumPy handle array slicing?**

**Ans:** Array slicing in NumPy is done by specifying the start, stop, and step index like array[start:stop:step], which returns a portion of the array.

**Q7: What is the difference between the np.zeros() and np.ones() functions?**

**Ans:** np.zeros() creates an array filled with zeros, while np.ones() creates an array filled with ones.

**Q8: What is array broadcasting in NumPy?**

**Ans:** Broadcasting in NumPy allows arrays of different shapes to be used in arithmetic operations by stretching the smaller array to match the shape of the larger array.

**Q9: How can you stack arrays along a new axis in NumPy?**
**Ans:** You can use np.stack() to join arrays along a new axis.

**Q10: How do you generate a random integer array using NumPy?**

**Ans:** You can generate a random integer array using np.random.randint(low, high, size).

----
**Long Answer Questions (LAQ)**

**Q1: Explain how array slicing works in NumPy.**

**Ans:** Array slicing in NumPy is a method to access or modify a subset of elements from a larger array. The syntax for slicing is array[start:stop:step], where:

start is the index from which slicing begins (inclusive),
stop is the index where slicing ends (exclusive),
step is the interval between indices to include in the slice.
For example, in a 1D array, arr[1:5:2] will return every second element between the indices 1 and 4.

**Q2: Discuss the difference between the .reshape() function and the .ravel() function in NumPy.**

**Ans:** The .reshape() function changes the shape of an array without modifying its data, allowing a multi-dimensional array to be flattened or reshaped into any compatible shape.
On the other hand, .ravel() returns a flattened 1D version of an array, but it tries to avoid copying the data by returning a flattened view where possible. If modifying the flattened array is necessary, ravel() returns a copy instead.

**Q3: Explain how NumPy handles broadcasting during array operations.**

**Ans:** Broadcasting in NumPy is a method to perform element-wise operations on arrays of different shapes. Smaller arrays are "broadcast" across the larger array by repeating their elements to match the shape of the larger array.
For example, when adding a scalar to a 2D array, the scalar is added to each element of the array by broadcasting the scalar to match the array's shape. Similarly, operations between arrays of different shapes follow the broadcasting rules to make them compatible.

**Q4: Describe how you would split an array in NumPy using the np.split() function. Provide an example.**

**Ans:** The np.split() function in NumPy divides an array into multiple sub-arrays based on the indices provided. The syntax is:
np.split(array, indices)
Here, array is the array to be split, and indices is a list of indices where the split will occur.
For example:
```python
arr = np.array([1, 2, 3, 4, 5, 6])  
np.split(arr, [2, 4])  
```
This splits the array at indices 2 and 4, resulting in three sub-arrays: [1, 2], [3, 4], and [5, 6].

**Q5: What are the key differences between np.hsplit() and np.vsplit()? Provide examples.**

**Ans:** np.hsplit() horizontally splits an array along its columns, while np.vsplit() vertically splits an array along its rows.
For example, if we have a 2D array:

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])  
```
np.hsplit(arr, 3) splits the array into three columns, each with two rows: [[1], [4]], [[2], [5]], [[3], [6]].
np.vsplit(arr, 2) splits the array into two sub-arrays along rows: [[1, 2, 3]] and [[4, 5, 6]].

**Q6: How can you create a 2D array with random integers between 1 and 10 using NumPy? Provide an example.**

**Ans:** A 2D array with random integers between 1 and 10 can be created using np.random.randint(low, high, size).
Example:

```python
np.random.randint(1, 10, size=(3, 3))
```
This generates a 3x3 array with random integers between 1 and 9.

**Q7: Describe how you would reshape an array from 1D to 2D in NumPy.**

**Ans:** Reshaping an array from 1D to 2D in NumPy can be done using the .reshape() function.
For example, given a 1D array:

```python
arr = np.array([1, 2, 3, 4, 5, 6])  
```
To reshape it into a 2D array with 2 rows and 3 columns:

```python
arr.reshape(2, 3)
```
This results in `[[1, 2, 3], [4, 5, 6]]`.

**Q8: Explain the concept of stacking arrays in NumPy using np.stack(). Provide an example.**

**Ans:** np.stack() joins arrays along a new axis, unlike hstack() and vstack(), which concatenate along existing axes.
For example:

```python
arr1 = np.array([1, 2, 3])  
arr2 = np.array([4, 5, 6])  
np.stack((arr1, arr2), axis=0)
```
This stacks the arrays along a new axis, resulting in [[1, 2, 3], [4, 5, 6]].

**Q9: How does NumPy’s array_split() differ from split()? Provide an example.**

**Ans:** The array_split() function allows unequal splitting of an array, whereas split() requires the splits to result in equal-sized sub-arrays.
For example:

```python
arr = np.array([1, 2, 3, 4, 5])  
np.array_split(arr, 3)
```

This will split the array into three parts: [1, 2], [3, 4], and [5].

**Q10: How would you flatten a multi-dimensional array into a 1D array in NumPy?**

**Ans:** You can flatten a multi-dimensional array using the .ravel() or .flatten() methods.
Example using ravel():

```python
arr = np.array([[1, 2], [3, 4]])  
arr.ravel()
```
This flattens the array into [1, 2, 3, 4].

**Q11: Discuss the importance of NumPy in scientific computing and how it handles large datasets efficiently.**

**Ans:**
NumPy is crucial in scientific computing because it provides efficient storage and operations for large datasets through its n-dimensional array objects. It uses continuous memory blocks, making array operations faster than traditional Python lists, and supports a variety of mathematical functions and broadcasting, which simplifies computation.

NumPy operates efficiently by:

- Avoiding type checking at each operation due to its homogeneous data type constraint.
- Leveraging vectorization to reduce the need for explicit loops in operations.
- Providing optimized C and Fortran libraries for core computations.

Example of large dataset handling:

```python
large_array = np.random.rand(1000000)
sum_large_array = np.sum(large_array)  # Efficient summation
```
This efficiency makes NumPy a foundation for data-driven scientific applications like machine learning, signal processing, and simulations.

**Q12: What is the difference between a view and a copy in NumPy? Why does this matter in array operations?**

**Ans:**
A view is a reference to the original array, meaning changes in the view will affect the original array. A copy creates a new, independent array.

Example:

```python
arr = np.array([1, 2, 3])
view = arr[:2]  # Creates a view
copy = arr[:2].copy()  # Creates a copy
view[0] = 99  # This will change arr
```
Views are more memory-efficient, but changes to them affect the original data, whereas copies do not.

**Q13: How are higher-dimensional arrays handled in NumPy, and how can they be reshaped and indexed? Provide a practical example.**

**Ans:**
Higher-dimensional arrays (tensors) in NumPy can be created and manipulated like 1D and 2D arrays. You can reshape tensors using reshape() and index them similarly, using one index for each dimension.

```python
tensor = np.arange(24).reshape(2, 3, 4)  # 3D tensor with shape (2, 3, 4)
element = tensor[1, 2, 3]  # Access element at specified indices
```
we can reshape tensors:
```python
reshaped_tensor = tensor.reshape(4, 6)
```

## Some important `NumPy` function for Linear Algrbra

Let’s start with some basic matrix operations. Suppose we have two matrices, A and B, and we want to add them together. In NumPy, we can do this with the simple command, `A+B`. Let's look into the detailed computational steps.

```{python}
# Addition and Subtraction
matrix1 = np.array([[1, 2], [3, 4]])
matrix2 = np.array([[5, 6], [7, 8]])
print(matrix1 + matrix2) # prints [[6, 8], [10, 12]]
```

Similary, matrix difference and other matrix operations can be illustrated as follows.

```{python}
print(matrix1 - matrix2) # prints [[-4, -4], [-4, -4]]
```

```{python}
# Scalar Multiplication
matrix = np.array([[1, 2], [3, 4]])
print(2 * matrix) # prints [[2, 4], [6, 8]]
```

```{python}
# Matrix Multiplication
matrix1 = np.array([[1, 2], [3, 4]])
matrix2 = np.array([[5, 6], [7, 8]])
print(np.dot(matrix1, matrix2)) # prints [[19, 22], [43, 50]]
```

```{python}
# Matrix Hadamards product
matrix1 = np.array([[1, 2], [3, 4]])
matrix2 = np.array([[5, 6], [7, 8]])
print(matrix1*matrix2) 
```

```{python}
# Transpose
matrix = np.array([[1, 2, 3], [4, 5, 6]])
print(np.transpose(matrix)) # prints [[1, 4], [2, 5], [3, 6]]
```

```{python}
# inverse of a matrix
a = np.array([[1, 2], [3, 4]])
a_inv = np.linalg.inv(a)
```

Next, let’s talk about vectors. A vector is simply a matrix with one column. They’re often used to represent things like forces or velocities in physics. In NumPy, we can represent vectors as arrays with one dimension.

```{python}
vector = np.array([1, 2, 3])
print(vector) # prints [1, 2, 3]
```

Let’s say we have two vectors, $\vec{u}$ and $\vec{v}$, and we want to compute their dot product (i.e., the sum of the products of their corresponding entries). We can do this with the command:

```{python}
vector1 = np.array([1, 2, 3])
vector2 = np.array([4, 5, 6])
print(np.dot(vector1, vector2)) # prints 32
```

Like that there are some other operations too.

```{python}
# Cross Product
vector1 = np.array([1, 2, 3])
vector2 = np.array([4, 5, 6])
print(np.cross(vector1, vector2)) # prints [-3, 6, -3]
```

:::{.callout-note}
 *Norm:* The norm of a vector is a scalar that represents the "length" of the vector. In NumPy, we can compute the norm using the `numpy.linalg.norm` function.
 The inner product of two vectors is a matrix that is computed by multiplying the first vector by the transpose of the second vector. In NumPy, we can 
compute the inner product using the numpy.inner function.
:::

```{python}
# finding norm
vector = np.array([1, 2, 3])
print(np.linalg.norm(vector)) # prints 3.74165738677
```

```{python}
#finding inner product
vector1 = np.array([1, 2, 3])
vector2 = np.array([4, 5, 6])
print(np.inner(vector1, vector2)) # prints 32
```

To handle higher dimensional mutrix multiplication, one can use `matmul()` function. The `np.matmul()` function is another way to perform matrix multiplication. Unlike `np.dot()`, it handles higher-dimensional arrays correctly by broadcasting. The syntax for this operation is `np.matmul(a, b)`.

```{python}
A = np.array([[1, 0], [0, 1]])
B = np.array([[4, 1], [2, 2]])

# Matrix multiplication using matmul
result = np.matmul(A, B)
print(result)
```

The function `np.linalg.inv()`  computes the inverse of a square matrix. Syntax for this function is `np.linalg.inv(a)`. An example is shown below.

```{python}
A = np.array([[1, 2], [3, 4]])

# Compute inverse
inv_A = np.linalg.inv(A)
print(inv_A)
```

The `np.linalg.det()` function computes the determinant of a square matrix. The determinant is useful for solving linear systems and understanding matrix properties. The syntax is `np.linalg.det(a)`.

```{python}
A = np.array([[1, 2], [3, 4]])

# Compute determinant
det_A = np.linalg.det(A)
print(det_A)
```

The `np.linalg.solve()` function solves a linear matrix equation or system of linear scalar equations. It finds the vector x that satisfies $Ax = b$. Syntax for this function is `np.linalg.solve(A, b)`.


```{python}
A = np.array([[3, 1], [1, 2]])
b = np.array([9, 8])

# Solve system of equations
x = np.linalg.solve(A, b)
print(x)
```

This function computes the QR decomposition of a matrix. QR decomposition is used to solve linear systems, least squares problems, and compute eigenvalues. Syntax for this function is `np.linalg.qr()`.

```{python}
A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# QR decomposition
Q, R = np.linalg.qr(A)
print("Q:", Q)
print("R:", R)
```

The `np.linalg.lstsq()` function solves a linear least-squares problem, which is useful in regression tasks. The syntax for the function is `np.linalg.lstsq(a, b, rcond=None)`.

```{python}
A = np.array([[1, 1], [1, 2], [2, 2], [2, 3]])
b = np.array([6, 8, 9, 11])

# Least-squares solution
x, residuals, rank, s = np.linalg.lstsq(A, b, rcond=None)
print("Solution:", x)
```


The Kronecker product is a matrix operation used in various applications like tensor products and matrix calculus. Syntax for this function is `np.kron(a, b)`.

```{python}
A = np.array([[1, 2], [3, 4]])
B = np.array([[0, 5], [6, 7]])

kronecker = np.kron(A, B)
print(kronecker)
```

Cosine similarity is used to find the cosine of the angle between two vectors. The mathematical formula for this operation is $\cos \theta=\frac{\vec{a}\cdot \vec{b}}{|\vec{a}\cdot\vec{b}|}$. The python function to calculate the cosine similarity is shown below.

```{python}
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

cosine_sim = np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))
print(cosine_sim)
```

### Linear Regression using `NumPy`

The `np.polyfit()` function fits a polynomial of a specified degree to the data, making it useful for regression. Syntax for this function is `np.polyfit(x, y, deg)`. Where $x$ Independent variable (input), $y$ is the dependent variable (output) and `deg` degree of the fitting polynomial. A simple example is given below.

```{python}
x = np.array([0, 1, 2, 3, 4])
y = np.array([1, 3, 5, 7, 9])

# Linear fit (degree 1)
coefficients = np.polyfit(x, y, 1)
print("Coefficients:", coefficients)
```

### Some interesting handy matrix operations using numpy arrays

In matrix decomposition, we need the matrix representation, $A-\lambda I$. For any matrix, we can do this by just `A-lambda np.eye(3)`. This can be deomonstarted here.

```{python}
A=np.array([[1,2,3],[3,4,5],[7,6,7]])
lamda=3
A-lamda*np.eye(3)
```

>**Task:** Create a matrix, $A$ using `numpy`  and find the covariance , $cov(A)$ using matrix operation.

```{python}
# creating a random matrix
import numpy as np
A=np.arange(16).reshape(4,4)
A
```

Now find $A-\bar{A}$.

```{python}
A_bar=np.mean(A,axis=0) # calculating column-wise sum
A_bar
```
```{python}
# calculating A-A bar with outer product opertation
print(A-np.outer(A_bar,np.ones(4)).T)
```
:::{.callout-note}
The same can be done using reshaping method
```{python}
#calculating A-A_bar using broadcasting
X=A-np.mean(A,axis=0).reshape(1,4)
print(X)
```
:::

Calculating the covariance.

```{python}
#mannualy calculating covariance
CoV=(1/3)*np.dot(X.T,X)
CoV
```

We can verify the same using default function as follows.

```{python}
#calculating covariance using numpy function
np.cov(A, rowvar=False)
```
:::{.callout-note}
It is interesting to compare the two ways of flattening an array using `reshape()`.

```{python}
#comparing two ways of flattening a matrix using numpy
A.reshape(-1)==A.reshape(16,)
```
:::


## Basics of `SciPy` Library for Computational Linear Algebra

Following the comprehensive exploration of the NumPy library, which forms the foundation of array operations and basic linear algebra computations, it is essential to expand into more advanced tools for scientific computing. The **SciPy** library builds upon NumPy, offering a vast collection of functions and utilities specifically designed for higher-level operations in scientific and technical computing. While NumPy provides efficient array handling and basic matrix operations, SciPy extends these capabilities by incorporating advanced functions for optimization, integration, interpolation, and linear algebra, among other tasks [@2020SciPy-NMeth]. 

For computational linear algebra, SciPy provides specialized modules like `scipy.linalg`, which can handle everything from solving linear systems to eigenvalue decompositions and matrix factorizations. This transition from NumPy to SciPy enables the handling of more complex problems efficiently and allows users to leverage optimized algorithms for large-scale numerical computations. By integrating SciPy into the workflow, computations can be carried out more robustly, expanding on the basic linear algebra concepts introduced through NumPy with advanced techniques necessary for practical applications.

### Basic Matrix operations

`SciPy` builds on the functionality of NumPy, offering more sophisticated and optimized algorithms, particularly suited for numerical computing tasks. While `NumPy` provides essential operations for linear algebra, `SciPy`'s `scipy.linalg` module extends these capabilities with more advanced functions. `SciPy` functions are often better optimized for large-scale systems, making them highly efficient for computational linear algebra applications.

As the first step to use `SciPy`, we need to import the (only) necessary submodules for our specific tasks. In our discussion, we consider only linear algebra. So we import the `linalg` submodule as follows

```{python}
#import scipy
import numpy as np # for matrix definition
from scipy import linalg
#print(scipy.__version__) # check version
```

Now let's discuss various `SciPy` functions for linear algebra with examples.

#### Computing the Determinant

The determinant is a scalar value that can be computed from the elements of a square matrix and is often used to determine whether a system of linear equations has a unique solution.

>*Syntax:* `scipy.linalg.det(A)`

```{python}
# example
A = np.array([[1, 2], [3, 4]])
det_A = linalg.det(A)
print(det_A)
```

:::{.callout-note}
Similar functionality is provided by `np.linalg.det()`. However, `scipy.linalg.det()` is often preferred when working with very large matrices due to the efficiency of SciPy's backend implementations.
:::

#### Solving Linear Systems of Equations

One of the fundamental tasks in linear algebra is solving a system of linear equations of the form $AX = b$, where $A$ is a matrix and $b$ is a vector or matrix of known values.
>*Syntax:* `scipy.linalg.solve(A, b)`

```{python}
#example
A = np.array([[3, 1], [1, 2]])
b = np.array([9, 8])
x = linalg.solve(A, b)
print(x)
```

:::{.callout-note}
NumPy's `np.linalg.solve()` also provides this functionality, but SciPy's version is better suited for larger and more complex matrices because it uses more efficient algorithms for decomposing the matrix.
:::

#### Matrix Inversion
Matrix inversion is a critical operation in many linear algebra problems, particularly in solving systems of linear equations.
>*Syntax:* `scipy.linalg.inv(A)`

```{python}
A = np.array([[1, 2], [3, 4]])
inv_A = linalg.inv(A)
print(inv_A)
```

#### Kronecker Product

The Kronecker product is used in various applications, including constructing block matrices and expanding the dimensionality of matrices.

>*Syntax:* `scipy.linalg.kron(A, B)`

```{python}
A = np.array([[1, 2], [3, 4]])
B = np.array([[0, 5], [6, 7]])
kron_product = linalg.kron(A, B)
print(kron_product)
```

#### Eigenvalues and Eigenvectors

Eigenvalues and eigenvectors are fundamental in many areas of linear algebra, including solving systems of differential equations and performing dimensionality reduction in machine learning.

>*Syntax:* `scipy.linalg.eig(A)`

```{python}
A = np.array([[3, 2], [4, 1]])
eigenvalues, eigenvectors = linalg.eig(A)
print("Eigenvalues:", eigenvalues)
print("Eigenvectors:", eigenvectors)
```

## Sparse Matrices

Sparse matrices are often useful in numerical simulations dealing with large systems, if the problem can be described in matrix form where the matrices or vectors mostly contains zeros. Scipy has a good support for sparse matrices, with basic linear algebra operations (such as equation solving, eigenvalue calculations, etc.).

There are many possible strategies for storing sparse matrices in an efficient way. Some of the most common are the so-called coordinate form (COO), list of list (LIL) form,  and compressed-sparse column CSC (and row, CSR). Each format has some advantages and disadvantages. Most computational algorithms (equation solving, matrix-matrix multiplication, etc.) can be efficiently implemented using CSR or CSC formats, but they are not so intuitive and not so easy to initialize. So often a sparse matrix is initially created in COO or LIL format (where we can efficiently add elements to the sparse matrix data), and then converted to CSC or CSR before used in real calculations.

For more information about these sparse formats, see e.g. <http://en.wikipedia.org/wiki/Sparse_matrix>


### Sparse Matrix operations in `SciPy`

**Sparse matrices** are a key feature of `SciPy`, providing an efficient way to store and manipulate large matrices with a significant number of zero elements. `SciPy` offers a variety of sparse matrix formats and supports operations like matrix multiplication, addition, transposition, and solving systems of equations.

Here is a guide to working with sparse matrices in `SciPy`.

**Types of Sparse Matrices in SciPy**

`SciPy` provides different types of sparse matrices depending on the use case:

1. **CSR (Compressed Sparse Row) Matrix**: Efficient for row slicing and matrix-vector products.
2. **CSC (Compressed Sparse Column) Matrix**: Efficient for column slicing and fast arithmetic operations.
3. **COO (Coordinate) Matrix**: Suitable for constructing sparse matrices by specifying individual entries.
4. **DIA (Diagonal) Matrix**: For matrices where non-zero elements are primarily on the diagonals.
5. **LIL (List of Lists) Matrix**: Good for constructing matrices incrementally.

#### Importing Sparse Matrices

```{python}
from scipy.sparse import csr_matrix, csc_matrix, coo_matrix
import numpy as np
```

**Creating Sparse Matrices**

```{python}
# Create a dense matrix
dense_matrix = np.array([[0, 0, 3], [4, 0, 0], [0, 5, 6]])

# Convert dense matrix to CSR format
csr = csr_matrix(dense_matrix)

# Display CSR matrix
print(csr)
```

```{python}
# creating sparse matrix in COO format
# Define row indices, column indices, and values
row = np.array([0, 1, 2, 2])
col = np.array([2, 0, 1, 2])
data = np.array([3, 4, 5, 6])

# Create COO sparse matrix
coo = coo_matrix((data, (row, col)), shape=(3, 3))

print(coo)
```

**Basic Operations with Sparse Matrices**

The basic matrix operations can be performed on the sparse matrix too. The difference is that in the case of sparse matices, the respective operations will be done only on non-zero enties. Now look into the basic matrix operations thorugh following examples.

*Matrix Multiplication:*

```{python}
A = csr_matrix([[1, 0, 0], [0, 0, 1], [0, 2, 0]])
B = csr_matrix([[4, 5], [0, 0], [7, 8]])

# Matrix multiplication (dot product)
result = A.dot(B)
print(result.toarray())  # Convert to dense array for display
```

*Transposition:*

```{python}
# Transpose the matrix
transposed = A.transpose()

print(transposed.toarray())
```

*Addition:*

```{python}
# Adding two sparse matrices
C = csr_matrix([[0, 1, 2], [3, 0, 0], [0, 0, 5]])
D = csr_matrix([[0, 1, 0], [0, 0, 0], [2, 0, 5]])

sum_matrix = C + D

print(sum_matrix.toarray())
```

*Solving Sparse Linear Systems*

We can solve systems of linear equations using sparse matrices with the `spsolve()` function:

```{python}
from scipy.sparse.linalg import spsolve

# Create a sparse matrix (A) and a dense vector (b)
A = csr_matrix([[3, 1, 0], [1, 2, 0], [0, 0, 1]])
b = np.array([5, 5, 1])

# Solve the system Ax = b
x = spsolve(A, b)

print("Solution x:", x)
```
#### Conversion from one sparse matrix system to another

We can convert between different sparse matrix formats using the `.tocsc()`,` .tocoo()`, `.todia()`, and similar methods:

```{python}
# Convert CSR to COO format
coo = A.tocoo()
print(coo)
print("The matrix is :\n",coo.toarray())
```

:::{.callout-note}
### Summary of sparse matrix operations

| Function      | Description                                   |
|---------------|-----------------------------------------------|
| `csr_matrix()` | Compressed Sparse Row matrix.                |
| `csc_matrix()` | Compressed Sparse Column matrix.             |
| `coo_matrix()` | Coordinate format matrix.                    |
| `spsolve()`   | Solves sparse linear systems.                 |
| `spdiags()`   | Extracts or constructs diagonal sparse matrices. |
| `lil_matrix()` | List of lists sparse matrix.                 |


:::


## Visualization Libraries

