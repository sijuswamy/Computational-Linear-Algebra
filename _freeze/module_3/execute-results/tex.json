{
  "hash": "7eb871630f074e95d62ae55e43577200",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Python Libraries for Computational Linear Algebra\"\nexecute: \n  enabled: true\njupyter: python3\n---\n\n\n\n\n\n\n\n\nIn the first two modules, we gained a foundational understanding of `Python` programming and the basics of linear algebra, including fundamental subspaces such as row space, column space, and null space, both theoretically and through Python implementations. These essential concepts provided the groundwork for solving linear algebra problems manually and computationally. Now, as we move into Module 3, the focus shifts toward leveraging advanced `Python` libraries to handle more complex and large-scale computations in linear algebra efficiently.\n\nThis module introduces the powerful computational tools available in `Python`, such as `NumPy`, `SymPy`, `SciPy`, and `Matplotlib`. These libraries are designed to enhance the ability to perform both numerical and symbolic operations on matrices, vectors, and systems of equations. With `NumPy`'s high-performance array operations, `SymPy`'s symbolic computation abilities, and `SciPy`'s extensive collection of scientific routines, students will be able to compute solutions for real-world problems with ease. The module also incorporates visualization techniques through `Matplotlib`, allowing students to graphically represent mathematical solutions, interpret data, and communicate their findings effectively. This module empowers students to move beyond manual calculations and explore advanced problem-solving strategies computationally.\n\n## Introduction to NumPy\n\nIn this section, we will introduce **NumPy**, the core library for scientific computing in Python. NumPy provides support for arrays, matrices, and a host of mathematical functions to operate on these structures. This is particularly useful for linear algebra computations, making it an essential tool in computational mathematics. The library also serves as the foundation for many other Python libraries like SciPy, Pandas, and Matplotlib.\n\n### Purpose of Using NumPy\n\nThe primary purpose of NumPy is to enable efficient numerical computations involving large datasets, vectors, and matrices. With NumPy, one can perform mathematical operations on arrays and matrices in a way that is highly optimized for performance, both in terms of memory and computational efficiency [@harris2020array].\n\nSome key advantages of using NumPy include:\n\n- **Efficient handling of large datasets**: Arrays in NumPy are optimized for performance and consume less memory compared to native Python lists.\n- **Matrix operations**: NumPy provides built-in functions for basic matrix operations, allowing one to perform tasks like matrix multiplication, transpose, and inversion easily.\n- **Linear algebra**: It includes functions for solving systems of equations, finding eigenvalues and eigenvectors, computing matrix factorizations, and more.\n\n## Basic Operations in NumPy\n\nThis section will present several examples of using NumPy array manipulation to access data and subarrays, and to split, reshape, and join the arrays.\nWhile the types of operations shown here may seem a bit dry and pedantic, they comprise the building blocks of many other examples used throughout the book.\nGet to know them well!\n\nWe'll cover a few categories of basic array manipulations here:\n\n- *Attributes of arrays*: Determining the size, shape, memory consumption, and data types of arrays\n- *Indexing of arrays*: Getting and setting the value of individual array elements\n- *Slicing of arrays*: Getting and setting smaller subarrays within a larger array\n- *Reshaping of arrays*: Changing the shape of a given array\n- *Joining and splitting of arrays*: Combining multiple arrays into one, and splitting one array into many\n\n::: {.callout-note}\n### Loading `numpy` to a python programme\n\n>Syntax \n\n```{.python}\nimport numpy as \"name of instance\"\n```\n\neg: ``` import numpy as np```\n\n:::\n\n#### Array Creation\n\nAt the core of NumPy is the **ndarray** object, which represents arrays and matrices. Here's how to create arrays using NumPy:\n\n```python\nimport numpy as np\n\n# Creating a 1D array\narr = np.array([1, 2, 3, 4, 5])\n\n# Creating a 2D matrix\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\nprint(\"1D Array: \\n\", arr)\nprint(\"2D Matrix: \\n\", matrix)\n```\n### Define different types of `numpy` arrays\n\nAs the first step to understand different types of arrays in `NumPy` let us consider the following examples.\n\n#### 1D Array (Vector)\nIn NumPy, a one-dimensional (1D) array is similar to a list or vector in mathematics. It consists of a single row or column of numbers, making it an ideal structure for storing sequences of values.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\n# Creating a 1D array\narr = np.array([1, 2, 3, 4])\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4]\n```\n:::\n:::\n\n\nHere, `np.array()` is used to create a 1D array (or vector) containing the values `[1, 2, 3, 4]`. The array represents a single sequence of numbers, and it is the basic structure of `NumPy`. \n\n:::{.callout-note}\n### Use:\n A 1D array can represent many things, such as a vector in linear algebra, a list of numbers, or a single dimension of data in a machine learning model.\n:::\n\n#### 2D Array (Matrix)\n\nA two-dimensional (2D) array is equivalent to a matrix in mathematics. It consists of rows and columns and is often used to store tabular data or perform matrix operations.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfrom IPython.display import display, HTML\n# Creating a 2D array (Matrix)\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\ndisplay(matrix)\n```\n\n::: {.cell-output .cell-output-display}\n```\narray([[1, 2, 3],\n       [4, 5, 6]])\n```\n:::\n:::\n\n\nIn this example, the 2D array (or matrix) is created using `np.array()` by providing a list of lists, where each list represents a row in the matrix. The result is a matrix with two rows and three columns.\n\n:::{.callout-note}\n### Use:\n Matrices are fundamental structures in linear algebra. They can represent anything from transformation matrices in graphics to coefficients in systems of linear equations.\n:::\n\n#### Zero Arrays\nZero arrays are used to initialize matrices or arrays with all elements set to zero. This can be useful when creating placeholder arrays where the values will be computed or updated later.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# Creating an array of zeros\nzero_matrix = np.zeros((3, 3))\nprint(zero_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n```\n:::\n:::\n\n\nThe `np.zeros()` function creates an array filled with zeros. In this example, we create a 3x3 matrix with all elements set to zero.\n\n:::{.callout-note}\n### Use:\n Zero arrays are commonly used in algorithms that require the allocation of memory for arrays that will be updated later.\n:::\n\n#### Identity Matrix\nAn identity matrix is a square matrix with ones on the diagonal and zeros elsewhere. It plays a crucial role in linear algebra, especially in solving systems of linear equations and matrix factorizations.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Creating an identity matrix\nidentity_matrix = np.eye(3)\nprint(identity_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n```\n:::\n:::\n\n\nThe `np.eye(n)` function creates an identity matrix with the specified size. In this case, we create a 3x3 identity matrix, where all diagonal elements are 1, and off-diagonal elements are 0.\n\n#### Arange Function\n\nThe `np.arange()` function is used to create an array with evenly spaced values within a given range. It's similar to Python's built-in ``range() function but returns a NumPy array instead of a list.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Creating an array using arange\narr = np.arange(1, 10, 2)\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 3 5 7 9]\n```\n:::\n:::\n\n\nHere, `np.arange(1, 10, 2)` generates an array of numbers starting at 1, ending before 10, with a step size of 2. The result is `[1, 3, 5, 7, 9]`.\n\n:::{.callout-note}\n### Use:\n This function is useful when creating arrays for loops, data generation, or defining sequences for analysis.\n:::\n\n#### Linspace Function\nThe `np.linspace()` function generates an array of evenly spaced values between a specified start and end, with the number of intervals defined by the user.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Creating an array using linspace\narr = np.linspace(0, 1, 5)\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.   0.25 0.5  0.75 1.  ]\n```\n:::\n:::\n\n\n`np.linspace(0, 1, 5)` creates an array with 5 evenly spaced values between 0 and 1, including both endpoints. The result is `[0. , 0.25, 0.5 , 0.75, 1. ]`.\n:::{.callout-note}\n### Use:\n linspace() is often used when you need a specific number of evenly spaced points within a range, such as for plotting functions or simulating data.\n:::\n\n#### Reshaping Arrays\n\nThe `reshape()` function changes the shape of an existing array without changing its data. It's useful when you need to convert an array to a different shape for computations or visualizations.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Reshaping an array\narr = np.arange(1, 10)\nreshaped_arr = arr.reshape(3, 3)\nprint(reshaped_arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\n```\n:::\n:::\n\n\nIn this example, a 1D array with 9 elements is reshaped into a 3x3 matrix using the `reshape()` method. The data remains the same but is now structured in a 2D form.\n\n:::{.callout-note}\n### Use:\n*Reshaping* is critical in linear algebra and machine learning when working with input data of different dimensions.\n:::\n\n#### Random Arrays\n\nNumPy's random module is used to generate arrays with random values. These arrays are useful in simulations, testing algorithms, and initializing variables in machine learning.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# Creating a random array\nrandom_arr = np.random.rand(3, 3)\nprint(random_arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0.25019618 0.76640927 0.18857974]\n [0.882273   0.6029882  0.87501664]\n [0.8175219  0.52463501 0.40024259]]\n```\n:::\n:::\n\n\n`np.random.rand(3, 3)` creates a 3x3 matrix with random values between 0 and 1. The `rand()` function generates random floats in the range $[0, 1)$.\n\n:::{.callout-note}\n### Use:\n Random arrays are commonly used for initializing weights in machine learning algorithms, simulating stochastic processes, or for testing purposes.\n:::\n\n:::{.callout-important}\n### Syntax\n\n\n- **One-Dimensional Array:** `np.array([list of values])`  \n- **Two-Dimensional Array:** `np.array([[list of values], [list of values]])`  \n- **Zero Array:** `np.zeros(shape)`  \n  - `shape` is a tuple representing the dimensions (e.g., `(3, 3)` for a 3x3 matrix).\n- **Identity Matrix:** `np.eye(n)`  \n  - `n` is the size of the matrix.\n- **Arrange Function:** `np.arange(start, stop, step)`  \n  - `start` is the starting value, `stop` is the end value (exclusive), and `step` is the increment.\n- **Linspace Function:** `np.linspace(start, stop, num)`  \n  - `start` and `stop` define the range, and `num` is the number of evenly spaced values.\n- **Reshaping Arrays:** `np.reshape(array, new_shape)`  \n  - `array` is the existing array, and `new_shape` is the desired shape (e.g., `(3, 4)`).\n- **Random Arrays without Using rand:** `np.random.randint(low, high, size)`  \n  - `low` and `high` define the range of values, and `size` defines the shape of the array.\n\n:::\n\n### Review Questions\n\n**Q1: What is the purpose of using `np.array()` in NumPy?**  \n**Ans:** `np.array()` is used to create arrays in NumPy, which can be 1D, 2D, or multi-dimensional arrays.\n\n**Q2: How do you create a 2D array in NumPy?**  \n**Ans:** A 2D array can be created using `np.array([[list of values], [list of values]])`.\n\n**Q3: What is the difference between `np.zeros()` and `np.eye()`?**  \n**Ans:** `np.zeros()` creates an array filled with zeros of a specified shape, while `np.eye()` creates an identity matrix of size `n`.\n\n**Q4: What is the syntax to create an evenly spaced array using `np.linspace()`?**  \n**Ans:** The syntax is `np.linspace(start, stop, num)`, where `num` specifies the number of evenly spaced points between `start` and `stop`.\n\n**Q5: How can you reshape an array in NumPy?**  \n**Ans:** Arrays can be reshaped using `np.reshape(array, new_shape)`, where `new_shape` is the desired shape for the array.\n\n**Q6: How do you create a random integer array in a specific range using NumPy?**  \n**Ans:** You can use `np.random.randint(low, high, size)` to generate a random array with integers between `low` and `high`, and `size` defines the shape of the array.\n\n**Q7: What does the function `np.arange(start, stop, step)` do?**  \n**Ans:** It generates an array of values from `start` to `stop` (exclusive) with a step size of `step`.\n\n**Q8: What is array broadcasting in NumPy?**  \n**Ans:** Array broadcasting allows NumPy to perform element-wise operations on arrays of different shapes by automatically expanding the smaller array to match the shape of the larger array.\n\n**Q9: How do you generate a zero matrix of size 4x4 in NumPy?**  \n**Ans:** A zero matrix of size 4x4 can be generated using `np.zeros((4, 4))`.\n\n**Q10: What is the difference between `np.arange()` and `np.linspace()`?**  \n**Ans:** `np.arange()` generates values with a specified step size, while `np.linspace()` generates evenly spaced values over a specified range and includes the endpoint.\n\n---\n\n### Tensors in NumPy\n\nA tensor is a generalized concept of matrices and vectors. In mathematical terms, tensors are multi-dimensional arrays, and their dimensionality (or rank) is what differentiates them from simpler structures like scalars (rank 0), vectors (rank 1), and matrices (rank 2). A tensor with three dimensions or more is often referred to as a higher-order tensor.\n\nIn practical terms, tensors can be seen as multi-dimensional arrays where each element is addressed by multiple indices. Tensors play a significant role in machine learning and deep learning frameworks, where operations on these multi-dimensional data structures are common.\n\n#### Types of Tensors:\n\n1. *Scalar (0-D Tensor)*: A single number.\n\nExample: 5\nRank: 0\nShape: ()\n\n2. *Vector (1-D Tensor)*: An array of numbers.\n\nExample: [1, 2, 3]\nRank: 1\nShape: (3)\n\n3. *Matrix (2-D Tensor)*: A 2D array (rows and columns).\n\nExample: [[1, 2, 3], [4, 5, 6]]\nRank: 2\nShape: (2, 3)\n\n4. *3-D Tensor*: An array of matrices.\n\nExample: [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]\nRank: 3\nShape: (2, 2, 3)\n\n5. *N-D Tensor*: A tensor with N dimensions, where $N > 3$.\n\nExample: A 4-D tensor could represent data with shape `(n_samples, n_channels, height, width)` in image processing.\n\n#### Creating Tensors Using NumPy\n\nIn `NumPy`, tensors are represented as multi-dimensional arrays. You can create tensors in a way similar to how you create arrays, but you extend the dimensions to represent higher-order tensors.\n\n**Creating a 1D Tensor (Vector)**\n\nA 1D tensor is simply a vector. You can create one using `np.array()`:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nimport numpy as np\nvector = np.array([1, 2, 3])\nprint(vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3]\n```\n:::\n:::\n\n\n**Creating a 2D Tensor (Matrix)**\n\nA 2D tensor is a matrix:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\nprint(matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3]\n [4 5 6]]\n```\n:::\n:::\n\n\n**Creating a 3D Tensor**\n\nTo create a 3D tensor (a stack of matrices):\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ntensor_3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\nprint(tensor_3d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[[ 1  2  3]\n  [ 4  5  6]]\n\n [[ 7  8  9]\n  [10 11 12]]]\n```\n:::\n:::\n\n\n**Creating a 4D Tensor**\n\nIn applications like deep learning, a 4D tensor is often used to represent a batch of images, where the dimensions could be (batch_size, channels, height, width):\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ntensor_4d = np.random.randint(10, size=(2, 3, 4, 5))  # 2 batches, 3 channels, 4x5 images\nprint(tensor_4d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[[[4 1 2 5 3]\n   [7 9 5 0 7]\n   [9 2 0 9 7]\n   [5 8 9 7 1]]\n\n  [[9 8 1 3 6]\n   [8 9 1 0 0]\n   [7 7 3 6 7]\n   [4 8 0 1 9]]\n\n  [[4 7 6 0 7]\n   [3 9 9 5 4]\n   [5 2 2 2 5]\n   [1 5 4 2 3]]]\n\n\n [[[2 3 2 1 5]\n   [1 6 4 8 4]\n   [7 4 8 2 9]\n   [7 9 5 8 7]]\n\n  [[5 8 1 4 0]\n   [8 7 1 4 3]\n   [8 1 3 0 8]\n   [5 6 1 9 2]]\n\n  [[2 6 3 5 2]\n   [2 9 2 4 1]\n   [5 6 8 7 5]\n   [1 7 1 0 5]]]]\n```\n:::\n:::\n\n\n:::{.callout-note}\n### General Syntax for Creating Tensors Using NumPy\n```{.python}\nnp.array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)\n```\n- object: An array-like object (nested lists) that you want to convert to a tensor.\n- dtype: The desired data type for the tensor elements.\n- copy: Whether to copy the data (default True).\n- order: Row-major (C) or column-major (F) order.\n- ndmin: Specifies the minimum number of dimensions for the tensor.\n::::\n\nIn the next section we will discuss the various attributes of the `NumPy` array.\n\n#### Attributes of arrays\n\nEach array has attributes ``ndim`` (the number of dimensions), ``shape`` (the size of each dimension), and ``size`` (the total size of the array):\n\nTo illustrate this attributes, consider the following arrays:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n#np.random.seed(0)  # seed for reproducibility\n\nx1 = np.random.randint(10, size=6)  # One-dimensional array\nx2 = np.random.randint(10, size=(3, 4))  # Two-dimensional array\nx3 = np.random.randint(10, size=(3, 4, 5))  # Three-dimensional array\n```\n:::\n\n\nThe array attributes of $x_3$ is shown below.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nprint(\"x3 ndim: \", x3.ndim)\nprint(\"x3 shape:\", x3.shape)\nprint(\"x3 size: \", x3.size)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx3 ndim:  3\nx3 shape: (3, 4, 5)\nx3 size:  60\n```\n:::\n:::\n\n\nAnother useful attribute are the ``dtype`` which return the data type of the array , ``itemsize``, which lists the size (in bytes) of each array element, and ``nbytes``, which lists the total size (in bytes) of the array: \n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nprint(\"dtype:\", x3.dtype)\nprint(\"itemsize:\", x3.itemsize, \"bytes\")\nprint(\"nbytes:\", x3.nbytes, \"bytes\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndtype: int32\nitemsize: 4 bytes\nnbytes: 240 bytes\n```\n:::\n:::\n\n\n### Array Indexing: Accessing Single Elements\n\nIf you are familiar with Python's standard list indexing, indexing in `NumPy` will feel quite familiar.\nIn a one-dimensional array, the $i^{th}$ value (counting from zero) can be accessed by specifying the desired index in square brackets, just as with Python lists:\n\nTo demonstrate indexing, let us consider the one dimensional array:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nx1=np.array([8, 5, 4, 7,4,1])\n```\n:::\n\n\nThe fourth element of `x1` can be accessed as \n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nprint(x1[3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n7\n```\n:::\n:::\n\n\nNow the second element from the end of the the arrray `x1` can be accessed as:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nprint(x1[-2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n```\n:::\n:::\n\n\n#### Acessing elements in multi-dimensional arrays\n\nIn a multi-dimensional array, items can be accessed using a comma-separated tuple of indices. An example is shown below.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nx2=np.array([[3, 3, 9, 2],\n       [5, 2, 3, 5],\n       [7, 2, 7, 1]])\nprint(x2)# list the 2-D array\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[3 3 9 2]\n [5 2 3 5]\n [7 2 7 1]]\n```\n:::\n:::\n\n\nNow print the third element in the first row, we will use the following code.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nx2[0, 2] ## access the element in first row and thrid column\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\nnp.int64(9)\n```\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nx2[2, -1] ## access the element in the 3rd row and last column\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\nnp.int64(1)\n```\n:::\n:::\n\n\n#### Modification of array elements\n\nValues can also be modified using any of the above index notation. An example is shown below.\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nx2[2, -1]=20 ## replace the 3rd row last column element of x2 by 20\nprint(x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 3  3  9  2]\n [ 5  2  3  5]\n [ 7  2  7 20]]\n```\n:::\n:::\n\n\n:::{.callout-note}\n### Homogenity of data in `NumPy` arrays\n\nKeep in mind that, unlike Python lists, NumPy arrays have a fixed type. This means, for example, that if you attempt to insert a floating-point value to an integer array, the value will be silently truncated. Don't be caught unaware by this behavior!\n\n:::\n\n\n#### Array Slicing: Accessing Subarrays\n\nJust as we can use square brackets to access individual array elements, we can also use them to access subarrays with the *slice* notation, marked by the colon (``:``) character.\nThe NumPy slicing syntax follows that of the standard Python list; to access a slice of an array ``x``, use this:\n``` python\nx[start:stop:step]\n```\nIf any of these are unspecified, they default to the values ``start=0``, ``stop=``*``size of dimension``*, ``step=1``.\n\nWe'll take a look at accessing sub-arrays in one dimension and in multiple dimensions.\n\n**1. One-dimensional subarrays**\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nx = np.arange(0,10)\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n```\n:::\n:::\n\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nx[1:6]  # first five elements\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\narray([1, 2, 3, 4, 5])\n```\n:::\n:::\n\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nx[5:]  # elements after index 5\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\narray([5, 6, 7, 8, 9])\n```\n:::\n:::\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nx[4:7]  # middle sub-array\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\narray([4, 5, 6])\n```\n:::\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nx[::2]  # every other element with step 2 (alternate elements)\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\narray([0, 2, 4, 6, 8])\n```\n:::\n:::\n\n\n**2. Multi-dimensional subarrays (slicing)**\n\nMulti-dimensional slices work in the same way, with multiple slices separated by commas.\nFor example:\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# creating a two dimensional array\nx2=np.array([[1,2,3],[3,4,5],[5,6,7]])\nprint(x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3]\n [3 4 5]\n [5 6 7]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# selecting first 3 rows and first two columns from x2\nprint(x2[:3,:2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2]\n [3 4]\n [5 6]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nprint(x2[:3:2,:3:2]) # slice alternate elements in first three rows and first three columns\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 3]\n [5 7]]\n```\n:::\n:::\n\n\n:::{.callout-note}\n### Accessing array rows and columns\n\nOne commonly needed routine is accessing of single rows or columns of an array.\nThis can be done by combining indexing and slicing, using an empty slice marked by a single colon (``:``)\n:::\n\nFor example *all the elements* in first column can be accessed as:\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nprint(x2[:, 0])  # first column of x2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 3 5]\n```\n:::\n:::\n\n\n#### Creating copies of arrays\n\nDespite the nice features of array views, it is sometimes useful to instead explicitly copy the data within an array or a subarray. This can be most easily done with the `copy()` method.\n\nThis concept can be illustrated through an example. Consider the array `x2` previously defined:\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nprint(x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3]\n [3 4 5]\n [5 6 7]]\n```\n:::\n:::\n\n\nNow take a copy of a slice of `x2` as follows.\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# create a copy of subarray and store it with the new name\nx2_sub_copy = x2[:2, :2].copy()\nprint(x2_sub_copy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2]\n [3 4]]\n```\n:::\n:::\n\n\nNow the changes happend in the copy will not affect the orginal array. For example, replace one element in the copy slice and check how it is refelected in both arrays.\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\nx2_sub_copy[0, 0] = 42\nprint(x2_sub_copy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[42  2]\n [ 3  4]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\nprint(x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3]\n [3 4 5]\n [5 6 7]]\n```\n:::\n:::\n\n\n#### More on reshaping\n\nAnother useful type of operation is reshaping of arrays.\nThe most flexible way of doing this is with the ``reshape`` method. There are various approaches in reshaping of arrays.\nFor example, if you want to put the numbers 1 through 9 in a $3 \\times 3$ grid, you can do the following:\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\nnp.arange(1, 10)\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\narray([1, 2, 3, 4, 5, 6, 7, 8, 9])\n```\n:::\n:::\n\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\ngrid = np.arange(1, 10).reshape((9, 1))\nprint(grid)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]\n [2]\n [3]\n [4]\n [5]\n [6]\n [7]\n [8]\n [9]]\n```\n:::\n:::\n\n\n:::{.callout-note}\nNote that for this to work, the size of the initial array must match the size of the reshaped array. Where possible, the reshape method will use a no-copy view of the initial array, but with non-contiguous memory buffers this is not always the case.\n\nAnother common reshaping pattern is the conversion of a one-dimensional array into a two-dimensional row or column matrix. This can be done with the reshape method, or more easily done by making use of the newaxis keyword within a slice operation:\n:::\n\n**More Examples**\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\nx = np.array([1, 2, 3])\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3]\n```\n:::\n:::\n\n\nNow check the dimension of the array created.\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\nx.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n(3,)\n```\n:::\n:::\n\n\nReshaping the array as a matrix.\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\n# row vector via reshape\nx1=x.reshape((1, 3))\nx1.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\n(1, 3)\n```\n:::\n:::\n\n\nWe can achieve the same using the `newaxis` function as shown below.\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\n# row vector via newaxis\nprint(x[np.newaxis, :])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3]]\n```\n:::\n:::\n\n\nSome other similar operations are here.\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\n# column vector via reshape\nx.reshape((3, 1))\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\narray([[1],\n       [2],\n       [3]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\n# column vector via newaxis\nx[:, np.newaxis]\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\narray([[1],\n       [2],\n       [3]])\n```\n:::\n:::\n\n\n### Array Concatenation and Splitting\n\nAll of the preceding routines worked on single arrays. It's also possible to combine multiple arrays into one, and to conversely split a single array into multiple arrays. We'll take a look at those operations here.\n\n#### Concatenation of arrays\n\nConcatenation, or joining of two arrays in NumPy, is primarily accomplished using the routines ``np.concatenate``, ``np.vstack``, and ``np.hstack``.\n``np.concatenate`` takes a tuple or list of arrays as its first argument, as we can see here:\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\nx = np.array([1, 2, 3])\ny = np.array([3, 2, 1])\nnp.concatenate([x, y])\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\narray([1, 2, 3, 3, 2, 1])\n```\n:::\n:::\n\n\nAnother example is shown here:\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\nnp.concatenate([y, y, y])\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\narray([3, 2, 1, 3, 2, 1, 3, 2, 1])\n```\n:::\n:::\n\n\nIt can also be used for two-dimensional arrays:\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\ngrid1 = np.array([[1, 2, 3],\n                 [4, 5, 6]])\ngrid2=np.array([[5,5,5],[7,7,7]])\n# concatenate along the first axis\nnm=np.concatenate([grid1, grid2],axis=0)\nnm.shape\nprint(nm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3]\n [4 5 6]\n [5 5 5]\n [7 7 7]]\n```\n:::\n:::\n\n\nRow-wise concatenation is showm below.\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\n# concatenate along the second axis (horrizontal) (zero-indexed)\nnp.concatenate([grid1, grid2], axis=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\narray([[1, 2, 3, 5, 5, 5],\n       [4, 5, 6, 7, 7, 7]])\n```\n:::\n:::\n\n\nFor working with arrays of mixed dimensions, it can be clearer to use the `np.vstack` (vertical stack) and `np.hstack` (horizontal stack) functions:\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\nx = np.array([1, 2, 3])\ngrid = np.array([[9, 8, 7],\n                 [6, 5, 4]])\n\n# vertically stack the arrays\ngrid\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n```\narray([[9, 8, 7],\n       [6, 5, 4]])\n```\n:::\n:::\n\n\nNow the new vector `x` has the same number of columns of `grid`. So we can only vertically stack it `grid`. For this the numpy function `vstack` will be used as follows.\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\ngrid2=np.vstack([grid,x])\nprint(grid2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[9 8 7]\n [6 5 4]\n [1 2 3]]\n```\n:::\n:::\n\n\nSimilarly the horrizontal stacking can be shown as follows.\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\n# horizontally stack the arrays\ny = np.array([[99],\n              [99],[3]])\nnp.hstack([grid2, y])\n```\n\n::: {.cell-output .cell-output-display execution_count=50}\n```\narray([[ 9,  8,  7, 99],\n       [ 6,  5,  4, 99],\n       [ 1,  2,  3,  3]])\n```\n:::\n:::\n\n\n#### Splitting of arrays\n\nThe opposite of concatenation is splitting, which is implemented by the functions ``np.split``, ``np.hsplit``, and ``np.vsplit``.  For each of these, we can pass a list of indices giving the split points:\n\nLet's begin with one dimensional arrays. First we split this array at specified locations and save it into sub arrays.\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\nx = [1, 2, 3, 99, 99, 3, 2, 1]\n```\n:::\n\n\nNow split the list into two sub lists at index 2\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\nx1,x2=np.split(x,[2])\n```\n:::\n\n\nNow see the sub-arrays:\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\nprint(\"the first array is:\", x1)\nprint(\"the second array is:\", x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe first array is: [1 2]\nthe second array is: [ 3 99 99  3  2  1]\n```\n:::\n:::\n\n\nMore sub arrays can be created by passing the splitting locations as a list as follows.\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\nx1,x2,x3=np.split(x,[2,4])\nprint(x1,\"\\n\",x2,'\\n',x3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2] \n [ 3 99] \n [99  3  2  1]\n```\n:::\n:::\n\n\n:::{.callout-note}\n Notice that $N$ split-points, leads to $N + 1$ subarrays.\n The related functions ``np.hsplit`` and ``np.vsplit`` are similar:\n:::\n\nNow use the `vsplit` and `hsplit` functions on multi dimensional arrays.\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\ngrid = np.arange(16).reshape((4, 4))\ngrid\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n```\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\n# vsplit\nupper, lower = np.vsplit(grid, [2])\nprint(upper)\nprint(lower)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0 1 2 3]\n [4 5 6 7]]\n[[ 8  9 10 11]\n [12 13 14 15]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\n#hsplit\nleft, right = np.hsplit(grid, [2])\nprint(\"Left array:\\n\",left,\"\\n Right array:\\n\",right)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLeft array:\n [[ 0  1]\n [ 4  5]\n [ 8  9]\n [12 13]] \n Right array:\n [[ 2  3]\n [ 6  7]\n [10 11]\n [14 15]]\n```\n:::\n:::\n\n\n### Review Questions\n\n**Short Answer Questions (SAQ)**\n\n**Q1: What is the main purpose of the NumPy library in Python?**  \n**Ans:** The main purpose of NumPy is to provide support for large, multi-dimensional arrays and matrices, along with a collection of mathematical functions to perform operations on these arrays efficiently.\n\n**Q2: How can a 1D array be created in NumPy?**  \n**Ans:** A 1D array can be created using `np.array()` function, like:  \n```python\nnp.array([1, 2, 3])\n```\n\n**Q3: How do you access the shape of a NumPy array?**\n\n**Ans:** You can access the shape of a NumPy array using the .shape attribute.\nFor example, array.shape gives the dimensions of the array.\n\n**Q4: What does the np.reshape() function do?**\n\n**Ans:** The np.reshape() function reshapes an array to a new shape without changing its data.\n\n**Q5: Explain the difference between vstack() and hstack() in NumPy.**\n\n**Ans:** vstack() vertically stacks arrays (along rows), while hstack() horizontally stacks arrays (along columns).\n\n**Q6: How does NumPy handle array slicing?**\n\n**Ans:** Array slicing in NumPy is done by specifying the start, stop, and step index like array[start:stop:step], which returns a portion of the array.\n\n**Q7: What is the difference between the np.zeros() and np.ones() functions?**\n\n**Ans:** np.zeros() creates an array filled with zeros, while np.ones() creates an array filled with ones.\n\n**Q8: What is array broadcasting in NumPy?**\n\n**Ans:** Broadcasting in NumPy allows arrays of different shapes to be used in arithmetic operations by stretching the smaller array to match the shape of the larger array.\n\n**Q9: How can you stack arrays along a new axis in NumPy?**\n**Ans:** You can use np.stack() to join arrays along a new axis.\n\n**Q10: How do you generate a random integer array using NumPy?**\n\n**Ans:** You can generate a random integer array using np.random.randint(low, high, size).\n\n----\n**Long Answer Questions (LAQ)**\n\n**Q1: Explain how array slicing works in NumPy.**\n\n**Ans:** Array slicing in NumPy is a method to access or modify a subset of elements from a larger array. The syntax for slicing is array[start:stop:step], where:\n\nstart is the index from which slicing begins (inclusive),\nstop is the index where slicing ends (exclusive),\nstep is the interval between indices to include in the slice.\nFor example, in a 1D array, arr[1:5:2] will return every second element between the indices 1 and 4.\n\n**Q2: Discuss the difference between the .reshape() function and the .ravel() function in NumPy.**\n\n**Ans:** The .reshape() function changes the shape of an array without modifying its data, allowing a multi-dimensional array to be flattened or reshaped into any compatible shape.\nOn the other hand, .ravel() returns a flattened 1D version of an array, but it tries to avoid copying the data by returning a flattened view where possible. If modifying the flattened array is necessary, ravel() returns a copy instead.\n\n**Q3: Explain how NumPy handles broadcasting during array operations.**\n\n**Ans:** Broadcasting in NumPy is a method to perform element-wise operations on arrays of different shapes. Smaller arrays are \"broadcast\" across the larger array by repeating their elements to match the shape of the larger array.\nFor example, when adding a scalar to a 2D array, the scalar is added to each element of the array by broadcasting the scalar to match the array's shape. Similarly, operations between arrays of different shapes follow the broadcasting rules to make them compatible.\n\n**Q4: Describe how you would split an array in NumPy using the np.split() function. Provide an example.**\n\n**Ans:** The np.split() function in NumPy divides an array into multiple sub-arrays based on the indices provided. The syntax is:\nnp.split(array, indices)\nHere, array is the array to be split, and indices is a list of indices where the split will occur.\nFor example:\n```python\narr = np.array([1, 2, 3, 4, 5, 6])  \nnp.split(arr, [2, 4])  \n```\nThis splits the array at indices 2 and 4, resulting in three sub-arrays: [1, 2], [3, 4], and [5, 6].\n\n**Q5: What are the key differences between np.hsplit() and np.vsplit()? Provide examples.**\n\n**Ans:** np.hsplit() horizontally splits an array along its columns, while np.vsplit() vertically splits an array along its rows.\nFor example, if we have a 2D array:\n\n```python\narr = np.array([[1, 2, 3], [4, 5, 6]])  \n```\nnp.hsplit(arr, 3) splits the array into three columns, each with two rows: [[1], [4]], [[2], [5]], [[3], [6]].\nnp.vsplit(arr, 2) splits the array into two sub-arrays along rows: [[1, 2, 3]] and [[4, 5, 6]].\n\n**Q6: How can you create a 2D array with random integers between 1 and 10 using NumPy? Provide an example.**\n\n**Ans:** A 2D array with random integers between 1 and 10 can be created using np.random.randint(low, high, size).\nExample:\n\n```python\nnp.random.randint(1, 10, size=(3, 3))\n```\nThis generates a 3x3 array with random integers between 1 and 9.\n\n**Q7: Describe how you would reshape an array from 1D to 2D in NumPy.**\n\n**Ans:** Reshaping an array from 1D to 2D in NumPy can be done using the .reshape() function.\nFor example, given a 1D array:\n\n```python\narr = np.array([1, 2, 3, 4, 5, 6])  \n```\nTo reshape it into a 2D array with 2 rows and 3 columns:\n\n```python\narr.reshape(2, 3)\n```\nThis results in `[[1, 2, 3], [4, 5, 6]]`.\n\n**Q8: Explain the concept of stacking arrays in NumPy using np.stack(). Provide an example.**\n\n**Ans:** np.stack() joins arrays along a new axis, unlike hstack() and vstack(), which concatenate along existing axes.\nFor example:\n\n```python\narr1 = np.array([1, 2, 3])  \narr2 = np.array([4, 5, 6])  \nnp.stack((arr1, arr2), axis=0)\n```\nThis stacks the arrays along a new axis, resulting in [[1, 2, 3], [4, 5, 6]].\n\n**Q9: How does NumPy’s array_split() differ from split()? Provide an example.**\n\n**Ans:** The array_split() function allows unequal splitting of an array, whereas split() requires the splits to result in equal-sized sub-arrays.\nFor example:\n\n```python\narr = np.array([1, 2, 3, 4, 5])  \nnp.array_split(arr, 3)\n```\n\nThis will split the array into three parts: [1, 2], [3, 4], and [5].\n\n**Q10: How would you flatten a multi-dimensional array into a 1D array in NumPy?**\n\n**Ans:** You can flatten a multi-dimensional array using the .ravel() or .flatten() methods.\nExample using ravel():\n\n```python\narr = np.array([[1, 2], [3, 4]])  \narr.ravel()\n```\nThis flattens the array into [1, 2, 3, 4].\n\n**Q11: Discuss the importance of NumPy in scientific computing and how it handles large datasets efficiently.**\n\n**Ans:**\nNumPy is crucial in scientific computing because it provides efficient storage and operations for large datasets through its n-dimensional array objects. It uses continuous memory blocks, making array operations faster than traditional Python lists, and supports a variety of mathematical functions and broadcasting, which simplifies computation.\n\nNumPy operates efficiently by:\n\n- Avoiding type checking at each operation due to its homogeneous data type constraint.\n- Leveraging vectorization to reduce the need for explicit loops in operations.\n- Providing optimized C and Fortran libraries for core computations.\n\nExample of large dataset handling:\n\n```python\nlarge_array = np.random.rand(1000000)\nsum_large_array = np.sum(large_array)  # Efficient summation\n```\nThis efficiency makes NumPy a foundation for data-driven scientific applications like machine learning, signal processing, and simulations.\n\n**Q12: What is the difference between a view and a copy in NumPy? Why does this matter in array operations?**\n\n**Ans:**\nA view is a reference to the original array, meaning changes in the view will affect the original array. A copy creates a new, independent array.\n\nExample:\n\n```python\narr = np.array([1, 2, 3])\nview = arr[:2]  # Creates a view\ncopy = arr[:2].copy()  # Creates a copy\nview[0] = 99  # This will change arr\n```\nViews are more memory-efficient, but changes to them affect the original data, whereas copies do not.\n\n**Q13: How are higher-dimensional arrays handled in NumPy, and how can they be reshaped and indexed? Provide a practical example.**\n\n**Ans:**\nHigher-dimensional arrays (tensors) in NumPy can be created and manipulated like 1D and 2D arrays. You can reshape tensors using reshape() and index them similarly, using one index for each dimension.\n\n```python\ntensor = np.arange(24).reshape(2, 3, 4)  # 3D tensor with shape (2, 3, 4)\nelement = tensor[1, 2, 3]  # Access element at specified indices\n```\nwe can reshape tensors:\n```python\nreshaped_tensor = tensor.reshape(4, 6)\n```\n\n## Some important `NumPy` function for Linear Algrbra\n\nLet’s start with some basic matrix operations. Suppose we have two matrices, A and B, and we want to add them together. In NumPy, we can do this with the simple command, `A+B`. Let's look into the detailed computational steps.\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\n# Addition and Subtraction\nmatrix1 = np.array([[1, 2], [3, 4]])\nmatrix2 = np.array([[5, 6], [7, 8]])\nprint(matrix1 + matrix2) # prints [[6, 8], [10, 12]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 6  8]\n [10 12]]\n```\n:::\n:::\n\n\nSimilary, matrix difference and other matrix operations can be illustrated as follows.\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\nprint(matrix1 - matrix2) # prints [[-4, -4], [-4, -4]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[-4 -4]\n [-4 -4]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\n# Scalar Multiplication\nmatrix = np.array([[1, 2], [3, 4]])\nprint(2 * matrix) # prints [[2, 4], [6, 8]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[2 4]\n [6 8]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\n# Matrix Multiplication\nmatrix1 = np.array([[1, 2], [3, 4]])\nmatrix2 = np.array([[5, 6], [7, 8]])\nprint(np.dot(matrix1, matrix2)) # prints [[19, 22], [43, 50]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[19 22]\n [43 50]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=62}\n``` {.python .cell-code}\n# Matrix Hadamards product\nmatrix1 = np.array([[1, 2], [3, 4]])\nmatrix2 = np.array([[5, 6], [7, 8]])\nprint(matrix1*matrix2) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 5 12]\n [21 32]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=63}\n``` {.python .cell-code}\n# Transpose\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\nprint(np.transpose(matrix)) # prints [[1, 4], [2, 5], [3, 6]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 4]\n [2 5]\n [3 6]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=64}\n``` {.python .cell-code}\n# inverse of a matrix\na = np.array([[1, 2], [3, 4]])\na_inv = np.linalg.inv(a)\n```\n:::\n\n\nNext, let’s talk about vectors. A vector is simply a matrix with one column. They’re often used to represent things like forces or velocities in physics. In NumPy, we can represent vectors as arrays with one dimension.\n\n::: {.cell execution_count=65}\n``` {.python .cell-code}\nvector = np.array([1, 2, 3])\nprint(vector) # prints [1, 2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3]\n```\n:::\n:::\n\n\nLet’s say we have two vectors, $\\vec{u}$ and $\\vec{v}$, and we want to compute their dot product (i.e., the sum of the products of their corresponding entries). We can do this with the command:\n\n::: {.cell execution_count=66}\n``` {.python .cell-code}\nvector1 = np.array([1, 2, 3])\nvector2 = np.array([4, 5, 6])\nprint(np.dot(vector1, vector2)) # prints 32\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n32\n```\n:::\n:::\n\n\nLike that there are some other operations too.\n\n::: {.cell execution_count=67}\n``` {.python .cell-code}\n# Cross Product\nvector1 = np.array([1, 2, 3])\nvector2 = np.array([4, 5, 6])\nprint(np.cross(vector1, vector2)) # prints [-3, 6, -3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[-3  6 -3]\n```\n:::\n:::\n\n\n:::{.callout-note}\n *Norm:* The norm of a vector is a scalar that represents the \"length\" of the vector. In NumPy, we can compute the norm using the `numpy.linalg.norm` function.\n The inner product of two vectors is a matrix that is computed by multiplying the first vector by the transpose of the second vector. In NumPy, we can \ncompute the inner product using the numpy.inner function.\n:::\n\n::: {.cell execution_count=68}\n``` {.python .cell-code}\n# finding norm\nvector = np.array([1, 2, 3])\nprint(np.linalg.norm(vector)) # prints 3.74165738677\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3.7416573867739413\n```\n:::\n:::\n\n\n::: {.cell execution_count=69}\n``` {.python .cell-code}\n#finding inner product\nvector1 = np.array([1, 2, 3])\nvector2 = np.array([4, 5, 6])\nprint(np.inner(vector1, vector2)) # prints 32\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n32\n```\n:::\n:::\n\n\nTo handle higher dimensional mutrix multiplication, one can use `matmul()` function. The `np.matmul()` function is another way to perform matrix multiplication. Unlike `np.dot()`, it handles higher-dimensional arrays correctly by broadcasting. The syntax for this operation is `np.matmul(a, b)`.\n\n::: {.cell execution_count=70}\n``` {.python .cell-code}\nA = np.array([[1, 0], [0, 1]])\nB = np.array([[4, 1], [2, 2]])\n\n# Matrix multiplication using matmul\nresult = np.matmul(A, B)\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[4 1]\n [2 2]]\n```\n:::\n:::\n\n\nThe function `np.linalg.inv()`  computes the inverse of a square matrix. Syntax for this function is `np.linalg.inv(a)`. An example is shown below.\n\n::: {.cell execution_count=71}\n``` {.python .cell-code}\nA = np.array([[1, 2], [3, 4]])\n\n# Compute inverse\ninv_A = np.linalg.inv(A)\nprint(inv_A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[-2.   1. ]\n [ 1.5 -0.5]]\n```\n:::\n:::\n\n\nThe `np.linalg.det()` function computes the determinant of a square matrix. The determinant is useful for solving linear systems and understanding matrix properties. The syntax is `np.linalg.det(a)`.\n\n::: {.cell execution_count=72}\n``` {.python .cell-code}\nA = np.array([[1, 2], [3, 4]])\n\n# Compute determinant\ndet_A = np.linalg.det(A)\nprint(det_A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-2.0000000000000004\n```\n:::\n:::\n\n\nThe `np.linalg.solve()` function solves a linear matrix equation or system of linear scalar equations. It finds the vector x that satisfies $Ax = b$. Syntax for this function is `np.linalg.solve(A, b)`.\n\n::: {.cell execution_count=73}\n``` {.python .cell-code}\nA = np.array([[3, 1], [1, 2]])\nb = np.array([9, 8])\n\n# Solve system of equations\nx = np.linalg.solve(A, b)\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2. 3.]\n```\n:::\n:::\n\n\nThis function computes the QR decomposition of a matrix. QR decomposition is used to solve linear systems, least squares problems, and compute eigenvalues. Syntax for this function is `np.linalg.qr()`.\n\n::: {.cell execution_count=74}\n``` {.python .cell-code}\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n# QR decomposition\nQ, R = np.linalg.qr(A)\nprint(\"Q:\", Q)\nprint(\"R:\", R)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nQ: [[-0.12309149  0.90453403  0.40824829]\n [-0.49236596  0.30151134 -0.81649658]\n [-0.86164044 -0.30151134  0.40824829]]\nR: [[-8.12403840e+00 -9.60113630e+00 -1.10782342e+01]\n [ 0.00000000e+00  9.04534034e-01  1.80906807e+00]\n [ 0.00000000e+00  0.00000000e+00 -8.88178420e-16]]\n```\n:::\n:::\n\n\nThe `np.linalg.lstsq()` function solves a linear least-squares problem, which is useful in regression tasks. The syntax for the function is `np.linalg.lstsq(a, b, rcond=None)`.\n\n::: {.cell execution_count=75}\n``` {.python .cell-code}\nA = np.array([[1, 1], [1, 2], [2, 2], [2, 3]])\nb = np.array([6, 8, 9, 11])\n\n# Least-squares solution\nx, residuals, rank, s = np.linalg.lstsq(A, b, rcond=None)\nprint(\"Solution:\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSolution: [2.09090909 2.54545455]\n```\n:::\n:::\n\n\nThe Kronecker product is a matrix operation used in various applications like tensor products and matrix calculus. Syntax for this function is `np.kron(a, b)`.\n\n::: {.cell execution_count=76}\n``` {.python .cell-code}\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[0, 5], [6, 7]])\n\nkronecker = np.kron(A, B)\nprint(kronecker)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 0  5  0 10]\n [ 6  7 12 14]\n [ 0 15  0 20]\n [18 21 24 28]]\n```\n:::\n:::\n\n\nCosine similarity is used to find the cosine of the angle between two vectors. The mathematical formula for this operation is $\\cos \\theta=\\frac{\\vec{a}\\cdot \\vec{b}}{|\\vec{a}\\cdot\\vec{b}|}$. The python function to calculate the cosine similarity is shown below.\n\n::: {.cell execution_count=77}\n``` {.python .cell-code}\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\n\ncosine_sim = np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))\nprint(cosine_sim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.9746318461970762\n```\n:::\n:::\n\n\n### Linear Regression using `NumPy`\n\nThe `np.polyfit()` function fits a polynomial of a specified degree to the data, making it useful for regression. Syntax for this function is `np.polyfit(x, y, deg)`. Where $x$ Independent variable (input), $y$ is the dependent variable (output) and `deg` degree of the fitting polynomial. A simple example is given below.\n\n::: {.cell execution_count=78}\n``` {.python .cell-code}\nx = np.array([0, 1, 2, 3, 4])\ny = np.array([1, 3, 5, 7, 9])\n\n# Linear fit (degree 1)\ncoefficients = np.polyfit(x, y, 1)\nprint(\"Coefficients:\", coefficients)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoefficients: [2. 1.]\n```\n:::\n:::\n\n\n### Some interesting handy matrix operations using numpy arrays\n\nIn matrix decomposition, we need the matrix representation, $A-\\lambda I$. For any matrix, we can do this by just `A-lambda np.eye(3)`. This can be deomonstarted here.\n\n::: {.cell execution_count=79}\n``` {.python .cell-code}\nA=np.array([[1,2,3],[3,4,5],[7,6,7]])\nlamda=3\nA-lamda*np.eye(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=79}\n```\narray([[-2.,  2.,  3.],\n       [ 3.,  1.,  5.],\n       [ 7.,  6.,  4.]])\n```\n:::\n:::\n\n\n>**Task:** Create a matrix, $A$ using `numpy`  and find the covariance , $cov(A)$ using matrix operation.\n\n::: {.cell execution_count=80}\n``` {.python .cell-code}\n# creating a random matrix\nimport numpy as np\nA=np.arange(16).reshape(4,4)\nA\n```\n\n::: {.cell-output .cell-output-display execution_count=80}\n```\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n```\n:::\n:::\n\n\nNow find $A-\\bar{A}$.\n\n::: {.cell execution_count=81}\n``` {.python .cell-code}\nA_bar=np.mean(A,axis=0) # calculating column-wise sum\nA_bar\n```\n\n::: {.cell-output .cell-output-display execution_count=81}\n```\narray([6., 7., 8., 9.])\n```\n:::\n:::\n\n\n::: {.cell execution_count=82}\n``` {.python .cell-code}\n# calculating A-A bar with outer product opertation\nprint(A-np.outer(A_bar,np.ones(4)).T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[-6. -6. -6. -6.]\n [-2. -2. -2. -2.]\n [ 2.  2.  2.  2.]\n [ 6.  6.  6.  6.]]\n```\n:::\n:::\n\n\n:::{.callout-note}\nThe same can be done using reshaping method\n\n::: {.cell execution_count=83}\n``` {.python .cell-code}\n#calculating A-A_bar using broadcasting\nX=A-np.mean(A,axis=0).reshape(1,4)\nprint(X)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[-6. -6. -6. -6.]\n [-2. -2. -2. -2.]\n [ 2.  2.  2.  2.]\n [ 6.  6.  6.  6.]]\n```\n:::\n:::\n\n\n:::\n\nCalculating the covariance.\n\n::: {.cell execution_count=84}\n``` {.python .cell-code}\n#mannualy calculating covariance\nCoV=(1/3)*np.dot(X.T,X)\nCoV\n```\n\n::: {.cell-output .cell-output-display execution_count=84}\n```\narray([[26.66666667, 26.66666667, 26.66666667, 26.66666667],\n       [26.66666667, 26.66666667, 26.66666667, 26.66666667],\n       [26.66666667, 26.66666667, 26.66666667, 26.66666667],\n       [26.66666667, 26.66666667, 26.66666667, 26.66666667]])\n```\n:::\n:::\n\n\nWe can verify the same using default function as follows.\n\n::: {.cell execution_count=85}\n``` {.python .cell-code}\n#calculating covariance using numpy function\nnp.cov(A, rowvar=False)\n```\n\n::: {.cell-output .cell-output-display execution_count=85}\n```\narray([[26.66666667, 26.66666667, 26.66666667, 26.66666667],\n       [26.66666667, 26.66666667, 26.66666667, 26.66666667],\n       [26.66666667, 26.66666667, 26.66666667, 26.66666667],\n       [26.66666667, 26.66666667, 26.66666667, 26.66666667]])\n```\n:::\n:::\n\n\n:::{.callout-note}\nIt is interesting to compare the two ways of flattening an array using `reshape()`.\n\n::: {.cell execution_count=86}\n``` {.python .cell-code}\n#comparing two ways of flattening a matrix using numpy\nA.reshape(-1)==A.reshape(16,)\n```\n\n::: {.cell-output .cell-output-display execution_count=86}\n```\narray([ True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True])\n```\n:::\n:::\n\n\n:::\n\n\n## Basics of `SciPy` Library for Computational Linear Algebra\n\nFollowing the comprehensive exploration of the NumPy library, which forms the foundation of array operations and basic linear algebra computations, it is essential to expand into more advanced tools for scientific computing. The **SciPy** library builds upon NumPy, offering a vast collection of functions and utilities specifically designed for higher-level operations in scientific and technical computing. While NumPy provides efficient array handling and basic matrix operations, SciPy extends these capabilities by incorporating advanced functions for optimization, integration, interpolation, and linear algebra, among other tasks [@2020SciPy-NMeth]. \n\nFor computational linear algebra, SciPy provides specialized modules like `scipy.linalg`, which can handle everything from solving linear systems to eigenvalue decompositions and matrix factorizations. This transition from NumPy to SciPy enables the handling of more complex problems efficiently and allows users to leverage optimized algorithms for large-scale numerical computations. By integrating SciPy into the workflow, computations can be carried out more robustly, expanding on the basic linear algebra concepts introduced through NumPy with advanced techniques necessary for practical applications.\n\n### Basic Matrix operations\n\n`SciPy` builds on the functionality of NumPy, offering more sophisticated and optimized algorithms, particularly suited for numerical computing tasks. While `NumPy` provides essential operations for linear algebra, `SciPy`'s `scipy.linalg` module extends these capabilities with more advanced functions. `SciPy` functions are often better optimized for large-scale systems, making them highly efficient for computational linear algebra applications.\n\nAs the first step to use `SciPy`, we need to import the (only) necessary submodules for our specific tasks. In our discussion, we consider only linear algebra. So we import the `linalg` submodule as follows\n\n::: {.cell execution_count=87}\n``` {.python .cell-code}\n#import scipy\nimport numpy as np # for matrix definition\nfrom scipy import linalg\n#print(scipy.__version__) # check version\n```\n:::\n\n\nNow let's discuss various `SciPy` functions for linear algebra with examples.\n\n#### Computing the Determinant\n\nThe determinant is a scalar value that can be computed from the elements of a square matrix and is often used to determine whether a system of linear equations has a unique solution.\n\n>*Syntax:* `scipy.linalg.det(A)`\n\n::: {.cell execution_count=88}\n``` {.python .cell-code}\n# example\nA = np.array([[1, 2], [3, 4]])\ndet_A = linalg.det(A)\nprint(det_A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-2.0\n```\n:::\n:::\n\n\n:::{.callout-note}\nSimilar functionality is provided by `np.linalg.det()`. However, `scipy.linalg.det()` is often preferred when working with very large matrices due to the efficiency of SciPy's backend implementations.\n:::\n\n#### Solving Linear Systems of Equations\n\nOne of the fundamental tasks in linear algebra is solving a system of linear equations of the form $AX = b$, where $A$ is a matrix and $b$ is a vector or matrix of known values.\n>*Syntax:* `scipy.linalg.solve(A, b)`\n\n::: {.cell execution_count=89}\n``` {.python .cell-code}\n#example\nA = np.array([[3, 1], [1, 2]])\nb = np.array([9, 8])\nx = linalg.solve(A, b)\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2. 3.]\n```\n:::\n:::\n\n\n:::{.callout-note}\nNumPy's `np.linalg.solve()` also provides this functionality, but SciPy's version is better suited for larger and more complex matrices because it uses more efficient algorithms for decomposing the matrix.\n:::\n\n#### Matrix Inversion\nMatrix inversion is a critical operation in many linear algebra problems, particularly in solving systems of linear equations.\n>*Syntax:* `scipy.linalg.inv(A)`\n\n::: {.cell execution_count=90}\n``` {.python .cell-code}\nA = np.array([[1, 2], [3, 4]])\ninv_A = linalg.inv(A)\nprint(inv_A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[-2.   1. ]\n [ 1.5 -0.5]]\n```\n:::\n:::\n\n\n#### Kronecker Product\n\nThe Kronecker product is used in various applications, including constructing block matrices and expanding the dimensionality of matrices.\n\n>*Syntax:* `scipy.linalg.kron(A, B)`\n\n::: {.cell execution_count=91}\n``` {.python .cell-code}\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[0, 5], [6, 7]])\nkron_product = linalg.kron(A, B)\nprint(kron_product)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 0  5  0 10]\n [ 6  7 12 14]\n [ 0 15  0 20]\n [18 21 24 28]]\n```\n:::\n:::\n\n\n#### Eigenvalues and Eigenvectors\n\nEigenvalues and eigenvectors are fundamental in many areas of linear algebra, including solving systems of differential equations and performing dimensionality reduction in machine learning.\n\n>*Syntax:* `scipy.linalg.eig(A)`\n\n::: {.cell execution_count=92}\n``` {.python .cell-code}\nA = np.array([[3, 2], [4, 1]])\neigenvalues, eigenvectors = linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\", eigenvectors)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEigenvalues: [ 5.+0.j -1.+0.j]\nEigenvectors: [[ 0.70710678 -0.4472136 ]\n [ 0.70710678  0.89442719]]\n```\n:::\n:::\n\n\n## Sparse Matrices\n\nSparse matrices are often useful in numerical simulations dealing with large systems, if the problem can be described in matrix form where the matrices or vectors mostly contains zeros. Scipy has a good support for sparse matrices, with basic linear algebra operations (such as equation solving, eigenvalue calculations, etc.).\n\nThere are many possible strategies for storing sparse matrices in an efficient way. Some of the most common are the so-called coordinate form (COO), list of list (LIL) form,  and compressed-sparse column CSC (and row, CSR). Each format has some advantages and disadvantages. Most computational algorithms (equation solving, matrix-matrix multiplication, etc.) can be efficiently implemented using CSR or CSC formats, but they are not so intuitive and not so easy to initialize. So often a sparse matrix is initially created in COO or LIL format (where we can efficiently add elements to the sparse matrix data), and then converted to CSC or CSR before used in real calculations.\n\nFor more information about these sparse formats, see e.g. <http://en.wikipedia.org/wiki/Sparse_matrix>\n\n\n### Sparse Matrix operations in `SciPy`\n\n**Sparse matrices** are a key feature of `SciPy`, providing an efficient way to store and manipulate large matrices with a significant number of zero elements. `SciPy` offers a variety of sparse matrix formats and supports operations like matrix multiplication, addition, transposition, and solving systems of equations.\n\nHere is a guide to working with sparse matrices in `SciPy`.\n\n**Types of Sparse Matrices in SciPy**\n\n`SciPy` provides different types of sparse matrices depending on the use case:\n\n1. **CSR (Compressed Sparse Row) Matrix**: Efficient for row slicing and matrix-vector products.\n2. **CSC (Compressed Sparse Column) Matrix**: Efficient for column slicing and fast arithmetic operations.\n3. **COO (Coordinate) Matrix**: Suitable for constructing sparse matrices by specifying individual entries.\n4. **DIA (Diagonal) Matrix**: For matrices where non-zero elements are primarily on the diagonals.\n5. **LIL (List of Lists) Matrix**: Good for constructing matrices incrementally.\n\n#### Importing Sparse Matrices\n\n::: {.cell execution_count=93}\n``` {.python .cell-code}\nfrom scipy.sparse import csr_matrix, csc_matrix, coo_matrix\nimport numpy as np\n```\n:::\n\n\n**Creating Sparse Matrices**\n\n::: {.cell execution_count=94}\n``` {.python .cell-code}\n# Create a dense matrix\ndense_matrix = np.array([[0, 0, 3], [4, 0, 0], [0, 5, 6]])\n\n# Convert dense matrix to CSR format\ncsr = csr_matrix(dense_matrix)\n\n# Display CSR matrix\nprint(csr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<Compressed Sparse Row sparse matrix of dtype 'int64'\n\twith 4 stored elements and shape (3, 3)>\n  Coords\tValues\n  (0, 2)\t3\n  (1, 0)\t4\n  (2, 1)\t5\n  (2, 2)\t6\n```\n:::\n:::\n\n\n::: {.cell execution_count=95}\n``` {.python .cell-code}\n# creating sparse matrix in COO format\n# Define row indices, column indices, and values\nrow = np.array([0, 1, 2, 2])\ncol = np.array([2, 0, 1, 2])\ndata = np.array([3, 4, 5, 6])\n\n# Create COO sparse matrix\ncoo = coo_matrix((data, (row, col)), shape=(3, 3))\n\nprint(coo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<COOrdinate sparse matrix of dtype 'int64'\n\twith 4 stored elements and shape (3, 3)>\n  Coords\tValues\n  (0, 2)\t3\n  (1, 0)\t4\n  (2, 1)\t5\n  (2, 2)\t6\n```\n:::\n:::\n\n\n**Basic Operations with Sparse Matrices**\n\nThe basic matrix operations can be performed on the sparse matrix too. The difference is that in the case of sparse matices, the respective operations will be done only on non-zero enties. Now look into the basic matrix operations thorugh following examples.\n\n*Matrix Multiplication:*\n\n::: {.cell execution_count=96}\n``` {.python .cell-code}\nA = csr_matrix([[1, 0, 0], [0, 0, 1], [0, 2, 0]])\nB = csr_matrix([[4, 5], [0, 0], [7, 8]])\n\n# Matrix multiplication (dot product)\nresult = A.dot(B)\nprint(result.toarray())  # Convert to dense array for display\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[4 5]\n [7 8]\n [0 0]]\n```\n:::\n:::\n\n\n*Transposition:*\n\n::: {.cell execution_count=97}\n``` {.python .cell-code}\n# Transpose the matrix\ntransposed = A.transpose()\n\nprint(transposed.toarray())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 0 0]\n [0 0 2]\n [0 1 0]]\n```\n:::\n:::\n\n\n*Addition:*\n\n::: {.cell execution_count=98}\n``` {.python .cell-code}\n# Adding two sparse matrices\nC = csr_matrix([[0, 1, 2], [3, 0, 0], [0, 0, 5]])\nD = csr_matrix([[0, 1, 0], [0, 0, 0], [2, 0, 5]])\n\nsum_matrix = C + D\n\nprint(sum_matrix.toarray())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 0  2  2]\n [ 3  0  0]\n [ 2  0 10]]\n```\n:::\n:::\n\n\n*Solving Sparse Linear Systems*\n\nWe can solve systems of linear equations using sparse matrices with the `spsolve()` function:\n\n::: {.cell execution_count=99}\n``` {.python .cell-code}\nfrom scipy.sparse.linalg import spsolve\n\n# Create a sparse matrix (A) and a dense vector (b)\nA = csr_matrix([[3, 1, 0], [1, 2, 0], [0, 0, 1]])\nb = np.array([5, 5, 1])\n\n# Solve the system Ax = b\nx = spsolve(A, b)\n\nprint(\"Solution x:\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSolution x: [1. 2. 1.]\n```\n:::\n:::\n\n\n#### Conversion from one sparse matrix system to another\n\nWe can convert between different sparse matrix formats using the `.tocsc()`,` .tocoo()`, `.todia()`, and similar methods:\n\n::: {.cell execution_count=100}\n``` {.python .cell-code}\n# Convert CSR to COO format\ncoo = A.tocoo()\nprint(coo)\nprint(\"The matrix is :\\n\",coo.toarray())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<COOrdinate sparse matrix of dtype 'int64'\n\twith 5 stored elements and shape (3, 3)>\n  Coords\tValues\n  (0, 0)\t3\n  (0, 1)\t1\n  (1, 0)\t1\n  (1, 1)\t2\n  (2, 2)\t1\nThe matrix is :\n [[3 1 0]\n [1 2 0]\n [0 0 1]]\n```\n:::\n:::\n\n\n:::{.callout-note}\n### Summary of sparse matrix operations\n\n| Function      | Description                                   |\n|---------------|-----------------------------------------------|\n| `csr_matrix()` | Compressed Sparse Row matrix.                |\n| `csc_matrix()` | Compressed Sparse Column matrix.             |\n| `coo_matrix()` | Coordinate format matrix.                    |\n| `spsolve()`   | Solves sparse linear systems.                 |\n| `spdiags()`   | Extracts or constructs diagonal sparse matrices. |\n| `lil_matrix()` | List of lists sparse matrix.                 |\n\n\n:::\n\n\n## Visualization Libraries\n\nData visualization libraries in Python empower developers and data scientists to create compelling visual representations of data. Popular libraries include Matplotlib, which offers versatile 2-D plotting capabilities, Seaborn for statistical graphics, Bokeh for interactive web applications, Altair for declarative visualizations, and Plotly for web-based interactive charts and dashboards.\n\n\n### Matplotlib: A Comprehensive Data Visualization Library in Python\n\nMatplotlib is a powerful Python library that enables developers and data scientists to create a wide range of static, animated, and interactive visualizations. Whether we're exploring data, presenting insights, or building scientific plots, Matplotlib has we covered. Let's delve into its features:\n\n1. **Publication-Quality Plots**: Matplotlib allows us to create professional-quality plots suitable for research papers, presentations, and publications. Customize colors, fonts, and styles to match our requirements.\n2. **Versatility**: With Matplotlib, one can create line plots, scatter plots, bar charts, histograms, pie charts, and more. It supports 2-D plotting and can handle complex visualizations.\n3. **Interactive Figures**: While it's known for static plots, Matplotlib also offers interactivity. We can zoom, pan, and explore data points within the plot.\n4. **Customization**: Fine-tune every aspect of our plot, from axis labels and titles to grid lines and legends. Annotations and text can be added seamlessly.\n5. **Integration with Jupyter**: Matplotlib integrates well with Jupyter notebooks, making it a favorite among data scientists and analysts.\n\n:::{.callout-note}\n#### Background\nMatplotlib is a multi-platform data visualization library built on NumPy arrays, and designed to work with the broader SciPy stack.\nIt was conceived by John Hunter in 2002, originally as a patch to IPython for enabling interactive MATLAB-style plotting via gnuplot from the IPython command line.\nIPython's creator, Fernando Perez, was at the time scrambling to finish his PhD, and let John know he wouldn’t have time to review the patch for several months.\nJohn took this as a cue to set out on his own, and the Matplotlib package was born, with version 0.1 released in 2003.\nIt received an early boost when it was adopted as the plotting package of choice of the Space Telescope Science Institute (the folks behind the Hubble Telescope), which financially supported Matplotlib’s development and greatly expanded its capabilities.\n\nOne of Matplotlib’s most important features is its ability to play well with many operating systems and graphics backends.\nMatplotlib supports dozens of backends and output types, which means you can count on it to work regardless of which operating system you are using or which output format you wish.\nThis cross-platform, everything-to-everyone approach has been one of the great strengths of Matplotlib.\nIt has led to a large user base, which in turn has led to an active developer base and Matplotlib’s powerful tools and ubiquity within the scientific Python world.\n\nIn recent years, however, the interface and style of Matplotlib have begun to show their age.\nNewer tools like ggplot and ggvis in the R language, along with web visualization toolkits based on D3js and HTML5 canvas, often make Matplotlib feel clunky and old-fashioned.\nStill, I'm of the opinion that we cannot ignore Matplotlib's strength as a well-tested, cross-platform graphics engine.\nRecent Matplotlib versions make it relatively easy to set new global plotting styles , and people have been developing new packages that build on its powerful internals to drive Matplotlib via cleaner, more modern APIs—for example, Seaborn , ggpy, HoloViews, Altair, and even Pandas itself can be used as wrappers around Matplotlib's API.\nEven with wrappers like these, it is still often useful to dive into Matplotlib's syntax to adjust the final plot output.\nFor this reason, I believe that Matplotlib itself will remain a vital piece of the data visualization stack, even if new tools mean the community gradually moves away from using the Matplotlib API directly.\n:::\n\n#### General Matplotlib Tips\n\nBefore we dive into the details of creating visualizations with Matplotlib, there are a few useful things you should know about using the package.\n\n1. Importing the `matplotlib` module\n\nJust as we use the `np` shorthand for NumPy and the `pd` shorthand for Pandas, we will use some standard shorthands for Matplotlib imports:\n\n```{.python}\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-whitegrid')\n%matplotlib inline\n```\n:::{.callout-note}\nThe ``plt`` interface is what we will use most often, as we shall see throughout this chapter.\n:::\n\n#### Setting Styles\n\nWe will use the ``plt.style`` directive to choose appropriate aesthetic styles for our figures.\nHere we will set the ``classic`` style, which ensures that the plots we create use the classic Matplotlib style:\n\n```python\nplt.style.use('classic')\nplt.style.use('default')\nplt.style.use('seaborn')\n```\nThroughout this section, we will adjust this style as needed.\nNote that the stylesheets used here are supported as of Matplotlib version 1.5; if you are using an earlier version of Matplotlib, only the default style is available.\n\nA simple example of loading the matplotlib module and setting theme is shown below.\n\n::: {.cell execution_count=101}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nplt.style.use('classic')\n```\n:::\n\n\n### How to Display Your Plots?\n\nA visualization you can't see won't be of much use, but just how you view your Matplotlib plots depends on the context.\nThe best use of Matplotlib differs depending on how you are using it; roughly, the three applicable contexts are using Matplotlib in a script, in an IPython terminal, or in a Jupyter notebook.\n\n\n### Plotting from a Jupyter Notebook\n\nThe Jupyter notebook is a browser-based interactive data analysis tool that can combine narrative, code, graphics, HTML elements, and much more into a single executable document.\n\nIf you are using Matplotlib from within a script, the function `plt.show` is your friend.\n`plt.show` starts an event loop, looks for all currently active `Figure` objects, and opens one or more interactive windows that display your figure or figures. \n\nThe `plt.show` command does a lot under the hood, as it must interact with your system's interactive graphical backend.\nThe details of this operation can vary greatly from system to system and even installation to installation, but Matplotlib does its best to hide all these details from you.\n\nOne thing to be aware of: the `plt.show` command should be used *only once* per Python session, and is most often seen at the very end of the script.\nMultiple `show` commands can lead to unpredictable backend-dependent behavior, and should mostly be avoided.\n\n:::{.callout-note}\nUsing `plt.show` in IPython's Matplotlib mode is not required.\n:::\n\nPlotting interactively within a Jupyter notebook can be done with the `%matplotlib` command, and works in a similar way to the IPython shell.\nYou also have the option of embedding graphics directly in the notebook, with two possible options:\n\n- `%matplotlib inline` will lead to *static* images of your plot embedded in the notebook.\n- `%matplotlib notebook` will lead to *interactive* plots embedded within the notebook.\n\nFor this discussion, we will generally stick with the default, with figures rendered as static images (see the following figure for the result of this basic plotting example):\n\n::: {.cell execution_count=102}\n``` {.python .cell-code}\n%matplotlib inline\n```\n:::\n\n\n::: {.cell execution_count=103}\n``` {.python .cell-code}\nplt.plot([1,2,3,4])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-104-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n#### Adding titles, axis labels, and a legend\nLet's redraw this plot but now with a title, axis labels, and a legend:\n\n::: {.cell execution_count=104}\n``` {.python .cell-code}\nx_vals = [1,2,3,4]\nplt.plot(x_vals, label=\"An awesome line\")\nplt.ylabel('The y-axis label!')\nplt.xlabel('The x-axis label!')\nplt.title(\"The title of the graph!\")\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-105-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n#### Adding both x and y data\n\nYou may be wondering why the x-axis ranges from 0-3 and the y-axis from 1-4. If you provide a single list or array to the [plot()](https://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot) command, matplotlib assumes it is a sequence of y values, and automatically generates the x values for you.\n\n[plot()](https://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot) is a versatile command, and will take an arbitrary number of arguments. For example, to plot x versus y, you can issue the command:\n\n::: {.cell execution_count=105}\n``` {.python .cell-code}\nx_vals = [1,2,3,4]\ny_vals = [1, 4, 9, 16]\nplt.plot(x_vals, y_vals)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-106-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n More explicit examples are shown below.\n\n::: {.cell execution_count=106}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Compute the x and y coordinates for points on a sine curve\nx = np.arange(0, 3 * np.pi, 0.1)\ny = np.sin(x)\n\n# Plot the points using matplotlib\nplt.plot(x, y)\nplt.show()  # You must call plt.show() to make graphics appear.\n```\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-107-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::: {.cell execution_count=107}\n``` {.python .cell-code}\nimport numpy as np\nx = np.linspace(0, 10, 100)\n\nfig = plt.figure()\nplt.plot(x, np.sin(x), '-')\nplt.plot(x, np.cos(x), '--');\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-108-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nNow let's change the theme to `seaborn` and create more plots with additional features.\n\n::: {.cell execution_count=108}\n``` {.python .cell-code}\nplt.style.use('seaborn-v0_8')\n```\n:::\n\n\n::: {.cell execution_count=109}\n``` {.python .cell-code}\nimport numpy as np\nfig=plt.figure()\nx = np.linspace(0, 10, 100)\nplt.plot(x, np.sin(x), 'r-', label=r'$\\sin(x)$') # r stands for colour and r in label stands for row text\nplt.plot(x, np.cos(x), 'c--', label=r'$\\cos(x)$')\nplt.title(r'Plots of $\\sin(x)$ and $\\cos(x)$' )\nplt.axis('tight')\nplt.legend(frameon=True, loc='upper right', ncol=1,framealpha=.7)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-110-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::{.callout-note}\n### Saving Figures to File\n\nOne nice feature of Matplotlib is the ability to save figures in a wide variety of formats.\nSaving a figure can be done using the ``savefig()`` command.\nIn ``savefig()``, the file format is inferred from the extension of the given filename.\nDepending on what backends you have installed, many different file formats are available.\nThe list of supported file types can be found for your system by using the following method of the figure canvas object. Following function return all supported formats.\n\n::: {.cell execution_count=110}\n``` {.python .cell-code}\nfig.canvas.get_supported_filetypes()\n```\n\n::: {.cell-output .cell-output-display execution_count=110}\n```\n{'eps': 'Encapsulated Postscript',\n 'jpg': 'Joint Photographic Experts Group',\n 'jpeg': 'Joint Photographic Experts Group',\n 'pdf': 'Portable Document Format',\n 'pgf': 'PGF code for LaTeX',\n 'png': 'Portable Network Graphics',\n 'ps': 'Postscript',\n 'raw': 'Raw RGBA bitmap',\n 'rgba': 'Raw RGBA bitmap',\n 'svg': 'Scalable Vector Graphics',\n 'svgz': 'Scalable Vector Graphics',\n 'tif': 'Tagged Image File Format',\n 'tiff': 'Tagged Image File Format',\n 'webp': 'WebP Image Format'}\n```\n:::\n:::\n\n\nNote that when saving your figure, it's not necessary to use ``plt.show()`` or related commands discussed earlier.\n:::\n\nFor example, to save the previous figure as a PNG file, you can run this:\n\n::: {.cell execution_count=111}\n``` {.python .cell-code}\nfig.savefig('my_figure.png')\n```\n:::\n\n\nTo confirm that it contains what we think it contains, let's use the IPython ``Image`` object to display the contents of this file:\n\n::: {.cell execution_count=112}\n``` {.python .cell-code}\nfrom IPython.display import Image\nImage('my_figure.png')\n```\n\n::: {.cell-output .cell-output-display execution_count=112}\n![](module_3_files/figure-pdf/cell-113-output-1.png){fig-pos='H'}\n:::\n:::\n\n\n#### MATLAB-style Interface\n\nMatplotlib was originally written as a Python alternative for MATLAB users, and much of its syntax reflects that fact.\nThe MATLAB-style tools are contained in the pyplot (``plt``) interface.\nFor example, the following code will probably look quite familiar to MATLAB users:\n\n#### Plotting multiple charts\n\nYou can create multiple plots within the same figure by using [`subplot`](https://matplotlib.org/gallery/subplots_axes_and_figures/subplot.html)\n\nLet's consider an example of two plots on same canvas.\n\n::: {.cell execution_count=113}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Create some fake data.\nx1 = np.linspace(0.0, 5.0)\ny1 = np.cos(2 * np.pi * x1) * np.exp(-x1)\nx2 = np.linspace(0.0, 2.0)\ny2 = np.cos(2 * np.pi * x2)\nplt.plot(x1,y1,label=\"first graph\")\nplt.plot(x2,y2,label=\"second graph\")\nplt.axis('tight')\nplt.legend(frameon=True, loc='upper right', ncol=1,framealpha=.7)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-114-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nNow let's represent these two plots in seperate subplots as shown below.\n\n::: {.cell execution_count=114}\n``` {.python .cell-code}\nfig, (ax1, ax2) = plt.subplots(2, 1)\nfig.suptitle('A tale of 2 subplots')\n\nax1.plot(x1, y1, 'o-')\nax1.set_ylabel('Damped oscillation')\n\nax2.plot(x2, y2, '.-')\nax2.set_xlabel('time (s)')\nax2.set_ylabel('Undamped')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-115-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nAnother approach is shown below.\n\n::: {.cell execution_count=115}\n``` {.python .cell-code}\nplt.subplot(2, 1, 1)\nplt.plot(x1, y1, 'o-')\nplt.title('A tale of 2 subplots')\nplt.ylabel('Damped oscillation')\n\nplt.subplot(2, 1, 2)\nplt.plot(x2, y2, '.-')\nplt.xlabel('time (s)')\nplt.ylabel('Undamped')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-116-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nAnother example is shown below.\n\n::: {.cell execution_count=116}\n``` {.python .cell-code}\n# First create a grid of plots\n# ax will be an array of two Axes objects\nplt.style.use('default')\nfig, ax = plt.subplots(2)\n\n# Call plot() method on the appropriate object\nax[0].plot(x, np.sin(x),'r--',label=r'$\\sin x$')\nax[0].set_title(r'$\\sin $ graph')\nax[1].set_xlabel(\"x values\")\nax[0].set_ylabel(r'$y=\\sin x$')\nax[1].plot(x, np.cos(x),'g-',label=r'$\\cos x$')\nax[1].set_ylabel(r'$y=\\cos x$')\nplt.axis('tight')\nplt.legend(frameon=True, loc='upper right', ncol=1,framealpha=.7)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-117-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n#### Simple Scatter Plots\n\nAnother commonly used plot type is the simple scatter plot, a close cousin of the line plot. Instead of points being joined by line segments, here the points are represented individually with a dot, circle, or other shape. We’ll start by setting up the notebook for plotting and importing the functions we will use:\n\n::: {.cell execution_count=117}\n``` {.python .cell-code}\nimport numpy as np\nx = np.linspace(0, 10, 100)\nfig = plt.figure()\nplt.plot(x, np.sin(x), '-o', label=r'$\\sin(x)$',)\nplt.plot(x, np.cos(x), 'p', label=r'$\\cos(x)$')\nplt.title('Plots of $\\sin(x)$ and $\\cos(x)$' )\nplt.axis('tight')\nplt.legend(frameon=True, loc='upper right', ncol=1,framealpha=.7)\nplt.show()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n<>:6: SyntaxWarning: invalid escape sequence '\\s'\n<>:6: SyntaxWarning: invalid escape sequence '\\s'\nC:\\Users\\SIJUKSWAMY\\AppData\\Local\\Temp\\ipykernel_16376\\3327894231.py:6: SyntaxWarning: invalid escape sequence '\\s'\n  plt.title('Plots of $\\sin(x)$ and $\\cos(x)$' )\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-118-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n#### Scatter Plots with plt.scatter\n\nA second, more powerful method of creating scatter plots is the plt.scatter function, which can be used very similarly to the `plt.plot` function:\n\n:::{.callout-note}\nThe primary difference of `plt.scatter` from `plt.plot` is that it can be used to create scatter plots where the properties of each individual point (size, face color, edge color, etc.) can be individually controlled or mapped to data.\n:::\n\nLet's show this by creating a random scatter plot with points of many colors and sizes. In order to better see the overlapping results, we'll also use the alpha keyword to adjust the transparency level:\n\n::: {.cell execution_count=118}\n``` {.python .cell-code}\nrng = np.random.RandomState(42)\nx = rng.randn(100)\ny = rng.randn(100)\ncolors = rng.rand(100)\nsizes = 1000 * rng.rand(100)\n\nplt.scatter(x, y, c=colors, s=sizes, alpha=0.3,\n            cmap='viridis',label=\" Random Y values\")\nplt.xlabel('Random x values')\nplt.ylabel('Random y values')\nplt.title('Bubble plot' )\nplt.colorbar();  # show color scale\n```\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-119-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n### Histograms, Binnings, and Density\n\nA simple histogram can be a great first step in understanding a dataset.\n\n::: {.cell execution_count=119}\n``` {.python .cell-code}\n%matplotlib inline\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8')\ndata = np.random.randn(1000)\nplt.hist(data)\n```\n\n::: {.cell-output .cell-output-display execution_count=119}\n```\n(array([ 14.,  43., 108., 190., 229., 202., 131.,  56.,  20.,   7.]),\n array([-2.84671827, -2.23958501, -1.63245175, -1.02531848, -0.41818522,\n         0.18894805,  0.79608131,  1.40321457,  2.01034784,  2.6174811 ,\n         3.22461436]),\n <BarContainer object of 10 artists>)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-120-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n#### Customizing Histograms\nThe `hist()` function has many options to tune both the calculation and the display; here's an example of a more customized histogram:\n\n::: {.cell execution_count=120}\n``` {.python .cell-code}\nplt.hist(data, bins=30, density=True, alpha=0.5,\n         histtype='stepfilled', color='steelblue',\n         edgecolor='none');\n```\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-121-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nThe plt.hist docstring has more information on other customization options available. This combination of histtype='stepfilled' along with some transparency alpha to be very useful when comparing histograms of several distributions:\n\n::: {.cell execution_count=121}\n``` {.python .cell-code}\nw1 = np.random.normal(0, 0.8, 1000)\nw2 = np.random.normal(-2, 1, 1000)\nw3 = np.random.normal(3, 1.2, 1000)\n\nkwargs = dict(histtype='stepfilled', alpha=0.3, density=True, bins=40)\n\nplt.hist(w1, **kwargs,label='w1')\nplt.hist(w2, **kwargs,label='w2')\nplt.hist(w3, **kwargs,label='w3')\nplt.legend()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-122-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n###  Working with datafiles\n\nConsider the pokemon dataset for this job. The main featurs of this dataset are:\n\n**Defense**: This column represents the base damage resistance against normal attacks. Higher values indicate that the Pokémon can withstand more physical damage.\n\n**Sp. Atk (Special Attack)**: This column shows the base modifier for special attacks. Pokémon with higher Special Attack values can deal more damage with special moves.\n\n**Sp. Def (Special Defense)**: This column indicates the base damage resistance against special attacks. Higher values mean the Pokémon can better resist damage from special moves.\n\n**Speed**: This column determines which Pokémon attacks first in each round. Pokémon with higher Speed values will generally attack before those with lower values.\n\n**Stage**: This column represents the evolutionary stage of the Pokémon. It typically ranges from 1 to 3, with 1 being the base form and 3 being the final evolved form. Some Pokémon may have additional stages, such as Mega Evolutions or Gigantamax forms.\n\n**Legendary**: This is a boolean column that identifies whether the Pokémon is legendary. It is marked as `True` for legendary Pokémon and `False` for non-legendary ones.\n\nThese columns provide valuable insights into the strengths and characteristics of each Pokémon, helping players strategize and build their teams effectively. 🌟\n\nNow, let’s read our data into a `Pandas` dataframe. We will relax the limit on display columns and rows using the `set_option()` method in Pandas:\n\n::: {.cell execution_count=122}\n``` {.python .cell-code}\nimport pandas as pd\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)\n```\n:::\n\n\n::: {.cell execution_count=123}\n``` {.python .cell-code}\ndf=pd.read_csv(\"https://raw.githubusercontent.com/sijuswamy/PyWorks/main/Pokemon.csv\",encoding = 'utf_8')\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=123}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Type 1</th>\n      <th>Type 2</th>\n      <th>Total</th>\n      <th>HP</th>\n      <th>Attack</th>\n      <th>Defense</th>\n      <th>Sp.Atk</th>\n      <th>Sp.Def</th>\n      <th>Speed</th>\n      <th>Stage</th>\n      <th>Legendary</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Bulbasaur</td>\n      <td>Grass</td>\n      <td>Poison</td>\n      <td>318</td>\n      <td>45</td>\n      <td>49</td>\n      <td>49</td>\n      <td>65</td>\n      <td>65</td>\n      <td>45</td>\n      <td>1</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Ivysaur</td>\n      <td>Grass</td>\n      <td>Poison</td>\n      <td>405</td>\n      <td>60</td>\n      <td>62</td>\n      <td>63</td>\n      <td>80</td>\n      <td>80</td>\n      <td>60</td>\n      <td>2</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Venusaur</td>\n      <td>Grass</td>\n      <td>Poison</td>\n      <td>525</td>\n      <td>80</td>\n      <td>82</td>\n      <td>83</td>\n      <td>100</td>\n      <td>100</td>\n      <td>80</td>\n      <td>3</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Charmander</td>\n      <td>Fire</td>\n      <td>Poison</td>\n      <td>309</td>\n      <td>39</td>\n      <td>52</td>\n      <td>43</td>\n      <td>60</td>\n      <td>50</td>\n      <td>65</td>\n      <td>1</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Charmeleon</td>\n      <td>Fire</td>\n      <td>NaN</td>\n      <td>405</td>\n      <td>58</td>\n      <td>64</td>\n      <td>58</td>\n      <td>80</td>\n      <td>65</td>\n      <td>80</td>\n      <td>2</td>\n      <td>False</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nSince the `Legendary` feature contains the string `True` and `False`. But they are part of the logical data type in python. So let's replace these values with `TRUE` and `FALSE` strings as follows.\n\n::: {.cell execution_count=124}\n``` {.python .cell-code}\nbooleanDictionary = {True: 'TRUE', False: 'FALSE'}\ndf = df.replace(booleanDictionary)\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=124}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Type 1</th>\n      <th>Type 2</th>\n      <th>Total</th>\n      <th>HP</th>\n      <th>Attack</th>\n      <th>Defense</th>\n      <th>Sp.Atk</th>\n      <th>Sp.Def</th>\n      <th>Speed</th>\n      <th>Stage</th>\n      <th>Legendary</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Bulbasaur</td>\n      <td>Grass</td>\n      <td>Poison</td>\n      <td>318</td>\n      <td>45</td>\n      <td>49</td>\n      <td>49</td>\n      <td>65</td>\n      <td>65</td>\n      <td>45</td>\n      <td>1</td>\n      <td>FALSE</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Ivysaur</td>\n      <td>Grass</td>\n      <td>Poison</td>\n      <td>405</td>\n      <td>60</td>\n      <td>62</td>\n      <td>63</td>\n      <td>80</td>\n      <td>80</td>\n      <td>60</td>\n      <td>2</td>\n      <td>FALSE</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Venusaur</td>\n      <td>Grass</td>\n      <td>Poison</td>\n      <td>525</td>\n      <td>80</td>\n      <td>82</td>\n      <td>83</td>\n      <td>100</td>\n      <td>100</td>\n      <td>80</td>\n      <td>3</td>\n      <td>FALSE</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Charmander</td>\n      <td>Fire</td>\n      <td>Poison</td>\n      <td>309</td>\n      <td>39</td>\n      <td>52</td>\n      <td>43</td>\n      <td>60</td>\n      <td>50</td>\n      <td>65</td>\n      <td>1</td>\n      <td>FALSE</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Charmeleon</td>\n      <td>Fire</td>\n      <td>NaN</td>\n      <td>405</td>\n      <td>58</td>\n      <td>64</td>\n      <td>58</td>\n      <td>80</td>\n      <td>65</td>\n      <td>80</td>\n      <td>2</td>\n      <td>FALSE</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n**Creating a histogram**\n\nWe can generate a histogram for any of the numerical columns by calling the `hist()` method on the plt object and passing in the selected column in the data frame. Let’s do this for the speed column, which corresponds to speed of the player.\n\n::: {.cell execution_count=125}\n``` {.python .cell-code}\nplt.hist(df['Speed'])\nplt.xlabel('Speed in minutes')\nplt.ylabel('Frequency')\nplt.title('Histogram of player speed')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-126-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n**Scatterplot of Attack vs HP**\n\nTo generate a scatter plot in `Matplotlib`, we simply use the `scatter()` method on the `plt` object. Let’s also label the axes and give our plot a title:\n\n::: {.cell execution_count=126}\n``` {.python .cell-code}\nplt.scatter(df['Attack'], df['HP'])\nplt.title('Attack vs. HP')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_3_files/figure-pdf/cell-127-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n**Barchart**\n\nBar charts are another useful visualization tool for analyzing categories in data. To visualize categorical columns, we first should count the values. We can use the counter method from the collections modules to generate a dictionary of count values for each category in a categorical column. Let’s do this for the Legendary column.\n\n::: {.cell execution_count=127}\n``` {.python .cell-code}\nfrom collections import Counter \n\nprint(Counter(df[('Legendary')]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCounter({'FALSE': 147, 'TRUE': 4})\n```\n:::\n:::\n\n\n:::{.callout-tip}\n We can filter this dictionary using the `most_common` method. Let’s look at the 10 most common nationality values ( you can also use the `least_common` method to analyze infrequent nationality values)\n:::\n\n Legendary_dict = dict(Counter(df[('Legendary')]).most_common(2))\n\nplt.bar(Legendary_dict.keys(), Legendary_dict.values())\n\nplt.xlabel('Legendary')\n\nplt.ylabel('Frequency')\n\nplt.title('Bar Plot of Ten Most Common Legendary')\n#plt.xticks(rotation=90)\nplt.show()\n```\n\n\n\n\n\n\n\n\n**Generating Pie Charts With `Matplotlib`**\n\nPie charts are a useful way to visualize proportions in your data. So first wee need to create the dictionary of propotion then feed it to the pie chart.\n\n\n\n\n\n\n\n\n```{python}\nprop = dict(Counter(df['Legendary']))\n\nfor key, values in prop.items():\n\n    prop[key] = (values)/len(df)*100\n\nprint(prop)\n```\n\n```{python}\nfig1, ax1 = plt.subplots()\n\nax1.pie(prop.values(), labels=prop.keys(), autopct='%1.1f%%',\n\n        shadow=True, startangle=0)\n\nax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.\n\nplt.show()\n```\n\n\n\n\n\n\n\n\n**Box plots**\n Box plots are helpful in visualizing the statistical summaries. The following code demonstrate the way of creating the box plot.\n\n\n\n\n\n\n\n\n ```{python}\n plt.title(\"Five point summary of Speed\")\nplt.boxplot(df['Speed'],patch_artist=True, notch=True,labels=['Speed'])\nplt.show()\n```\n\n\n\n\n\n\n\n\n### Data Visualization With Seaborn\n\n`Seaborn` is a library built on top of `Matplotlib` that enables more sophisticated visualization and aesthetic plot formatting. Once you’ve mastered Matplotlib, you may want to move up to Seaborn for more complex visualizations.\n\nFor example, simply using the `Seaborn` `set()` method can dramatically improve the appearance of your `Matplotlib` plots. Let’s take a look.\n\nFirst, `import Seaborn as sns` and reformat all of the figures we generated. At the top of your script, write the following code and rerun:\n\n\n\n\n\n\n\n\n```{python}\nimport seaborn as sns\nsns.set()\nplt.show()\n```\n\n\n\n\n\n\n\n\n### Histograms With Seaborn\n\nTo regenerate our histogram of the overall column, we use the `histplot` method on the Seaborn object:\n\n\n\n\n\n\n\n\n```{python}\nsns.histplot(df['Speed'],kde=True)\nplt.xlabel('Speed in minutes')\nplt.ylabel('Frequency')\nplt.title('Histogram of player speed')\nplt.show()\n```\n\n\n\n\n\n\n\n\nNow let's modify the histogtram by including the feature Legendary.\n\n\n\n\n\n\n\n\n```{python}\nsns.histplot(x='Speed',hue='Legendary',kde=True,data=df)\nplt.xlabel('Speed in minutes')\nplt.ylabel('Frequency')\nplt.title('Histogram of player speed')\nplt.show()\n```\n\n\n\n\n\n\n\n\n### Scatter Plots With Seaborn\nSeaborn also makes generating scatter plots straightforward. Let’s recreate the scatter plot from earlier:\n\n\n\n\n\n\n\n\n```{python}\nsns.scatterplot(x='Attack', y='HP',hue='Legendary',data=df)\nplt.title('Attack vs. HP')\nplt.show()\n```\n\n\n\n\n\n\n\n\nIn the similar way, let’s compare the Attack and Defense stats for our Pokémon over Stages\n\n\n\n\n\n\n\n\n```{python}\n# Plot using Seaborn\nsns.lmplot(x='Attack', y='Defense', data=df,\n           fit_reg=False, legend=False,\n           hue='Stage')\n \n# Tweak using Matplotlib\nplt.ylim(0, 200)\nplt.xlim(0, 160)\nplt.legend(loc='upper right')\nplt.show()\n```\n\n\n\n\n\n\n\n\nNow let's witness the power of seaboran in creating boxplots of all numerical features in single line of code!\n\n\n\n\n\n\n\n\n```{python}\n# Boxplot\nplt.figure(figsize=(8,6)) # Set plot dimensions\nsns.boxplot(data=df)\nplt.show()\n```\n\n",
    "supporting": [
      "module_3_files\\figure-pdf"
    ],
    "filters": []
  }
}