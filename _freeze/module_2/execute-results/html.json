{
  "hash": "c69c4008e6086dba3960619081e4fa21",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Transforming Linear Algebra to Computational Language\"\nexecute: \n  enabled: true\n---\n\n## Introduction \n\nIn the first module, we established a solid foundation in matrix algebra by exploring pseudocode and implementing fundamental matrix operations using Python. We practiced key concepts such as matrix addition, subtraction, multiplication, and determinants through practical examples in image processing, leveraging the `SymPy` library for symbolic computation. \n\nAs we begin the second module, **\"Transforming Linear Algebra to Computational Language,\"** our focus will shift towards applying these concepts with greater depth and actionable insight. This module is designed to bridge the theoretical knowledge from matrix algebra with practical computational applications. You will learn to interpret and utilize matrix operations, solve systems of equations, and analyze the rank of matrices within a variety of real-world contexts. \n\nA new concept we will introduce is the **Rank-Nullity Theorem**, which provides a fundamental relationship between the rank of a matrix and the dimensions of its null space. This theorem is crucial for understanding the solution spaces of linear systems and the properties of linear transformations. By applying this theorem, you will be able to gain deeper insights into the structure of solutions and the behavior of matrix transformations.\n\nThis transition will not only reinforce your understanding of linear algebra but also enhance your ability to apply these concepts effectively in computational settings. Through engaging examples and practical exercises, you will gain valuable experience in transforming abstract mathematical principles into tangible solutions, setting a strong groundwork for advanced computational techniques.\n\n## Relearning of Terms and Operations in Linear Algebra\n\nIn this section, we will revisit fundamental matrix operations such as addition, subtraction, scaling, and more through practical examples. Our goal is to transform theoretical linear algebra into modern computational applications. We will demonstrate these concepts using Python, focusing on practical and industrial applications.\n\n### Matrix Addition and Subtraction in Data Analysis\n\nMatrix addition and subtraction are fundamental operations that help in combining datasets and analyzing differences. \n\n**Simple Example: Combining Quarterly Sales Data**\n\nWe begin with quarterly sales data from different regions and combine them to get the total sales.\n\n**Tabular Data:**\n\n| Region | Q1   | Q2   | Q3   | Q4   |\n|--------|------|------|------|------|\n| A      | 2500 | 2800 | 3100 | 2900 |\n| B      | 1500 | 1600 | 1700 | 1800 |\n\n**From Scratch Python Implementation:**\n\n::: {#e456027f .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Quarterly sales data\nsales_region_a = np.array([2500, 2800, 3100, 2900])\nsales_region_b = np.array([1500, 1600, 1700, 1800])\n\n# Combine sales data\ntotal_sales = sales_region_a + sales_region_b\n\n# Visualization\nquarters = ['Q1', 'Q2', 'Q3', 'Q4']\nplt.bar(quarters, total_sales, color='skyblue')\nplt.xlabel('Quarter')\nplt.ylabel('Total Sales')\nplt.title('Combined Quarterly Sales Data for Regions A and B')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_2_files/figure-html/cell-2-output-1.png){width=601 height=449}\n:::\n:::\n\n\nUsing `pandas` to handle tabular data:\n\n::: {#c921bf3c .cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# DataFrames for quarterly sales data\ndf_a = pd.DataFrame({'Q1': [2500], 'Q2': [2800], 'Q3': [3100], 'Q4': [2900]}, index=['Region A'])\ndf_b = pd.DataFrame({'Q1': [1500], 'Q2': [1600], 'Q3': [1700], 'Q4': [1800]}, index=['Region B'])\n\n# Combine data\ndf_total = df_a.add(df_b)\n\n# Visualization\ndf_total.T.plot(kind='bar', color='skyblue')\nplt.xlabel('Quarter')\nplt.ylabel('Total Sales')\nplt.title('Combined Quarterly Sales Data for Regions A and B')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_2_files/figure-html/cell-3-output-1.png){width=608 height=455}\n:::\n:::\n\n\nWe can extend the this in to more advanced examples. Irrespective to the size of the data, for representation aggregation tasks matrix models are best options and are used in industry as a standard. Let us consider an advanced example to analyse difference in stock prices. For this example we are using a simulated data. The python code for this simulation process is shown below: \n\n::: {#ca9c87ee .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Simulated observed and predicted stock prices\nobserved_prices = np.random.uniform(100, 200, size=(100, 5))\npredicted_prices = np.random.uniform(95, 210, size=(100, 5))\n\n# Calculate the difference matrix\nprice_differences = observed_prices - predicted_prices\n\n# Visualization\nplt.imshow(price_differences, cmap='coolwarm', aspect='auto')\nplt.colorbar()\nplt.title('Stock Price Differences')\nplt.xlabel('Stock Index')\nplt.ylabel('Day Index')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_2_files/figure-html/cell-4-output-1.png){width=571 height=449}\n:::\n:::\n\n\nAnother important matrix operation relevant to data analytics and Machine Learning application is scaling. This is considered as a statistical tool to make various features (attributes) in to same scale so as to avoid unnecessary misleading impact in data analysis and its intepretation. In Machine Learning context, this pre-processing stage is inevitable so as to make the model relevant and usable. \n\n**Simple Example: Normalizing Employee Performance Data**\n\n**Tabular Data:**\n\n| Employee | Metric A   | Metric B   | \n|--------|--------------|------------|\n| X      | 80           | 700        | \n| Y      | 90           | 800        | \n| Z      |100           |900         |\n| A      |110           |1000        |\n| B      |120           |1100        |\n\nUsing simple python code we can simulate the model for `min-max` scaling.\n\n::: {#e519e730 .cell execution_count=4}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Employee performance data with varying scales\ndata = np.array([[80, 700], [90, 800], [100, 900], [110, 1000], [120, 1100]])\n\n# Manual scaling\nmin_vals = np.min(data, axis=0)\nmax_vals = np.max(data, axis=0)\nscaled_data = (data - min_vals) / (max_vals - min_vals)\n\n# Visualization\nplt.figure(figsize=(10, 5))\nplt.subplot(1, 2, 1)\nplt.imshow(data, cmap='viridis')\nplt.title('Original Data')\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.imshow(scaled_data, cmap='viridis')\nplt.title('Scaled Data')\nplt.colorbar()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_2_files/figure-html/cell-5-output-1.png){width=657 height=431}\n:::\n:::\n\n\n This method will confine the feature values (attributes) into the range $[0,1]$. So in effect all the features are scaled proportionally to the data spectrum.\n\nSimilarly we can use the standard scaling (transformation to normal distribution) using the transformation $\\dfrac{x-\\bar{x}}{n}$. The python code for this operation is given below:\n\n::: {#d92cdf26 .cell execution_count=5}\n``` {.python .cell-code}\n# Standard scaling from scratch\ndef standard_scaling(data):\n    mean = np.mean(data, axis=0)\n    std = np.std(data, axis=0)\n    scaled_data = (data - mean) / std\n    return scaled_data\n\n# Apply standard scaling\nscaled_data_scratch = standard_scaling(data)\n\nprint(\"Standard Scaled Data (from scratch):\\n\", scaled_data_scratch)\n\n# Visualization\nplt.figure(figsize=(10, 5))\nplt.subplot(1, 2, 1)\nplt.imshow(data, cmap='viridis')\nplt.title('Original Data')\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.imshow(scaled_data_scratch, cmap='viridis')\nplt.title('Scaled Data')\nplt.colorbar()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStandard Scaled Data (from scratch):\n [[-1.41421356 -1.41421356]\n [-0.70710678 -0.70710678]\n [ 0.          0.        ]\n [ 0.70710678  0.70710678]\n [ 1.41421356  1.41421356]]\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](module_2_files/figure-html/cell-6-output-2.png){width=668 height=431}\n:::\n:::\n\n\nHere we will use one more type of visualization to demonstrate the distribution of data.\n\n::: {#b344fff3 .cell execution_count=6}\n``` {.python .cell-code}\nimport seaborn as sns\n# Create plots\nplt.figure(figsize=(14, 7))\n\n# Plot for original data\nplt.subplot(1, 2, 1)\nsns.histplot(data, kde=True, bins=10, palette=\"viridis\")\nplt.title('Original Data Distribution')\nplt.xlabel('Value')\nplt.ylabel('Frequency')\n\n# Plot for standard scaled data\nplt.subplot(1, 2, 2)\nsns.histplot(scaled_data_scratch, kde=True, bins=10, palette=\"viridis\")\nplt.title('Standard Scaled Data Distribution')\nplt.xlabel('Value')\nplt.ylabel('Frequency')\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_2_files/figure-html/cell-7-output-1.png){width=1332 height=662}\n:::\n:::\n\n\nA scatter plot showing the impact of scaling is shown below.\n\n::: {#3af402e6 .cell execution_count=7}\n``` {.python .cell-code}\n# Plot original and scaled data\nplt.figure(figsize=(14, 7))\n\n# Original Data\nplt.subplot(1, 3, 1)\nplt.scatter(data[:, 0], data[:, 1], color='blue')\nplt.title('Original Data')\nplt.xlabel('Metric A')\nplt.ylabel('Metric B')\n\n# Standard Scaled Data\nplt.subplot(1, 3, 2)\nplt.scatter(scaled_data_scratch[:, 0], scaled_data_scratch[:, 1], color='green')\nplt.title('Standard Scaled Data')\nplt.xlabel('Metric A (Standard Scaled)')\nplt.ylabel('Metric B (Standard Scaled)')\n\n# Min-Max Scaled Data\nplt.subplot(1, 3, 3)\nplt.scatter(scaled_data[:, 0], scaled_data[:, 1], color='red')\nplt.title('Min-Max Scaled Data')\nplt.xlabel('Metric A (Min-Max Scaled)')\nplt.ylabel('Metric B (Min-Max Scaled)')\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_2_files/figure-html/cell-8-output-1.png){width=1334 height=662}\n:::\n:::\n\n\nWe can use the `scikit-learn` library for do the same thing in a very simple handy approach. The `python` code for this job is shown below.\n\n::: {#0311d86a .cell execution_count=8}\n``` {.python .cell-code}\nfrom sklearn.preprocessing import MinMaxScaler\n\n# Min-max scaling using sklearn\nscaler = MinMaxScaler()\nmin_max_scaled_data_sklearn = scaler.fit_transform(data)\n\nprint(\"Min-Max Scaled Data (using sklearn):\\n\", min_max_scaled_data_sklearn)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMin-Max Scaled Data (using sklearn):\n [[0.   0.  ]\n [0.25 0.25]\n [0.5  0.5 ]\n [0.75 0.75]\n [1.   1.  ]]\n```\n:::\n:::\n\n\n::: {#8eb42547 .cell execution_count=9}\n``` {.python .cell-code}\nfrom sklearn.preprocessing import StandardScaler\n\n# Standard scaling using sklearn\nscaler = StandardScaler()\nscaled_data_sklearn = scaler.fit_transform(data)\n\nprint(\"Standard Scaled Data (using sklearn):\\n\", scaled_data_sklearn)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStandard Scaled Data (using sklearn):\n [[-1.41421356 -1.41421356]\n [-0.70710678 -0.70710678]\n [ 0.          0.        ]\n [ 0.70710678  0.70710678]\n [ 1.41421356  1.41421356]]\n```\n:::\n:::\n\n\nA scatter plot showing the impact on scaling is shown bellow.\n\n::: {#4dc322ec .cell execution_count=10}\n``` {.python .cell-code}\n# Plot original and scaled data\nplt.figure(figsize=(14, 7))\n\n# Original Data\nplt.subplot(1, 3, 1)\nplt.scatter(data[:, 0], data[:, 1], color='blue')\nplt.title('Original Data')\nplt.xlabel('Metric A')\nplt.ylabel('Metric B')\n\n# Standard Scaled Data\nplt.subplot(1, 3, 2)\nplt.scatter(scaled_data_sklearn[:, 0], scaled_data_sklearn[:, 1], color='green')\nplt.title('Standard Scaled Data')\nplt.xlabel('Metric A (Standard Scaled)')\nplt.ylabel('Metric B (Standard Scaled)')\n\n# Min-Max Scaled Data\nplt.subplot(1, 3, 3)\nplt.scatter(min_max_scaled_data_sklearn[:, 0], min_max_scaled_data_sklearn[:, 1], color='red')\nplt.title('Min-Max Scaled Data')\nplt.xlabel('Metric A (Min-Max Scaled)')\nplt.ylabel('Metric B (Min-Max Scaled)')\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_2_files/figure-html/cell-11-output-1.png){width=1334 height=662}\n:::\n:::\n\n\n### More on Matrix Product and its Applications\n\nIn the first module of our course, we introduced matrix products as scalar projections, focusing on how matrices interact through basic operations. In this section, we will expand on this by exploring different types of matrix products that have practical importance in various fields. One such product is the *Hadamard product*, which is particularly useful in applications ranging from image processing to neural networks and statistical analysis. We will cover the definition, properties, and examples of the Hadamard product, and then delve into practical applications with simulated data.\n\n#### Hadamard Product\n\nThe Hadamard product (or element-wise product) of two matrices is a binary operation that combines two matrices of the same dimensions to produce another matrix of the same dimensions, where each element is the product of corresponding elements in the original matrices.\n\n:::{.callout-important}\n### Definition (Hadamard Product):\nFor two matrices $A$ and $B$ of the same dimension $m \\times n$, the Hadamard product $A \\circ B$ is defined as:\n\n$$(A \\circ B)_{ij} = A_{ij} \\cdot B_{ij}$$\n\nwhere $\\cdot$ denotes element-wise multiplication.\n:::\n\n::: {.callout-note}\n### Properties of Hadamard Product\n\n1.  **Commutativity**: \n  $$A \\circ B = B \\circ A$$\n  \n2.  **Associativity**: \n  $$(A \\circ B) \\circ C = A \\circ (B \\circ C)$$\n  \n3.  **Distributivity**: \n  $$A \\circ (B + C) = (A \\circ B) + (A \\circ C)$$\n:::\n\nSome simple examples to demonstrate the Hadamard product is given below.\n\nExample 1: Basic Hadamard Product\n\nGiven matrices:\n\n$$A = \\begin{pmatrix}\n1 & 2 \\\\\n3 & 4\n\\end{pmatrix}, \\quad\nB = \\begin{pmatrix}\n5 & 6 \\\\\n7 & 8\n\\end{pmatrix}$$\n\nThe Hadamard product $A \\circ B$ is:\n$$A \\circ B = \\begin{pmatrix}\n1 \\cdot 5 & 2 \\cdot 6 \\\\\n3 \\cdot 7 & 4 \\cdot 8\n\\end{pmatrix} = \\begin{pmatrix}\n5 & 12 \\\\\n21 & 32\n\\end{pmatrix}$$\n\nExample 2: Hadamard Product with Larger Matrices\n\nGiven matrices:\n\n$$A = \\begin{pmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{pmatrix}, \\quad\nB = \\begin{pmatrix}\n9 & 8 & 7 \\\\\n6 & 5 & 4 \\\\\n3 & 2 & 1\n\\end{pmatrix}$$\n\nThe Hadamard product $A \\circ B$ is:\n\n$$A \\circ B = \\begin{pmatrix}\n1 \\cdot 9 & 2 \\cdot 8 & 3 \\cdot 7 \\\\\n4 \\cdot 6 & 5 \\cdot 5 & 6 \\cdot 4 \\\\\n7 \\cdot 3 & 8 \\cdot 2 & 9 \\cdot 1\n\\end{pmatrix} = \\begin{pmatrix}\n9 & 16 & 21 \\\\\n24 & 25 & 24 \\\\\n21 & 16 & 9\n\\end{pmatrix}$$\n\nIn the following code chunks the computational process of Hadamard product is implemented in `Python`. Here both the from the scratch and use of external module versions are included.\n\n**1. Compute Hadamard Product from Scratch (without Libraries)**\n\nHere’s how you can compute the Hadamard product manually:\n\n::: {#bec74eae .cell execution_count=11}\n``` {.python .cell-code}\n# Define matrices A and B\nA = [[1, 2, 3], [4, 5, 6]]\nB = [[7, 8, 9], [10, 11, 12]]\n\n# Function to compute Hadamard product\ndef hadamard_product(A, B):\n    # Get the number of rows and columns\n    num_rows = len(A)\n    num_cols = len(A[0])\n    \n    # Initialize the result matrix\n    result = [[0]*num_cols for _ in range(num_rows)]\n    \n    # Compute the Hadamard product\n    for i in range(num_rows):\n        for j in range(num_cols):\n            result[i][j] = A[i][j] * B[i][j]\n    \n    return result\n\n# Compute Hadamard product\nhadamard_product_result = hadamard_product(A, B)\n\n# Display result\nprint(\"Hadamard Product (From Scratch):\")\nfor row in hadamard_product_result:\n    print(row)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHadamard Product (From Scratch):\n[7, 16, 27]\n[40, 55, 72]\n```\n:::\n:::\n\n\n**2. Compute Hadamard Product Using `SymPy`**\n\nHere’s how to compute the Hadamard product using `SymPy`:\n\n::: {#0c9720d5 .cell execution_count=12}\n``` {.python .cell-code}\nimport sympy as sp\n\n# Define matrices A and B\nA = sp.Matrix([[1, 2, 3], [4, 5, 6]])\nB = sp.Matrix([[7, 8, 9], [10, 11, 12]])\n\n# Compute Hadamard product using SymPy\nHadamard_product_sympy = A.multiply_elementwise(B)\n\n# Display result\nprint(\"Hadamard Product (Using SymPy):\")\nprint(Hadamard_product_sympy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHadamard Product (Using SymPy):\nMatrix([[7, 16, 27], [40, 55, 72]])\n```\n:::\n:::\n\n\n**Practical Applications**\n\n*Application 1: Image Masking*\n\nThe Hadamard product can be used for image masking. Here’s how you can apply a mask to an image and visualize it:\n\n::: {#5079b926 .cell execution_count=13}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Simulated large image (2D array) using NumPy\nimage = np.random.rand(100, 100)\n\n# Simulated mask (binary matrix) using NumPy\nmask = np.random.randint(0, 2, size=(100, 100))\n\n# Compute Hadamard product\nmasked_image = image * mask\n\n# Plot original image and masked image\nfig, ax = plt.subplots(1, 2, figsize=(12, 5))\nax[0].imshow(image, cmap='gray')\nax[0].set_title('Original Image')\nax[1].imshow(masked_image, cmap='gray')\nax[1].set_title('Masked Image')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](module_2_files/figure-html/cell-14-output-1.png){width=902 height=431}\n:::\n:::\n\n\nApplication 2: Element-wise Scaling in Neural Networks\n\nThe Hadamard product can be used for dropout^[A regularization techniques in Deep learning. This approach deactivate some selected neurons to control model over-fitting] in neural networks. A simple simulated example is given below.\n\n::: {#5cc5e8de .cell execution_count=14}\n``` {.python .cell-code}\n# Simulated large activations (2D array) using NumPy\nactivations = np.random.rand(100, 100)\n\n# Simulated dropout mask (binary matrix) using NumPy\ndropout_mask = np.random.randint(0, 2, size=(100, 100))\n\n# Apply dropout\ndropped_activations = activations * dropout_mask\n\n# Display results\nprint(\"Original Activations:\")\nprint(activations)\nprint(\"\\nDropout Mask:\")\nprint(dropout_mask)\nprint(\"\\nDropped Activations:\")\nprint(dropped_activations)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal Activations:\n[[0.58212524 0.87041739 0.84460613 ... 0.33305495 0.44489585 0.8684023 ]\n [0.5171853  0.29461735 0.82768228 ... 0.12264183 0.58393672 0.70770389]\n [0.99267584 0.99084305 0.06019981 ... 0.01144968 0.55258449 0.34130822]\n ...\n [0.11864754 0.0353514  0.36088127 ... 0.28917025 0.24079385 0.97901097]\n [0.90279698 0.30605417 0.17864954 ... 0.28654735 0.85245442 0.38944675]\n [0.38824661 0.71542956 0.57709994 ... 0.78073156 0.51421234 0.45396759]]\n\nDropout Mask:\n[[0 1 1 ... 0 0 1]\n [0 1 0 ... 0 1 1]\n [1 1 0 ... 0 1 1]\n ...\n [0 0 0 ... 0 1 0]\n [0 0 1 ... 0 0 0]\n [0 0 1 ... 0 1 1]]\n\nDropped Activations:\n[[0.         0.87041739 0.84460613 ... 0.         0.         0.8684023 ]\n [0.         0.29461735 0.         ... 0.         0.58393672 0.70770389]\n [0.99267584 0.99084305 0.         ... 0.         0.55258449 0.34130822]\n ...\n [0.         0.         0.         ... 0.         0.24079385 0.        ]\n [0.         0.         0.17864954 ... 0.         0.         0.        ]\n [0.         0.         0.57709994 ... 0.         0.51421234 0.45396759]]\n```\n:::\n:::\n\n\nApplication 3: Statistical Data Analysis\n\nIn statistics, the Hadamard product can be applied to scale covariance matrices. Here’s how we can compute the covariance matrix using matrix operations and apply scaling.\n\n::: {#b6ce1353 .cell execution_count=15}\n``` {.python .cell-code}\nimport sympy as sp\nimport numpy as np\n\n# Simulated large dataset (2D array) using NumPy\ndata = np.random.rand(100, 10)\n\n# Compute the mean of each column\nmean = np.mean(data, axis=0)\n\n# Center the data\ncentered_data = data - mean\n\n# Compute the covariance matrix using matrix product operation\ncov_matrix = (centered_data.T @ centered_data) / (centered_data.shape[0] - 1)\ncov_matrix_sympy = sp.Matrix(cov_matrix)\n\n# Simulated scaling factors (2D array) using SymPy Matrix\nscaling_factors = sp.Matrix(np.random.rand(10, 10))\n\n# Compute Hadamard product\nscaled_cov_matrix = cov_matrix_sympy.multiply(scaling_factors)\n\n# Display results\nprint(\"Covariance Matrix:\")\nprint(cov_matrix_sympy)\nprint(\"\\nScaling Factors:\")\nprint(scaling_factors)\nprint(\"\\nScaled Covariance Matrix:\")\nprint(scaled_cov_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCovariance Matrix:\nMatrix([[0.0788046044726513, -0.00304934769307527, -0.00438518174765039, -0.000723429073346924, 0.000803374298447625, 0.00124748238891765, 0.00695538023746061, 0.00372057419532430, 0.0196784466543289, 0.00122306548261182], [-0.00304934769307527, 0.0813043584162656, 0.00352425427336682, -0.0140928485080072, 0.0117609016492402, -0.00265003196732907, -0.00873317145710714, 0.00218919319630423, 0.00570894041030775, -0.0123997905969564], [-0.00438518174765039, 0.00352425427336682, 0.0921818688676055, -0.0155676542730362, 0.00395596377021573, 0.00665555489970176, -0.00872709828678629, 0.00847523798927913, 0.0172208497154383, -0.00576476393543306], [-0.000723429073346924, -0.0140928485080072, -0.0155676542730362, 0.0807272311518056, -0.000963525818138950, 0.00842337829627435, 0.00127194911551330, -0.0171608043807779, -0.0138205373468713, 0.0161272562285705], [0.000803374298447625, 0.0117609016492402, 0.00395596377021573, -0.000963525818138950, 0.0878380270467204, 0.0105149158463958, -0.0120501266433211, -0.00741973669480270, 0.0136667233050394, 0.000284972548212635], [0.00124748238891765, -0.00265003196732907, 0.00665555489970176, 0.00842337829627435, 0.0105149158463958, 0.0686654728705294, 0.000451231346577458, -0.0127125928344776, -0.000439083040863072, 0.00250267862707372], [0.00695538023746061, -0.00873317145710714, -0.00872709828678629, 0.00127194911551330, -0.0120501266433211, 0.000451231346577458, 0.0864350799305982, 0.0173649892388032, 0.00782968749450413, 0.000817413174329276], [0.00372057419532430, 0.00218919319630423, 0.00847523798927913, -0.0171608043807779, -0.00741973669480270, -0.0127125928344776, 0.0173649892388032, 0.0813070511542109, -0.00124860792561536, 0.00191301241748492], [0.0196784466543289, 0.00570894041030775, 0.0172208497154383, -0.0138205373468713, 0.0136667233050394, -0.000439083040863072, 0.00782968749450413, -0.00124860792561536, 0.0873076907958406, -0.00505191844723564], [0.00122306548261182, -0.0123997905969564, -0.00576476393543306, 0.0161272562285705, 0.000284972548212635, 0.00250267862707372, 0.000817413174329276, 0.00191301241748492, -0.00505191844723564, 0.0737550296176420]])\n\nScaling Factors:\nMatrix([[0.507789002610705, 0.921690878055982, 0.460361788212539, 0.288628481892096, 0.599886865566931, 0.302308740150735, 0.839871215176559, 0.524370804289234, 0.870492384166042, 0.923823609486615], [0.164851717476652, 0.200547877818258, 0.352414435374929, 0.681814373370964, 0.198244189541824, 0.690440533605902, 0.567706278928956, 0.983535556033701, 0.344453440845208, 0.192300798089553], [0.434989880882950, 0.938513656639209, 0.415691798249556, 0.250077852267681, 0.905501099147395, 0.941820991508116, 0.262227591541917, 0.575452039248534, 0.282208818485910, 0.724471854073694], [0.684266108524500, 0.457048407840477, 0.989703669762338, 0.0628859531672193, 0.0595328767423046, 0.532621000141083, 0.405897364186952, 0.607531000551014, 0.207958022744720, 0.478302699996996], [0.817120656532643, 0.575594751844084, 0.106031062193213, 0.277106046538656, 0.485903110804279, 0.769294806228196, 0.557041577695262, 0.864387604760135, 0.722455297855395, 0.593773723831296], [0.733222500589801, 0.318030765170960, 0.583970281937878, 0.612678236705583, 0.0264928601779900, 0.467165124031230, 0.344184140106603, 0.228238704128403, 0.615655754573361, 0.855904623582136], [0.0179392913920881, 0.220711755774116, 0.997700197522840, 0.393575335358708, 0.706970188402990, 0.625256373625023, 0.797194444798163, 0.741922251471015, 0.705927901824568, 0.891106617218278], [0.692824778995113, 0.246437951162997, 0.0410274006888073, 0.180430222675926, 0.235163843425325, 0.775244633382779, 0.620613511243173, 0.164209348743754, 0.814171842255096, 0.185202022743113], [0.705955832791643, 0.654863272614590, 0.550499440853898, 0.616475656441232, 0.246462845994478, 0.461798302447226, 0.00725574649029903, 0.0717870813158890, 0.633057633834972, 0.0191253044376208], [0.212549324961594, 0.437494317039333, 0.170602265397828, 0.787720755526032, 0.963340024353493, 0.403951333967317, 0.642843972303609, 0.672282976220564, 0.144259859936059, 0.534795293446414]])\n\nScaled Covariance Matrix:\nMatrix([[0.0555365860359203, 0.0843087066683074, 0.0516124666136401, 0.0370144466195614, 0.0548993133516368, 0.0352181528454364, 0.0726707592212043, 0.0443460839157702, 0.0880821054714757, 0.0781544409845931], [0.0141662598963970, 0.0132137531113229, 0.00686983325377819, 0.0468945334660998, 0.00608808742785663, 0.0527008039786046, 0.0309059533939443, 0.0673478849600986, 0.0277228913740219, -0.000553359384968160], [0.0525596561202971, 0.0893751717705075, 0.0265784872055315, 0.0325544198689644, 0.0772247291450799, 0.0925248983154047, 0.0153876450232525, 0.0419712880087382, 0.0379390938319807, 0.0550484099678484], [0.0329699861106105, 0.0149737018162077, 0.0686500763541874, -0.00215217417452348, -0.00377001366081024, 0.00920377416688273, 0.0230697801369717, 0.0349110422273528, -0.00809634691000363, 0.0369085158455256], [0.0872442104223120, 0.0648610085265480, 0.0159046829357060, 0.0425303473198425, 0.0426765038491216, 0.0772010810026637, 0.0466175116615435, 0.0830196683068967, 0.0697445379350362, 0.0548662962146574], [0.0592170163680293, 0.0363787139614395, 0.0520710715861782, 0.0453155211774012, 0.0133116279238411, 0.0407043876010553, 0.0282741522313684, 0.0316544799642594, 0.0437252997094916, 0.0738858341350427], [0.00893341818041582, 0.0190992677210985, 0.0881396109101017, 0.0335105389288471, 0.0566790430821010, 0.0509238697147681, 0.0728192191856582, 0.0485867501052424, 0.0726497910841540, 0.0730889473744647], [0.0349784684209331, 0.0195543734494121, 0.00111266678523600, 0.0160038639829561, 0.0383087119268520, 0.0639179613193340, 0.0566401995860282, 0.0166717496089375, 0.0675707297340882, 0.0180352157059382], [0.0796499980885057, 0.0932393752035491, 0.0607055529549898, 0.0692275985549450, 0.0562295136646491, 0.0712625142024691, 0.0289889997536078, 0.0376354792715316, 0.0897380833526092, 0.0385958815741101], [0.0226227272268173, 0.0311720632333534, 0.0219454489511987, 0.0487343603521803, 0.0650542084496490, 0.0258117777229984, 0.0492574323674319, 0.0458858825947619, 0.00984340249036105, 0.0450238908284251]])\n```\n:::\n:::\n\n\n##### Inner Product of Matrices\n\nThe inner product of two matrices is a generalized extension of the dot product, where each matrix is treated as a vector in a high-dimensional space. For two matrices $A$ and $B$ of the same dimension $m \\times n$, the inner product is defined as the sum of the element-wise products of the matrices.\n\n::: {.callout-important}\n### Definition (Inner product)\n\nFor two matrices $A$ and $B$ of dimension $m \\times n$, the inner product $\\langle A, B \\rangle$ is given by:\n\n$$\\langle A, B \\rangle = \\sum_{i=1}^{m} \\sum_{j=1}^{n} A_{ij} \\cdot B_{ij}$$\n\nwhere $\\cdot$ denotes element-wise multiplication.\n:::\n\n\n::: {.callout-important}\n### Properties\n\n1.  **Commutativity**: \n  $$\\langle A, B \\rangle = \\langle B, A \\rangle$$\n  \n2.  **Linearity**: \n  $$\\langle A + C, B \\rangle = \\langle A, B \\rangle + \\langle C, B \\rangle$$\n  \n3.  **Positive Definiteness**: \n  $$\\langle A, A \\rangle \\geq 0$$\n  with equality if and only if $A$ is a zero matrix.\n:::\n\n\nSome simple examples showing the mathematical process of calculating the inner product is given bellow.\n\n**Example 1: Basic Inner Product**\n\nGiven matrices:\n\n$$A = \\begin{pmatrix}\n1 & 2 \\\\\n3 & 4\n\\end{pmatrix}, \\quad\nB = \\begin{pmatrix}\n5 & 6 \\\\\n7 & 8\n\\end{pmatrix}$$\n\nThe inner product $\\langle A, B \\rangle$ is:\n\n$$\\langle A, B \\rangle = 1 \\cdot 5 + 2 \\cdot 6 + 3 \\cdot 7 + 4 \\cdot 8 = 5 + 12 + 21 + 32 = 70$$\n\n**Example 2: Inner Product with Larger Matrices**\n\nGiven matrices:\n\n$$A = \\begin{pmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{pmatrix}, \\quad\nB = \\begin{pmatrix}\n9 & 8 & 7 \\\\\n6 & 5 & 4 \\\\\n3 & 2 & 1\n\\end{pmatrix}$$\n\nThe inner product $\\langle A, B \\rangle$ is calculated as:\n\\begin{align*}\nlangle A, B \\rangle &= 1 \\cdot 9 + 2 \\cdot 8 + 3 \\cdot 7 + 4 \\cdot 6 + 5 \\cdot 5 + 6 \\cdot 4 + 7 \\cdot 3 + 8 \\cdot 2 + 9 \\cdot 1\\\\\n&= 9 + 16 + 21 + 24 + 25 + 24 + 21 + 16 + 9\\\\\n&= 175\n\\end{align*}\n\nNow let's look into the computational part of *inner product*.\n\n1. Compute Inner Product from Scratch (without Libraries)\n\nHere’s how you can compute the inner product from the scratch:\n\n::: {#1e51dfc7 .cell execution_count=16}\n``` {.python .cell-code}\n# Define matrices A and B\nA = [[1, 2, 3], [4, 5, 6]]\nB = [[7, 8, 9], [10, 11, 12]]\n\n# Function to compute inner product\ndef inner_product(A, B):\n    # Get the number of rows and columns\n    num_rows = len(A)\n    num_cols = len(A[0])\n    \n    # Initialize the result\n    result = 0\n    \n    # Compute the inner product\n    for i in range(num_rows):\n        for j in range(num_cols):\n            result += A[i][j] * B[i][j]\n    \n    return result\n\n# Compute inner product\ninner_product_result = inner_product(A, B)\n\n# Display result\nprint(\"Inner Product (From Scratch):\")\nprint(inner_product_result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInner Product (From Scratch):\n217\n```\n:::\n:::\n\n\n2. Compute Inner Product Using `NumPy`\n\nHere’s how to compute the inner product using Numpy:\n\n::: {#786d9312 .cell execution_count=17}\n``` {.python .cell-code}\nimport numpy as np\n# Define matrices A and B\nA = np.array([[1, 2, 3], [4, 5, 6]])\nB = np.array([[7, 8, 9], [10, 11, 12]])\n# calculating innerproduct\ninner_product = (A*B).sum() # calculate element-wise product, then column sum\n\nprint(\"Inner Product (Using numpy):\")\nprint(inner_product)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInner Product (Using numpy):\n217\n```\n:::\n:::\n\n\nThe same operation can be done using `NumPy` functions as follows.\n\n::: {#597037f7 .cell execution_count=18}\n``` {.python .cell-code}\nimport sympy as sp\nimport numpy as np  \n# Define matrices A and B\nA = sp.Matrix([[1, 2, 3], [4, 5, 6]])\nB = sp.Matrix([[7, 8, 9], [10, 11, 12]])\n\n# Compute element-wise product\nelementwise_product = A.multiply_elementwise(B)\n\n# Calculate sum of each column\ninner_product_sympy = np.sum(elementwise_product)\n\n# Display result\nprint(\"Inner Product (Using SymPy):\")\nprint(inner_product_sympy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInner Product (Using SymPy):\n217\n```\n:::\n:::\n\n\nA vector dot product (in Physics) can be calculated using `SymPy` `.dot()` function as shown below. \n\nLet $A=\\begin{pmatrix}1&2&3\\end{pmatrix}$ and $B=\\begin{pmatrix}4&5&6\\end{pmatrix}$, then the dot product, $A\\cdot B$ is computed as:\n\n::: {#bc98c63f .cell execution_count=19}\n``` {.python .cell-code}\nimport sympy as sp\nA=sp.Matrix([1,2,3])\nB=sp.Matrix([4,5,6])\ndisplay(A.dot(B)) # calculate fot product of A and B\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown}\n$\\displaystyle 32$\n:::\n:::\n\n\n:::{.callout-warning}\n## A word of caution\nIn `SymPy` , `sp.Matrix([1,2,3])` create a column vector. But `np.array([1,2,3])` creates a row vector. So be careful while applying matrix/ dot product operations on these objects.\n:::\n\nThe same dot product using `numpy` object can be done as follows:\n\n::: {#54ea0d26 .cell execution_count=20}\n``` {.python .cell-code}\nimport numpy as np\nA=np.array([1,2,3])\nB=np.array([4,5,6])\nA.dot(B.T)# dot() stands for dot product B.T represents the transpose of B\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\nnp.int64(32)\n```\n:::\n:::\n\n\n**Practical Applications**\n\nApplication 1: Signal Processing\n\nIn signal processing, the inner product can be used to measure the similarity between two signals. Here the most popular measure of similarity is the `cosine` similarity. This measure is defined as:\n\n$$\\cos \\theta=\\dfrac{A\\cdot B}{||A|| ||B||}$$\n\nNow consider two digital signals are given. It's cosine similarity measure can be calculated with a simulated data as shown below.\n\n::: {#060aec46 .cell execution_count=21}\n``` {.python .cell-code}\nimport numpy as np\n\n# Simulated large signals (1D array) using NumPy\nsignal1 = np.sin(np.random.rand(1000))\nsignal2 = np.cos(np.random.rand(1000))\n\n# Compute inner product\ninner_product_signal = np.dot(signal1, signal2)\n#cosine_sim=np.dot(signal1,signal2)/(np.linalg.norm(signal1)*np.linalg.norm(signal2))\n# Display result\ncosine_sim=inner_product_signal/(np.sqrt(np.dot(signal1,signal1))*np.sqrt(np.dot(signal2,signal2)))\nprint(\"Inner Product (Using numpy):\")\nprint(inner_product_signal)\nprint(\"Similarity of signals:\")\nprint(cosine_sim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInner Product (Using numpy):\n391.51041380470053\nSimilarity of signals:\n0.872168977673512\n```\n:::\n:::\n\n\nApplication 2: Machine Learning - Feature Similarity\n\nIn machine learning, the inner product is used to calculate the similarity between feature vectors.\n\n::: {#b24f10da .cell execution_count=22}\n``` {.python .cell-code}\nimport numpy as np\n\n# Simulated feature vectors (2D array) using NumPy\nfeatures1 = np.random.rand(100, 10)\nfeatures2 = np.random.rand(100, 10)\n\n# Compute inner product for each feature vector\ninner_products = np.einsum('ij,ij->i', features1, features2) # use Einstien's sum\n\n# Display results\nprint(\"Inner Products of Feature Vectors:\")\nprint(inner_products)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInner Products of Feature Vectors:\n[2.81741233 2.62363884 3.22438685 3.00407518 2.37872691 2.6345075\n 1.26708857 1.74748851 4.22560221 4.3734001  4.10877682 0.90745771\n 3.77361184 1.7504151  2.37090156 2.70042357 2.28094279 3.61939851\n 3.304708   2.13495737 2.33297908 1.53996758 2.55447727 2.91760059\n 1.81881275 2.04986701 2.5451474  2.11686084 2.75284726 1.7829855\n 2.58831679 2.81808499 1.8402832  2.76613218 2.71553066 2.20121196\n 2.73396654 2.302734   1.79445606 2.31814991 2.61718969 3.81856539\n 2.83110142 1.61366989 2.81423207 1.33707233 2.07264082 2.42973896\n 3.12110334 1.75918971 3.74149397 2.65291737 2.74713036 3.09235888\n 2.46548244 2.02500099 2.39258534 2.6531278  2.24699046 1.97266018\n 2.76254069 2.64218457 2.81384718 2.11208092 3.33427349 3.50829485\n 2.29163997 1.71601606 2.80534326 2.91370394 2.53479679 3.28155336\n 2.68244892 3.21573464 3.74308149 2.5007984  1.52641336 3.09086791\n 1.81761184 2.59864199 5.27357839 2.6602584  1.65021457 1.9292059\n 2.29726324 2.90951081 3.07057225 2.60270332 3.67316332 1.33076571\n 2.56799624 3.29087449 3.12310182 1.75933129 2.36977394 2.49974945\n 1.59356636 2.48762837 3.90518064 1.25650412]\n```\n:::\n:::\n\n\nApplication 3: Covariance Matrix in Statistics\n\nThe inner product can be used to compute covariance matrices for statistical data analysis. If $X$ is a given distribution and $x=X-\\bar{X}$. Then the covariance of $X$ can be calculated as $cov(X)=\\dfrac{1}{n-1}(x\\cdot x^T)$ ^[Remember that the covariance of $X$ is defined as $Cov(X)=\\dfrac{\\sum (X-\\bar{X})^2}{n-1}$]. The python code a simulated data is shown below.\n\n::: {#e169340c .cell execution_count=23}\n``` {.python .cell-code}\nimport sympy as sp\nimport numpy as np\n\n# Simulated large dataset (2D array) using NumPy\ndata = np.random.rand(100, 10)\n\n# Compute the mean of each column\nmean = np.mean(data, axis=0)\n\n# Center the data\ncentered_data = data - mean\n\n# Compute the covariance matrix using matrix product operation\ncov_matrix = (centered_data.T @ centered_data) / (centered_data.shape[0] - 1)\ncov_matrix_sympy = sp.Matrix(cov_matrix)\n\n# Display results\nprint(\"Covariance Matrix:\")\nprint(cov_matrix_sympy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCovariance Matrix:\nMatrix([[0.0825756479399736, -0.00143884272188479, -0.0150845745963579, 0.00585740386082970, -0.00251308363581066, 0.00940370975476215, 0.00398346088173367, -0.0102104413919231, 0.00914400771098456, 0.00808298333143312], [-0.00143884272188479, 0.0741110541661852, 0.0184638661014915, -0.00456816171599506, 0.00602550674715550, -0.00903924982927731, 0.00408719119760089, 0.00700717611853449, 0.00510787223997128, 0.00358764646258043], [-0.0150845745963579, 0.0184638661014915, 0.0901800977789118, 0.00246026195148743, 0.00140040735741254, -0.00190303789992076, 0.00890333323490244, 0.00830075466048054, -0.00364038850035898, -0.00535124285813519], [0.00585740386082970, -0.00456816171599506, 0.00246026195148743, 0.0689042281287209, -0.00424351767668173, -0.00991662911796387, -0.000825736129267059, 0.000154908282187785, -0.0152701556062448, -0.000860187492745651], [-0.00251308363581066, 0.00602550674715550, 0.00140040735741254, -0.00424351767668173, 0.0828884760859893, -0.00572685468580185, -0.00546405915271126, -0.000168638811453311, 0.00241596496652660, -0.00251236659602759], [0.00940370975476215, -0.00903924982927731, -0.00190303789992076, -0.00991662911796387, -0.00572685468580185, 0.0787821878821962, -0.00609465542775232, -0.0125466762188460, -0.00346337406654995, 0.000831573891661168], [0.00398346088173367, 0.00408719119760089, 0.00890333323490244, -0.000825736129267059, -0.00546405915271126, -0.00609465542775232, 0.0873453533264268, 0.00726406322846968, 0.00306893162959867, 0.00251368272053239], [-0.0102104413919231, 0.00700717611853449, 0.00830075466048054, 0.000154908282187785, -0.000168638811453311, -0.0125466762188460, 0.00726406322846968, 0.0759990765409087, 0.00265209177691456, -0.0132428462111232], [0.00914400771098456, 0.00510787223997128, -0.00364038850035898, -0.0152701556062448, 0.00241596496652660, -0.00346337406654995, 0.00306893162959867, 0.00265209177691456, 0.0669519536301808, 0.0109221841227183], [0.00808298333143312, 0.00358764646258043, -0.00535124285813519, -0.000860187492745651, -0.00251236659602759, 0.000831573891661168, 0.00251368272053239, -0.0132428462111232, 0.0109221841227183, 0.0642255159262406]])\n```\n:::\n:::\n\n\nThese examples demonstrate the use of inner product and dot product in various applications.\n\n#### Outer Product\n\nThe outer product of two vectors results in a matrix, and it is a way to combine these vectors into a higher-dimensional representation.\n\n:::{.callout-note}\n\n### Definition (Outer Product)\n\nFor two vectors $\\mathbf{u}$ and $\\mathbf{v}$ of dimensions $m$ and $n$ respectively, the outer product $\\mathbf{u} \\otimes \\mathbf{v}$ is an $m \\times n$ matrix defined as:\n\n$$(\\mathbf{u} \\otimes \\mathbf{v})_{ij} = u_i \\cdot v_j$$\n\nwhere $\\cdot$ denotes the outer product operation. In matrix notation, for two column vectors $u,v$, \n$$u\\otimes v=uv^T$$\n:::\n\n\n:::{.callout-note}\n### Properties\n\n1.  **Linearity**:\n  $$(\\mathbf{u} + \\mathbf{w}) \\otimes \\mathbf{v} = (\\mathbf{u} \\otimes \\mathbf{v}) + (\\mathbf{w} \\otimes \\mathbf{v})$$\n  \n2.  **Distributivity**:\n  $$\\mathbf{u} \\otimes (\\mathbf{v} + \\mathbf{w}) = (\\mathbf{u} \\otimes \\mathbf{v}) + (\\mathbf{u} \\otimes \\mathbf{w})$$\n  \n3.  **Associativity**:\n  $$(\\mathbf{u} \\otimes \\mathbf{v}) \\otimes \\mathbf{w} = \\mathbf{u} \\otimes (\\mathbf{v} \\otimes \\mathbf{w})$$\n\n:::\n\nSome simple examples of outer product is given below.\n\n**Example 1: Basic Outer Product**\n\nGiven vectors:\n\n$$\\mathbf{u} = \\begin{pmatrix}\n1 \\\\\n2\n\\end{pmatrix}, \\quad\n\\mathbf{v} = \\begin{pmatrix}\n3 \\\\\n4 \\\\\n5\\end{pmatrix}$$\n\nThe outer product $\\mathbf{u} \\otimes \\mathbf{v}$ is:\n\n$$\\mathbf{u} \\otimes \\mathbf{v} = \\begin{pmatrix}\n1 \\cdot 3 & 1 \\cdot 4 & 1 \\cdot 5 \\\\\n2 \\cdot 3 & 2 \\cdot 4 & 2 \\cdot 5\n\\end{pmatrix} = \\begin{pmatrix}\n3 & 4 & 5 \\\\\n6 & 8 & 10\n\\end{pmatrix}$$\n\n**Example 2: Outer Product with Larger Vectors**\n\nGiven vectors:\n$$\\mathbf{u} = \\begin{pmatrix}\n1 \\\\\n2 \\\\\n3\n\\end{pmatrix}, \\quad\n\\mathbf{v} = \\begin{pmatrix}\n4 \\\\\n5\n\\end{pmatrix}$$\n\nThe outer product $\\mathbf{u} \\otimes \\mathbf{v}$ is:\n\n$$\\mathbf{u} \\otimes \\mathbf{v} = \\begin{pmatrix}\n1 \\cdot 4 & 1 \\cdot 5 \\\\\n2 \\cdot 4 & 2 \\cdot 5 \\\\\n3 \\cdot 4 & 3 \\cdot 5\n\\end{pmatrix} = \\begin{pmatrix}\n4 & 5 \\\\\n8 & 10 \\\\\n12 & 15\n\\end{pmatrix}$$\n\n**1. Compute Outer Product of Vectors from Scratch (without Libraries)**\n\nHere’s how you can compute the outer product manually:\n\n::: {#8e6a469a .cell execution_count=24}\n``` {.python .cell-code}\n# Define vectors u and v\nu = [1, 2]\nv = [3, 4, 5]\n\n# Function to compute outer product\ndef outer_product(u, v):\n    # Initialize the result\n    result = [[a * b for b in v] for a in u]\n    return result\n\n# Compute outer product\nouter_product_result = outer_product(u, v)\n\n# Display result\nprint(\"Outer Product of Vectors (From Scratch):\")\nfor row in outer_product_result:\n    print(row)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOuter Product of Vectors (From Scratch):\n[3, 4, 5]\n[6, 8, 10]\n```\n:::\n:::\n\n\n**2. Compute Outer Product of Vectors Using SymPy**\n\nHere’s how to compute the outer product using `SymPy`:\n\n::: {#b0bf8805 .cell execution_count=25}\n``` {.python .cell-code}\nimport sympy as sp\n\n# Define vectors u and v\nu = sp.Matrix([1, 2])\nv = sp.Matrix([3, 4, 5])\n\n# Compute outer product using SymPy\nouter_product_sympy = u * v.T\n\n# Display result\nprint(\"Outer Product of Vectors (Using SymPy):\")\nprint(outer_product_sympy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOuter Product of Vectors (Using SymPy):\nMatrix([[3, 4, 5], [6, 8, 10]])\n```\n:::\n:::\n\n\n**Outer Product of Matrices**\n \nThe outer product of two matrices extends the concept from vectors to higher-dimensional tensors. For two matrices $A$ and $B$, the outer product results in a higher-dimensional tensor and is generally expressed as block matrices.\n\n:::{.callout-note}\n### Definition (Outer Product of Matrices)\n\nFor two matrices $A$ of dimension $m \\times p$ and $B$ of dimension $q \\times n$, the outer product $A \\otimes B$ results in a tensor of dimension $m \\times q \\times p \\times n$. The entries of the tensor are given by:\n\n$$(A \\otimes B)_{ijkl} = A_{ij} \\cdot B_{kl}$$\n\nwhere $\\cdot$ denotes the outer product operation.\n:::\n\n:::{.callout-note}\n\n### Properties\n\n1.  **Linearity**:\n  $$(A + C) \\otimes B = (A \\otimes B) + (C \\otimes B)$$\n  \n2.  **Distributivity**:\n  $$A \\otimes (B + D) = (A \\otimes B) + (A \\otimes D)$$\n  \n3. **Associativity**:\n\n  $$(A \\otimes B) \\otimes C = A \\otimes (B \\otimes C)$$\n:::\n\nHere are some simple examples to demonstrate the mathematical procedure to find outer product of matrices.\n\n**Example 1: Basic Outer Product of Matrices**\n\nGiven matrices:\n$$\nA = \\begin{pmatrix}\n1 & 2 \\\\\n3 & 4\n\\end{pmatrix}, \\quad\nB = \\begin{pmatrix}\n5 \\\\\n6\n\\end{pmatrix}$$\n\nThe outer product $A \\otimes B$ is:\n\n$$A \\otimes B = \\begin{pmatrix}\n1 \\cdot 5 & 1 \\cdot 6 \\\\\n2 \\cdot 5 & 2 \\cdot 6 \\\\\n3 \\cdot 5 & 3 \\cdot 6 \\\\\n4 \\cdot 5 & 4 \\cdot 6\n\\end{pmatrix} = \\begin{pmatrix}\n5 & 6 \\\\\n10 & 12 \\\\\n15 & 18 \\\\\n20 & 24\n\\end{pmatrix}$$\n\n**Example 2: Outer Product with Larger Matrices**\n\nGiven matrices:\n\n$$A = \\begin{pmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6\n\\end{pmatrix}, \\quad\nB = \\begin{pmatrix}\n7 \\\\\n8\n\\end{pmatrix}$$\n\nThe outer product $A \\otimes B$ is:\n\n$$A \\otimes B = \\begin{pmatrix}\n1 \\cdot 7 & 1 \\cdot 8 \\\\\n2 \\cdot 7 & 2 \\cdot 8 \\\\\n3 \\cdot 7 & 3 \\cdot 8 \\\\\n4 \\cdot 7 & 4 \\cdot 8 \\\\\n5 \\cdot 7 & 5 \\cdot 8 \\\\\n6 \\cdot 7 & 6 \\cdot 8\n\\end{pmatrix} = \\begin{pmatrix}\n7 & 8 \\\\\n14 & 16 \\\\\n21 & 24 \\\\\n28 & 32 \\\\\n35 & 40 \\\\\n42 & 48\n\\end{pmatrix}$$\n\n**Example 3: Compute the outer product of the following vectors $\\mathbf{u} = [0, 1, 2]$ and $\\mathbf{v} = [2, 3, 4]$.\n\nTo find the outer product, we calculate each element $(i, j)$ as the product of the $(i)$-th element of $\\mathbf{u}$ and the $(j)$-th element of $\\mathbf{v}$. Mathematically:\n\n$$\\mathbf{u} \\otimes \\mathbf{v} = \\begin{bmatrix}\n0 \\cdot 2 & 0 \\cdot 3 & 0 \\cdot 4 \\\\\n1 \\cdot 2 & 1 \\cdot 3 & 1 \\cdot 4 \\\\\n2 \\cdot 2 & 2 \\cdot 3 & 2 \\cdot 4\n\\end{bmatrix}\n= \\begin{bmatrix}\n0 & 0 & 0 \\\\\n2 & 3 & 4 \\\\\n4 & 6 & 8\n\\end{bmatrix}$$\n\n**1. Compute Outer Product of Matrices from Scratch (without Libraries)**\n\nHere’s how you can compute the outer product manually:\n\n::: {#de3e2992 .cell execution_count=26}\n``` {.python .cell-code}\n# Define matrices A and B\nA = [[1, 2], [3, 4]]\nB = [[5], [6]]\n\n# Function to compute outer product\ndef outer_product_matrices(A, B):\n    m = len(A)\n    p = len(A[0])\n    q = len(B)\n    n = len(B[0])\n    result = [[0] * (n * p) for _ in range(m * q)]\n\n    for i in range(m):\n        for j in range(p):\n            for k in range(q):\n                for l in range(n):\n                    result[i*q + k][j*n + l] = A[i][j] * B[k][l]\n\n    return result\n\n# Compute outer product\nouter_product_result_matrices = outer_product_matrices(A, B)\n\n# Display result\nprint(\"Outer Product of Matrices (From Scratch):\")\nfor row in outer_product_result_matrices:\n    print(row)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOuter Product of Matrices (From Scratch):\n[5, 10]\n[6, 12]\n[15, 20]\n[18, 24]\n```\n:::\n:::\n\n\nHere is the Python code to compute the outer product of these vectors using the `NumPy` function `.outer()`:\n\n::: {#f2da1f22 .cell execution_count=27}\n``` {.python .cell-code}\nimport numpy as np\n\n# Define vectors\nu = np.array([[1,2],[3,4]])\nv = np.array([[5],[4]])\n\n# Compute outer product\nouter_product = np.outer(u, v)\n\nprint(\"Outer Product of u and v:\")\nprint(outer_product)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOuter Product of u and v:\n[[ 5  4]\n [10  8]\n [15 12]\n [20 16]]\n```\n:::\n:::\n\n\n**Example 3: Real-world Application in Recommendation Systems**\n\nIn recommendation systems, the outer product can represent user-item interactions. A simple context is here. Let the user preferences of items is given as $u=[4, 3, 5]$ and the item scores is given by $v=[2, 5, 4]$. Now the recommendation score can be calculated as the outer product of these two vectors. Calculation of this score is shown below.\nThe outer product $\\mathbf{u} \\otimes \\mathbf{v}$ is calculated as follows:\n\n$$\\mathbf{u} \\otimes \\mathbf{v} = \\begin{bmatrix}\n4 \\cdot 2 & 4 \\cdot 5 & 4 \\cdot 4 \\\\\n3 \\cdot 2 & 3 \\cdot 5 & 3 \\cdot 4 \\\\\n5 \\cdot 2 & 5 \\cdot 5 & 5 \\cdot 4\n\\end{bmatrix}\n= \\begin{bmatrix}\n8 & 20 & 16 \\\\\n6 & 15 & 12 \\\\\n10 & 25 & 20\n\\end{bmatrix}$$\n\nThe python code for this task is given below.\n\n::: {#800698d5 .cell execution_count=28}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the user and product ratings vectors\nuser_ratings = np.array([4, 3, 5])\nproduct_ratings = np.array([2, 5, 4])\n\n# Compute the outer product\npredicted_ratings = np.outer(user_ratings, product_ratings)\n\n# Print the predicted ratings matrix\nprint(\"Predicted Ratings Matrix:\")\nprint(predicted_ratings)\n\n# Plot the result\nplt.imshow(predicted_ratings, cmap='coolwarm', interpolation='nearest')\nplt.colorbar()\nplt.title('Predicted Ratings Matrix (Recommendation System)')\nplt.xlabel('Product Ratings')\nplt.ylabel('User Ratings')\nplt.xticks(ticks=np.arange(len(product_ratings)), labels=product_ratings)\nplt.yticks(ticks=np.arange(len(user_ratings)), labels=user_ratings)\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPredicted Ratings Matrix:\n[[ 8 20 16]\n [ 6 15 12]\n [10 25 20]]\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](module_2_files/figure-html/cell-29-output-2.png){width=509 height=449}\n:::\n:::\n\n\n:::{.callout-note}\n### Additional Properties & Definitions\n\n1. **Definition and Properties**\n\n   Given two vectors:\n   - $\\mathbf{u} \\in \\mathbb{R}^m$\n   - $\\mathbf{v} \\in \\mathbb{R}^n$\n\n   The outer product $\\mathbf{u} \\otimes \\mathbf{v}$ results in an $m \\times n$ matrix where each element $(i, j)$ of the matrix is calculated as:\n   $$(\\mathbf{u} \\otimes \\mathbf{v})_{ij} = u_i \\cdot v_j$$\n\n2. **Non-Symmetry**\n\n   The outer product is generally not symmetric. For vectors $\\mathbf{u}$ and $\\mathbf{v}$, the matrix $\\mathbf{u} \\otimes \\mathbf{v}$ is not necessarily equal to $\\mathbf{v} \\otimes \\mathbf{u}$:\n   $$\\mathbf{u} \\otimes \\mathbf{v} \\neq \\mathbf{v} \\otimes \\mathbf{u}$$\n\n3. **Rank of the Outer Product**\n\n   The rank of the outer product matrix $\\mathbf{u} \\otimes \\mathbf{v}$ is always 1, provided neither $\\mathbf{u}$ nor $\\mathbf{v}$ is a zero vector. This is because the matrix can be expressed as a single rank-1 matrix.\n\n4. **Distributive Property**\n\n   The outer product is distributive over vector addition. For vectors $\\mathbf{u}_1, \\mathbf{u}_2 \\in \\mathbb{R}^m$ and $\\mathbf{v} \\in \\mathbb{R}^n$:\n   $$(\\mathbf{u}_1 + \\mathbf{u}_2) \\otimes \\mathbf{v} = (\\mathbf{u}_1 \\otimes \\mathbf{v}) + (\\mathbf{u}_2 \\otimes \\mathbf{v})$$\n\n5. **Associativity with Scalar Multiplication**\n\n   The outer product is associative with scalar multiplication. For a scalar $\\alpha$ and vectors $\\mathbf{u} \\in \\mathbb{R}^m$ and $\\mathbf{v} \\in \\mathbb{R}^n$:\n   $$\\alpha (\\mathbf{u} \\otimes \\mathbf{v}) = (\\alpha \\mathbf{u}) \\otimes \\mathbf{v} = \\mathbf{u} \\otimes (\\alpha \\mathbf{v})$$\n\n6. **Matrix Trace**\n\n   The trace of the outer product of two vectors is given by:\n   $$\\text{tr}(\\mathbf{u} \\otimes \\mathbf{v}) = (\\mathbf{u}^T \\mathbf{v}) \\cdot (\\mathbf{v}^T \\mathbf{u})$$\n   Here, $\\text{tr}$ denotes the trace of a matrix, which is the sum of its diagonal elements.\n\n7. **Matrix Norm**\n\n   The Frobenius norm of the outer product matrix can be expressed in terms of the norms of the original vectors:\n   $$\\| \\mathbf{u} \\otimes \\mathbf{v} \\|_F = \\| \\mathbf{u} \\|_2 \\cdot \\| \\mathbf{v} \\|_2$$\n   where $\\| \\cdot \\|_2$ denotes the Euclidean norm.\n\n:::\n\n**Example Calculation in Python**\n\nHere’s how to compute and visualize the outer product properties using Python:\n\n::: {#ac99c86b .cell execution_count=29}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define vectors\nu = np.array([1, 2, 3])\nv = np.array([4, 5])\n\n# Compute outer product\nouter_product = np.outer(u, v)\n\n# Display results\nprint(\"Outer Product Matrix:\")\nprint(outer_product)\n\n# Compute and display rank\nrank = np.linalg.matrix_rank(outer_product)\nprint(f\"Rank of Outer Product Matrix: {rank}\")\n\n# Compute Frobenius norm\nfrobenius_norm = np.linalg.norm(outer_product, 'fro')\nprint(f\"Frobenius Norm: {frobenius_norm}\")\n\n# Plot the result\nplt.imshow(outer_product, cmap='viridis', interpolation='nearest')\nplt.colorbar()\nplt.title('Outer Product Matrix')\nplt.xlabel('Vector v')\nplt.ylabel('Vector u')\nplt.xticks(ticks=np.arange(len(v)), labels=v)\nplt.yticks(ticks=np.arange(len(u)), labels=u)\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOuter Product Matrix:\n[[ 4  5]\n [ 8 10]\n [12 15]]\nRank of Outer Product Matrix: 1\nFrobenius Norm: 23.958297101421877\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](module_2_files/figure-html/cell-30-output-2.png){width=373 height=449}\n:::\n:::\n\n\n#### Kronecker Product\n\nIn mathematics, the Kronecker product, sometimes denoted by $\\otimes$, is an operation on two matrices of arbitrary size resulting in a *block matrix*. It is a specialization of the tensor product (which is denoted by the same symbol) from vectors to matrices and gives the matrix of the tensor product linear map with respect to a standard choice of basis. The Kronecker product is to be distinguished from the usual matrix multiplication, which is an entirely different operation. The Kronecker product is also sometimes called *matrix direct product*.\n\n:::{.callout-note}\nIf $A$ is an $m \\times n$ matrix and $B$ is a $p \\times q$ matrix, then the Kronecker product $A\\otimes B$ is the $pm \\times qn$ block matrix defined as: Each\n$a_{ij}$ of $A$ is replaced by the matrix $a_{ij}B$. Symbolically this will result in a block matrix defined by:\n\n$$A\\otimes B=\\begin{bmatrix}A \\otimes B = \\begin{bmatrix}\na_{11}B & a_{12}B & \\cdots & a_{1n}B \\\\\na_{21}B & a_{22}B & \\cdots & a_{2n}B \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m1}B & a_{m2}B & \\cdots & a_{mn}B\n\\end{bmatrix} \\end{bmatrix}$$\n:::\n\n:::{.callout-note}\n\n#### Properties of the Kronecker Product\n\n1. **Associativity**\n\n   The Kronecker product is associative. For matrices $A \\in \\mathbb{R}^{m \\times n}$, $B \\in \\mathbb{R}^{p \\times q}$, and $C \\in \\mathbb{R}^{r \\times s}$:\n   $$(A \\otimes B) \\otimes C = A \\otimes (B \\otimes C)$$\n\n2. **Distributivity Over Addition**\n\n   The Kronecker product distributes over matrix addition. For matrices $A \\in \\mathbb{R}^{m \\times n}$, $B \\in \\mathbb{R}^{p \\times q}$, and $C \\in \\mathbb{R}^{p \\times q}$:\n   $$A \\otimes (B + C) = (A \\otimes B) + (A \\otimes C)$$\n\n3. **Mixed Product Property**\n\n   The Kronecker product satisfies the mixed product property with the matrix product. For matrices $A \\in \\mathbb{R}^{m \\times n}$, $B \\in \\mathbb{R}^{p \\times q}$, $C \\in \\mathbb{R}^{r \\times s}$, and $D \\in \\mathbb{R}^{r \\times s}$:\n   $$(A \\otimes B) (C \\otimes D) = (A C) \\otimes (B D)$$\n\n4. **Transpose**\n\n   The transpose of the Kronecker product is given by:\n   $$(A \\otimes B)^T = A^T \\otimes B^T$$\n\n5. **Norm**\n\n   The Frobenius norm of the Kronecker product can be computed as:\n  $$\\| A \\otimes B \\|_F = \\| A \\|_F \\cdot \\| B \\|_F$$\n   where $\\| \\cdot \\|_F $ denotes the Frobenius norm.\n  :::\n\n:::{.callout-tip}\n\n### Frobenius Norm\n\nThe Frobenius norm, also known as the Euclidean norm for matrices, is a measure of a matrix's magnitude. It is defined as the square root of the sum of the absolute squares of its elements. Mathematically, for a matrix $A$ with elements $a_{ij}$, the Frobenius norm is given by:\n\n$$\\|A\\|_F = \\sqrt{\\sum_{i,j} |a_{ij}|^2}$$\n:::\n\nExample 1: Calculation of Frobenius Norm\n\nConsider the matrix $A$:\n\n$$A = \\begin{bmatrix}\n1 & 2 \\\\\n3 & 4\n\\end{bmatrix}$$\n\nTo compute the Frobenius norm:\n\n$$\\|A\\|_F = \\sqrt{1^2 + 2^2 + 3^2 + 4^2}\n= \\sqrt{1 + 4 + 9 + 16}\n= \\sqrt{30}\n\\approx 5.48$$\n\nExample 2: Frobenius Norm of a Sparse Matrix\n\nConsider the sparse matrix $B$:\n\n$$B = \\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 5 & 0 \\\\\n0 & 0 & 0\n\\end{bmatrix}$$\n\nTo compute the Frobenius norm:\n\n$$\\|B\\|_F = \\sqrt{0^2 + 0^2 + 0^2 + 5^2 + 0^2 + 0^2}\n= \\sqrt{25}\n= 5$$\n\nExample 3: Frobenius Norm in a Large Matrix\n\nConsider the matrix $C$ of size $3 \\times 3 $:\n\n$$C = \\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{bmatrix}$$\n\nTo compute the Frobenius norm:\n\n\\begin{align*}\n\\|C\\|_F &= \\sqrt{1^2 + 2^2 + 3^2 + 4^2 + 5^2 + 6^2 + 7^2 + 8^2 + 9^2}\\\\\n&= \\sqrt{1 + 4 + 9 + 16 + 25 + 36 + 49 + 64 + 81}\n&= \\sqrt{285}\n&\\approx 16.88\n\\end{align*}\n\n**Applications of the Frobenius Norm**\n\n- *Application 1: Image Compression:* In image processing, the Frobenius norm can measure the difference between the original and compressed images, indicating how well the compression has preserved the original image quality.\n\n- *Application 2: Matrix Factorization:* In numerical analysis, Frobenius norm is used to evaluate the error in matrix approximations, such as in Singular Value Decomposition (SVD). A lower Frobenius norm of the error indicates a better approximation.\n\n- *Application 3: Error Measurement in Numerical Solutions:* In solving systems of linear equations, the Frobenius norm can be used to measure the error between the true solution and the computed solution, providing insight into the accuracy of numerical methods.\n\nThe `linalg` sub module of `NumPy` library can be used to calculate various norms. Basically norm is the generalized form of Euclidean distance.\n\n::: {#7a29c07d .cell execution_count=30}\n``` {.python .cell-code}\nimport numpy as np\n\n# Example 1: Simple Matrix\nA = np.array([[1, 2], [3, 4]])\nfrobenius_norm_A = np.linalg.norm(A, 'fro')\nprint(f\"Frobenius Norm of A: {frobenius_norm_A:.2f}\")\n\n# Example 2: Sparse Matrix\nB = np.array([[0, 0, 0], [0, 5, 0], [0, 0, 0]])\nfrobenius_norm_B = np.linalg.norm(B, 'fro')\nprint(f\"Frobenius Norm of B: {frobenius_norm_B:.2f}\")\n\n# Example 3: Large Matrix\nC = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nfrobenius_norm_C = np.linalg.norm(C, 'fro')\nprint(f\"Frobenius Norm of C: {frobenius_norm_C:.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFrobenius Norm of A: 5.48\nFrobenius Norm of B: 5.00\nFrobenius Norm of C: 16.88\n```\n:::\n:::\n\n\n**Frobenius norm of Kronecker product**\n\nLet us consider two matrices,\n\n$$A = \\begin{bmatrix}\n1 & 2 \\\\\n3 & 4\n\\end{bmatrix}$$\n\nand\n\n$$B = \\begin{bmatrix}\n0 & 5 \\\\\n6 & 7\n\\end{bmatrix}$$\n\nThe Kronecker product $C = A \\otimes B$ is:\n\n$$C = \\begin{bmatrix}\n1 \\cdot B & 2 \\cdot B \\\\\n3 \\cdot B & 4 \\cdot B\n\\end{bmatrix}\n= \\begin{bmatrix}\n\\begin{bmatrix}\n0 & 5 \\\\\n6 & 7\n\\end{bmatrix} & \\begin{bmatrix}\n0 \\cdot 2 & 5 \\cdot 2 \\\\\n6 \\cdot 2 & 7 \\cdot 2\n\\end{bmatrix} \\\\\n\\begin{bmatrix}\n0 \\cdot 3 & 5 \\cdot 3 \\\\\n6 \\cdot 3 & 7 \\cdot 3\n\\end{bmatrix} & \\begin{bmatrix}\n0 \\cdot 4 & 5 \\cdot 4 \\\\\n6 \\cdot 4 & 7 \\cdot 4\n\\end{bmatrix}\n\\end{bmatrix}$$\n\nThis expands to:\n\n$$C = \\begin{bmatrix}\n0 & 5 & 0 & 10 \\\\\n6 & 7 & 12 & 14 \\\\\n0 & 15 & 0 & 20 \\\\\n18 & 21 & 24 & 28\n\\end{bmatrix}$$\n\n*Computing the Frobenius Norm*\n\nTo compute the Frobenius norm of $C$:\n\n$$\\|C\\|_F = \\sqrt{\\sum_{i=1}^{4} \\sum_{j=1}^{4} |c_{ij}|^2}$$\n\n$$\\|C\\|_F = \\sqrt{0^2 + 5^2 + 0^2 + 10^2 + 6^2 + 7^2 + 12^2 + 14^2 + 0^2 + 15^2 + 0^2 + 20^2 + 18^2 + 21^2 + 24^2 + 28^2}$$\n\n$$\\|C\\|_F = \\sqrt{0 + 25 + 0 + 100 + 36 + 49 + 144 + 196 + 0 + 225 + 0 + 400 + 324 + 441 + 576 + 784}$$\n\n$$\\|C\\|_F = \\sqrt{2896}$$\n$$\\|C\\|_F \\approx 53.87$$\n\n",
    "supporting": [
      "module_2_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}