{
  "hash": "39458dbf3aac10fbff4f07354cd0f71c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Transforming Linear Algebra to Computational Language\"\nexecute: \n  enabled: true\n---\n\n\n\n\n\n\n\n## Introduction \n\nIn the first module, we established a solid foundation in matrix algebra by exploring pseudocode and implementing fundamental matrix operations using `Python`. We practiced key concepts such as matrix addition, subtraction, multiplication, and determinants through practical examples in image processing, leveraging the `SymPy` library for symbolic computation. \n\nAs we begin the second module, **\"Transforming Linear Algebra to Computational Language,\"** our focus will shift towards applying these concepts with greater depth and actionable insight. This module is designed to bridge the theoretical knowledge from matrix algebra with practical computational applications. You will learn to interpret and utilize matrix operations, solve systems of equations, and analyze the rank of matrices within a variety of real-world contexts. \n\nA new concept we will introduce is the **Rank-Nullity Theorem**, which provides a fundamental relationship between the rank of a matrix and the dimensions of its null space. This theorem is crucial for understanding the solution spaces of linear systems and the properties of linear transformations. By applying this theorem, you will be able to gain deeper insights into the structure of solutions and the behavior of matrix transformations.\n\nThis transition will not only reinforce your understanding of linear algebra but also enhance your ability to apply these concepts effectively in computational settings. Through engaging examples and practical exercises, you will gain valuable experience in transforming abstract mathematical principles into tangible solutions, setting a strong groundwork for advanced computational techniques.\n\n## Relearning of Terms and Operations in Linear Algebra\n\nIn this section, we will revisit fundamental matrix operations such as addition, subtraction, scaling, and more through practical examples. Our goal is to transform theoretical linear algebra into modern computational applications. We will demonstrate these concepts using `Python`, focusing on practical and industrial applications.\n\n### Matrix Addition and Subtraction in Data Analysis\n\nMatrix addition and subtraction are fundamental operations that help in combining datasets and analyzing differences. \n\n**Simple Example: Combining Quarterly Sales Data**\n\nWe begin with quarterly sales data from different regions and combine them to get the total sales. The sales data is given in @tbl-qtb. A ar plot of the total sales is shown in [Fig @fig-total1].\n\n\n| Region | Q1   | Q2   | Q3   | Q4   |\n|--------|------|------|------|------|\n| A      | 2500 | 2800 | 3100 | 2900 |\n| B      | 1500 | 1600 | 1700 | 1800 |\n\n: Quarterly Sales Data {#tbl-qtb}\n\n**From Scratch `Python` Implementation:**\n\n::: {#cell-fig-total1 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Quarterly sales data\nsales_region_a = np.array([2500, 2800, 3100, 2900])\nsales_region_b = np.array([1500, 1600, 1700, 1800])\n\n# Combine sales data\ntotal_sales = sales_region_a + sales_region_b\n\n# Visualization\nquarters = ['Q1', 'Q2', 'Q3', 'Q4']\nplt.bar(quarters, total_sales, color='skyblue')\nplt.xlabel('Quarter')\nplt.ylabel('Total Sales')\nplt.title('Combined Quarterly Sales Data for Regions A and B')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Computing Total Sales using `Numpy` aggregation method](module_2_files/figure-epub/fig-total1-output-1.png){#fig-total1}\n:::\n:::\n\n\nIn the above `Python` code, we have performed the aggregation operation with the `NumPy` method. Same can be done in a more data analysis style using `pandas` inorder to handle tabular data meaningfully. In this approach, quarterly sales data of each region is stored as `DataFrames`(like an excel sheet). The we combine these two `DataFrames` into one. After that create a new row with index 'Total' and populate this row with sum of quarterly sales in Region A and Region B. Finally a bar plot is created using this 'Total' sales. Advantage of this approach is that we don't need the `matplotlib` library to create visualizations!. The EDA using this approach is shown in [Fig @fig-tot2].\n\n::: {#cell-fig-tot2 .cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# DataFrames for quarterly sales data\ndf_a = pd.DataFrame({'Q1': [2500], 'Q2': [2800], 'Q3': [3100], 'Q4': [2900]}, index=['Region A'])\ndf_b = pd.DataFrame({'Q1': [1500], 'Q2': [1600], 'Q3': [1700], 'Q4': [1800]}, index=['Region B'])\n\n# Combine data\ndf_combined = df_a.add(df_b, fill_value=0)\ndf_combined.loc[\"Total\"] = df_combined.sum(axis=0)\n# Visualization\ndf_combined.loc[\"Total\"].plot(kind='bar', color=['green'])\nplt.xlabel('Quarter')\nplt.ylabel('Total Sales')\nplt.title('Combined Quarterly Sales Data for Regions A and B')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Computation of Total Sales using `Pandas` method](module_2_files/figure-epub/fig-tot2-output-1.png){#fig-tot2}\n:::\n:::\n\n\nWe can extend this in to more advanced examples. Irrespective to the size of the data, for representation and aggregation tasks matrix models are best options and are used in industry as a standard. Let us consider an advanced example to analyse difference in stock prices. For this example we are using a simulated data. The python code for this simulation process is shown in [Fig @fig-sim].\n\n::: {#cell-fig-sim .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Simulated observed and predicted stock prices\nobserved_prices = np.random.uniform(100, 200, size=(100, 5))\npredicted_prices = np.random.uniform(95, 210, size=(100, 5))\n\n# Calculate the difference matrix\nprice_differences = observed_prices - predicted_prices\n\n# Visualization\nplt.imshow(price_differences, cmap='coolwarm', aspect='auto')\nplt.colorbar()\nplt.title('Stock Price Differences')\nplt.xlabel('Stock Index')\nplt.ylabel('Day Index')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Demonstration of Stock Price simulated from a Uniform Distribution](module_2_files/figure-epub/fig-sim-output-1.png){#fig-sim}\n:::\n:::\n\n\nAnother important matrix operation relevant to data analytics and Machine Learning application is scaling. This is considered as a statistical tool to make various features (attributes) in to same scale so as to avoid unnecessary misleading impact in data analysis and its intepretation. In Machine Learning context, this pre-processing stage is inevitable so as to make the model relevant and usable. \n\n**Simple Example: Normalizing Employee Performance Data**\n\n\n| Employee | Metric A   | Metric B   | \n|--------|--------------|------------|\n| X      | 80           | 700        | \n| Y      | 90           | 800        | \n| Z      |100           |900         |\n| A      |110           |1000        |\n| B      |120           |1100        |\n\n: Employee Performance Data {#tbl-EPD}\n\nUsing simple python code we can simulate the model for `min-max` scaling. The formula for `min-max` scaling is:\n$$min_max(X)=\\dfrac{X-min(X)}{max(X)-min(X)}$$\n\nFor example, while applying the `min-max` scaling in the first value of Metric A, the scaled value is \n$$min_max(80)\\dfrac{80-80}{120-80}=0$$ \n\nSimilarly\n\n$$min_max(100)\\dfrac{100-80}{120-80}=0.5$$\n\nWhen we apply this formula to Metric A and Metric B, the scaled output from @tbl-EPD will be as follows:\n\n| Employee | Metric A   | Metric B   | \n|--------|--------------|------------|\n| X      | 0.00         | 0.00       | \n| Y      | 0.25         | 0.25       | \n| Z      | 0.50         | 0.50       |\n| A      | 0.75         | 0.75       |\n| B      | 1.00         | 1.00       |\n\n: Employee Performance Data {#tbl-EPDu}\n\nIt is interesting to look into the scaled data! In the orginal table (@tbl-EPD) it is looked like Metric B is superior. But from the scaled table (@tbl-EPDu), it is clear that both the Metrics are representing same relative information. This will help us to identify the redundency in measure and so skip any one of the Metric before analysis!.\n\nThe same can be achieved through a matrix operation. The `Python` implementation of this scaling process is shown in [Fig @fig-totalsales].\n\n::: {#cell-fig-totalsales .cell execution_count=4}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Employee performance data with varying scales\ndata = np.array([[80, 700], [90, 800], [100, 900], [110, 1000], [120, 1100]])\n\n# Manual scaling\nmin_vals = np.min(data, axis=0)\nmax_vals = np.max(data, axis=0)\nscaled_data = (data - min_vals) / (max_vals - min_vals)\n\n# Visualization\nplt.figure(figsize=(8, 5))\nplt.subplot(1, 2, 1)\nplt.imshow(data, cmap='viridis')\nplt.title('Original Data')\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.imshow(scaled_data, cmap='viridis')\nplt.title('Scaled Data')\nplt.colorbar()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Total sales using `pandas` method](module_2_files/figure-epub/fig-totalsales-output-1.png){#fig-totalsales}\n:::\n:::\n\n\nFrom the first sub plot, it is clear that there is a significant difference in the distributions (Metric A and Metric B values). But the second sub plot shows that both the distributions have same pattern and the values ranges between 0 and 1. In short the visualization is more appealing and self explanatory in this case.\n\n:::{.callout-note}\nThe `min-max` scaling method will confine the feature values (attributes) into the range $[0,1]$. So in effect all the features are scaled proportionally to the data spectrum.\n:::\n\nSimilarly, we can use the `standard scaling` (transformation to normal distribution) using the transformation $\\dfrac{x-\\bar{x}}{\\sigma}$. Scaling table is given as a practice task to the reader. The python code for this operation is shown in [Fig @fig-minmax].\n\n::: {#cell-fig-minmax .cell execution_count=5}\n``` {.python .cell-code}\n# Standard scaling from scratch\ndef standard_scaling(data):\n    mean = np.mean(data, axis=0)\n    std = np.std(data, axis=0)\n    scaled_data = (data - mean) / std\n    return scaled_data\n\n# Apply standard scaling\nscaled_data_scratch = standard_scaling(data)\n\nprint(\"Standard Scaled Data (from scratch):\\n\", scaled_data_scratch)\n\n# Visualization\nplt.figure(figsize=(6, 5))\nplt.subplot(1, 2, 1)\nplt.imshow(data, cmap='viridis')\nplt.title('Original Data')\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.imshow(scaled_data_scratch, cmap='viridis')\nplt.title('Scaled Data')\nplt.colorbar()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStandard Scaled Data (from scratch):\n [[-1.41421356 -1.41421356]\n [-0.70710678 -0.70710678]\n [ 0.          0.        ]\n [ 0.70710678  0.70710678]\n [ 1.41421356  1.41421356]]\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![Min-max scaling using basic python](module_2_files/figure-epub/fig-minmax-output-2.png){#fig-minmax}\n:::\n:::\n\n\nTo understand the effect of standard scaling, let us consider [Fig @fig-comp1]. This plot create the frequency distribution of the data as a histogram along with the density function. From the first sub-plot, it is clear that the distribution has multiple modes (peaks). When we apply the standard scaling, the distribution become un-modal(only one peek). This is demonstrated in the second sub-plot.\n\n::: {#cell-fig-comp1 .cell execution_count=6}\n``` {.python .cell-code}\n# Standard scaling from scratch\nimport seaborn as sns\n# Create plots\nplt.figure(figsize=(6, 5))\n\n# Plot for original data\nplt.subplot(1, 2, 1)\nsns.histplot(data, kde=True, bins=10, palette=\"viridis\")\nplt.title('Original Data Distribution')\nplt.xlabel('Value')\nplt.ylabel('Frequency')\n\n# Plot for standard scaled data\nplt.subplot(1, 2, 2)\nsns.histplot(scaled_data_scratch, kde=True, bins=10, palette=\"viridis\")\nplt.title('Standard Scaled Data Distribution')\nplt.xlabel('Value')\nplt.ylabel('Frequency')\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Impact of standard scaling on the distribution](module_2_files/figure-epub/fig-comp1-output-1.png){#fig-comp1}\n:::\n:::\n\n\nA scatter plot showing the compare the impact of scaling on the given distribution is shown in [Fig @fig-scatter].\n\n::: {#cell-fig-scatter .cell execution_count=7}\n``` {.python .cell-code}\n# Plot original and scaled data\nplt.figure(figsize=(6, 5))\n\n# Original Data\nplt.subplot(1, 3, 1)\nplt.scatter(data[:, 0], data[:, 1], color='blue')\nplt.title('Original Data')\nplt.xlabel('Metric A')\nplt.ylabel('Metric B')\n\n# Standard Scaled Data\nplt.subplot(1, 3, 2)\nplt.scatter(scaled_data_scratch[:, 0], scaled_data_scratch[:, 1], color='green')\nplt.title('Standard Scaled Data')\nplt.xlabel('Metric A (Standard Scaled)')\nplt.ylabel('Metric B (Standard Scaled)')\n\n# Min-Max Scaled Data\nplt.subplot(1, 3, 3)\nplt.scatter(scaled_data[:, 0], scaled_data[:, 1], color='red')\nplt.title('Min-Max Scaled Data')\nplt.xlabel('Metric A (Min-Max Scaled)')\nplt.ylabel('Metric B (Min-Max Scaled)')\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Comparison of impact of scaling on the distribution](module_2_files/figure-epub/fig-scatter-output-1.png){#fig-scatter}\n:::\n:::\n\n\nFrom the [Fig @fig-scatter], it is clear that the scaling does not affect the pattern of the data, instead it just scale the distribution proportionally!\n\nWe can use the `scikit-learn` library for do the same thing in a very simple handy approach. The `python` code for this job is shown below.\n\n::: {#6984eeb5 .cell execution_count=8}\n``` {.python .cell-code}\nfrom sklearn.preprocessing import MinMaxScaler\n\n# Min-max scaling using sklearn\nscaler = MinMaxScaler()\nmin_max_scaled_data_sklearn = scaler.fit_transform(data)\n\nprint(\"Min-Max Scaled Data (using sklearn):\\n\", min_max_scaled_data_sklearn)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMin-Max Scaled Data (using sklearn):\n [[0.   0.  ]\n [0.25 0.25]\n [0.5  0.5 ]\n [0.75 0.75]\n [1.   1.  ]]\n```\n:::\n:::\n\n\n::: {#f3b39d5f .cell execution_count=9}\n``` {.python .cell-code}\nfrom sklearn.preprocessing import StandardScaler\n\n# Standard scaling using sklearn\nscaler = StandardScaler()\nscaled_data_sklearn = scaler.fit_transform(data)\n\nprint(\"Standard Scaled Data (using sklearn):\\n\", scaled_data_sklearn)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStandard Scaled Data (using sklearn):\n [[-1.41421356 -1.41421356]\n [-0.70710678 -0.70710678]\n [ 0.          0.        ]\n [ 0.70710678  0.70710678]\n [ 1.41421356  1.41421356]]\n```\n:::\n:::\n\n\nA scatter plot showing the impact on scaling is shown in [Fig @fig-comp2]. This plot compare the m`min-max` and `standard-scaling`.\n\n::: {#cell-fig-comp2 .cell execution_count=10}\n``` {.python .cell-code}\n# Plot original and scaled data\nplt.figure(figsize=(6, 5))\n\n# Original Data\nplt.subplot(1, 3, 1)\nplt.scatter(data[:, 0], data[:, 1], color='blue')\nplt.title('Original Data')\nplt.xlabel('Metric A')\nplt.ylabel('Metric B')\n\n# Standard Scaled Data\nplt.subplot(1, 3, 2)\nplt.scatter(scaled_data_sklearn[:, 0], scaled_data_sklearn[:, 1], color='green')\nplt.title('Standard Scaled Data')\nplt.xlabel('Metric A (Standard Scaled)')\nplt.ylabel('Metric B (Standard Scaled)')\n\n# Min-Max Scaled Data\nplt.subplot(1, 3, 3)\nplt.scatter(min_max_scaled_data_sklearn[:, 0], min_max_scaled_data_sklearn[:, 1], color='red')\nplt.title('Min-Max Scaled Data')\nplt.xlabel('Metric A (Min-Max Scaled)')\nplt.ylabel('Metric B (Min-Max Scaled)')\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Camparison of Min-max and standard  scalings with original data](module_2_files/figure-epub/fig-comp2-output-1.png){#fig-comp2}\n:::\n:::\n\n\n### More on Matrix Product and its Applications\n\nIn the first module of our course, we introduced matrix products as scalar projections, focusing on how matrices interact through basic operations. In this section, we will expand on this by exploring different types of matrix products that have practical importance in various fields. One such product is the *Hadamard product*, which is particularly useful in applications ranging from image processing to neural networks and statistical analysis. We will cover the definition, properties, and examples of the Hadamard product, and then delve into practical applications with simulated data.\n\n#### Hadamard Product\n\nThe Hadamard product (or element-wise product) of two matrices is a binary operation that combines two matrices of the same dimensions to produce another matrix of the same dimensions, where each element is the product of corresponding elements in the original matrices.\n\n:::{.callout-important}\n### Definition (Hadamard Product):\nFor two matrices $A$ and $B$ of the same dimension $m \\times n$, the Hadamard product $A \\circ B$ is defined as:\n\n$$(A \\circ B)_{ij} = A_{ij} \\cdot B_{ij}$$\n\nwhere $\\cdot$ denotes element-wise multiplication.\n:::\n\n::: {.callout-note}\n### Properties of Hadamard Product\n\n1.  **Commutativity**: \n  $$A \\circ B = B \\circ A$$\n  \n2.  **Associativity**: \n  $$(A \\circ B) \\circ C = A \\circ (B \\circ C)$$\n  \n3.  **Distributivity**: \n  $$A \\circ (B + C) = (A \\circ B) + (A \\circ C)$$\n:::\n\nSome simple examples to demonstrate the Hadamard product is given below.\n\nExample 1: Basic Hadamard Product\n\nGiven matrices:\n\n$$A = \\begin{pmatrix}\n1 & 2 \\\\\n3 & 4\n\\end{pmatrix}, \\quad\nB = \\begin{pmatrix}\n5 & 6 \\\\\n7 & 8\n\\end{pmatrix}$$\n\nThe Hadamard product $A \\circ B$ is:\n$$A \\circ B = \\begin{pmatrix}\n1 \\cdot 5 & 2 \\cdot 6 \\\\\n3 \\cdot 7 & 4 \\cdot 8\n\\end{pmatrix} = \\begin{pmatrix}\n5 & 12 \\\\\n21 & 32\n\\end{pmatrix}$$\n\nExample 2: Hadamard Product with Larger Matrices\n\nGiven matrices:\n\n$$A = \\begin{pmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{pmatrix}, \\quad\nB = \\begin{pmatrix}\n9 & 8 & 7 \\\\\n6 & 5 & 4 \\\\\n3 & 2 & 1\n\\end{pmatrix}$$\n\nThe Hadamard product $A \\circ B$ is:\n\n$$A \\circ B = \\begin{pmatrix}\n1 \\cdot 9 & 2 \\cdot 8 & 3 \\cdot 7 \\\\\n4 \\cdot 6 & 5 \\cdot 5 & 6 \\cdot 4 \\\\\n7 \\cdot 3 & 8 \\cdot 2 & 9 \\cdot 1\n\\end{pmatrix} = \\begin{pmatrix}\n9 & 16 & 21 \\\\\n24 & 25 & 24 \\\\\n21 & 16 & 9\n\\end{pmatrix}$$\n\nIn the following code chunks the computational process of Hadamard product is implemented in `Python`. Here both the from the scratch and use of external module versions are included.\n\n**1. Compute Hadamard Product from Scratch (without Libraries)**\n\nHere’s how you can compute the Hadamard product manually:\n\n::: {#c14c71b2 .cell execution_count=11}\n``` {.python .cell-code}\n# Define matrices A and B\nA = [[1, 2, 3], [4, 5, 6]]\nB = [[7, 8, 9], [10, 11, 12]]\n\n# Function to compute Hadamard product\ndef hadamard_product(A, B):\n    # Get the number of rows and columns\n    num_rows = len(A)\n    num_cols = len(A[0])\n    \n    # Initialize the result matrix\n    result = [[0]*num_cols for _ in range(num_rows)]\n    \n    # Compute the Hadamard product\n    for i in range(num_rows):\n        for j in range(num_cols):\n            result[i][j] = A[i][j] * B[i][j]\n    \n    return result\n\n# Compute Hadamard product\nhadamard_product_result = hadamard_product(A, B)\n\n# Display result\nprint(\"Hadamard Product (From Scratch):\")\nfor row in hadamard_product_result:\n    print(row)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHadamard Product (From Scratch):\n[7, 16, 27]\n[40, 55, 72]\n```\n:::\n:::\n\n\n**2. Compute Hadamard Product Using `SymPy`**\n\nHere’s how to compute the Hadamard product using `SymPy`:\n\n::: {#e6b16bd7 .cell execution_count=12}\n``` {.python .cell-code}\nimport sympy as sp\n\n# Define matrices A and B\nA = sp.Matrix([[1, 2, 3], [4, 5, 6]])\nB = sp.Matrix([[7, 8, 9], [10, 11, 12]])\n\n# Compute Hadamard product using SymPy\nHadamard_product_sympy = A.multiply_elementwise(B)\n\n# Display result\nprint(\"Hadamard Product (Using SymPy):\")\nprint(Hadamard_product_sympy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHadamard Product (Using SymPy):\nMatrix([[7, 16, 27], [40, 55, 72]])\n```\n:::\n:::\n\n\n**Practical Applications**\n\n*Application 1: Image Masking*\n\nThe Hadamard product can be used for image masking. Here’s how you can apply a mask to an image and visualize it as shown in [Fig @fig-imgmask].\n\n::: {#cell-fig-imgmask .cell execution_count=13}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Simulated large image (2D array) using NumPy\nimage = np.random.rand(100, 100)\n\n# Simulated mask (binary matrix) using NumPy\nmask = np.random.randint(0, 2, size=(100, 100))\n\n# Compute Hadamard product\nmasked_image = image * mask\n\n# Plot original image and masked image\nfig, ax = plt.subplots(1, 2, figsize=(12, 5))\nax[0].imshow(image, cmap='gray')\nax[0].set_title('Original Image')\nax[1].imshow(masked_image, cmap='gray')\nax[1].set_title('Masked Image')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Demonstration of Masking in DIP using Hadamard Product](module_2_files/figure-epub/fig-imgmask-output-1.png){#fig-imgmask}\n:::\n:::\n\n\nApplication 2: Element-wise Scaling in Neural Networks\n\nThe Hadamard product can be used for dropout^[A regularization techniques in Deep learning. This approach deactivate some selected neurons to control model over-fitting] in neural networks. A simple simulated example is given below.\n\n::: {#c870d2b9 .cell execution_count=14}\n``` {.python .cell-code}\n# Simulated large activations (2D array) using NumPy\nactivations = np.random.rand(100, 100)\n\n# Simulated dropout mask (binary matrix) using NumPy\ndropout_mask = np.random.randint(0, 2, size=(100, 100))\n\n# Apply dropout\ndropped_activations = activations * dropout_mask\n\n# Display results\nprint(\"Original Activations:\")\nprint(activations)\nprint(\"\\nDropout Mask:\")\nprint(dropout_mask)\nprint(\"\\nDropped Activations:\")\nprint(dropped_activations)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal Activations:\n[[0.95674559 0.8977341  0.6591733  ... 0.28189348 0.02726559 0.79371648]\n [0.83014234 0.07819155 0.02328147 ... 0.77434868 0.7450518  0.42546778]\n [0.80383871 0.88473019 0.81518602 ... 0.88066844 0.27654896 0.65653403]\n ...\n [0.17479878 0.81376878 0.89053112 ... 0.21905602 0.13765499 0.79591233]\n [0.61384776 0.93796571 0.39677021 ... 0.95072536 0.07811453 0.81123282]\n [0.59549353 0.99551457 0.83718469 ... 0.41100916 0.09769097 0.55417967]]\n\nDropout Mask:\n[[0 1 1 ... 1 0 1]\n [0 0 1 ... 0 0 0]\n [0 0 1 ... 1 1 1]\n ...\n [0 0 1 ... 1 1 1]\n [0 0 0 ... 0 1 1]\n [0 0 0 ... 0 0 0]]\n\nDropped Activations:\n[[0.         0.8977341  0.6591733  ... 0.28189348 0.         0.79371648]\n [0.         0.         0.02328147 ... 0.         0.         0.        ]\n [0.         0.         0.81518602 ... 0.88066844 0.27654896 0.65653403]\n ...\n [0.         0.         0.89053112 ... 0.21905602 0.13765499 0.79591233]\n [0.         0.         0.         ... 0.         0.07811453 0.81123282]\n [0.         0.         0.         ... 0.         0.         0.        ]]\n```\n:::\n:::\n\n\nApplication 3: Statistical Data Analysis\n\nIn statistics, the Hadamard product can be applied to scale covariance matrices. Here’s how we can compute the covariance matrix using matrix operations and apply scaling. Following `Python` code demonstrate this.\n\n::: {#3a5a3249 .cell execution_count=15}\n``` {.python .cell-code}\nimport sympy as sp\nimport numpy as np\n\n# Simulated large dataset (2D array) using NumPy\ndata = np.random.rand(100, 10)\n\n# Compute the mean of each column\nmean = np.mean(data, axis=0)\n\n# Center the data\ncentered_data = data - mean\n\n# Compute the covariance matrix using matrix product operation\ncov_matrix = (centered_data.T @ centered_data) / (centered_data.shape[0] - 1)\ncov_matrix_sympy = sp.Matrix(cov_matrix)\n\n# Simulated scaling factors (2D array) using SymPy Matrix\nscaling_factors = sp.Matrix(np.random.rand(10, 10))\n\n# Compute Hadamard product\nscaled_cov_matrix = cov_matrix_sympy.multiply(scaling_factors)\n\n# Display results\nprint(\"Covariance Matrix:\")\nprint(cov_matrix_sympy)\nprint(\"\\nScaling Factors:\")\nprint(scaling_factors)\nprint(\"\\nScaled Covariance Matrix:\")\nprint(scaled_cov_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCovariance Matrix:\nMatrix([[0.0668992208752821, 0.0231526200716858, 0.00154322187505562, -0.0146256113326536, -0.00636515012453383, -0.00669856746403596, -0.0130566536833750, 0.00243052207799565, -0.00255229797977480, 0.00696813420565906], [0.0231526200716858, 0.0778822031492130, -0.00220827681010537, 0.00215189195050298, -0.0153149498687200, -0.00704313191561015, -0.00423192926025612, -0.000263613920622562, 0.00276152635634300, -0.0116320296029952], [0.00154322187505562, -0.00220827681010537, 0.0813956488617807, 0.00178926357563656, -0.00800377423830852, -0.00509957520834449, -0.00340748700569602, 0.00477373485897835, -0.00638562595634084, -0.00282164593322884], [-0.0146256113326536, 0.00215189195050298, 0.00178926357563656, 0.0718103184708836, 0.00714586209865044, 0.00465090356863884, 0.00641755272699317, -0.00466823622943310, 0.00449619493896604, 0.00980174720720387], [-0.00636515012453383, -0.0153149498687200, -0.00800377423830852, 0.00714586209865044, 0.0887147042847554, 0.00171542710912210, 0.00893727186438121, -0.000530892491828907, -0.00593341328768673, -0.000922740467941842], [-0.00669856746403596, -0.00704313191561015, -0.00509957520834449, 0.00465090356863884, 0.00171542710912210, 0.0780486194866841, 0.00775936713631896, -0.00637143898567556, -0.00403019062114617, -0.0148054922024229], [-0.0130566536833750, -0.00423192926025612, -0.00340748700569602, 0.00641755272699317, 0.00893727186438121, 0.00775936713631896, 0.0822526883961524, -0.0104313546526364, 0.00799496071086879, 0.00113108460558624], [0.00243052207799565, -0.000263613920622562, 0.00477373485897835, -0.00466823622943310, -0.000530892491828907, -0.00637143898567556, -0.0104313546526364, 0.0819917477123810, 0.00908586128594000, -0.00213685399846404], [-0.00255229797977480, 0.00276152635634300, -0.00638562595634084, 0.00449619493896604, -0.00593341328768673, -0.00403019062114617, 0.00799496071086879, 0.00908586128594000, 0.0810689047714091, 0.0136902319653882], [0.00696813420565906, -0.0116320296029952, -0.00282164593322884, 0.00980174720720387, -0.000922740467941842, -0.0148054922024229, 0.00113108460558624, -0.00213685399846404, 0.0136902319653882, 0.0797160307516741]])\n\nScaling Factors:\nMatrix([[0.00198815991796342, 0.330146740539170, 0.104584456312967, 0.543838278074282, 0.897098198032631, 0.875422628277076, 0.668293619740225, 0.0996476675056602, 0.898261144480742, 0.250402749723411], [0.179775206512848, 0.0647659499552508, 0.371145902262706, 0.428019797786499, 0.814621447959128, 0.493216881271976, 0.574697124987882, 0.850068728806530, 0.798655518495765, 0.418750726602110], [0.773864836258602, 0.952861343561890, 0.111387798052280, 0.836921591567126, 0.00829393628525676, 0.0288593197938695, 0.793670196503602, 0.375946838983533, 0.438020837644463, 0.722880299373120], [0.848161704674662, 0.492377576664476, 0.310858534345612, 0.273795104714128, 0.841376197728887, 0.397553524367948, 0.181385076629560, 0.753878149325772, 0.342008393199567, 0.119648039848708], [0.0521996298558123, 0.497793242037775, 0.0517885376206041, 0.223482141288244, 0.224067795830768, 0.525786782926934, 0.651469105610508, 0.0546225325527274, 0.195625389379470, 0.142917923689598], [0.908468702196773, 0.651343270619794, 0.839154487992973, 0.320108963876482, 0.797987968866516, 0.0942415785022708, 0.155492068846397, 0.907724479826696, 0.821670941972436, 0.105178900970735], [0.630188222232266, 0.870490970730522, 0.188598891770126, 0.637271531162416, 0.902683089884723, 0.190228841472065, 0.377172319016186, 0.564316137991828, 0.669701419656006, 0.621052187291217], [0.941110439192956, 0.153954058249885, 0.801573244021160, 0.708658989047050, 0.476348890413695, 0.943701052074677, 0.950238661764229, 0.525563883902424, 0.189546704572368, 0.852703379413131], [0.610181343227098, 0.330230680222328, 0.788348794498472, 0.864391414472576, 0.0175671068690821, 0.00383322060617097, 0.721980456990477, 0.777813309294914, 0.0544843561361739, 0.0149076928064086], [0.880541600032598, 0.258662853151608, 0.687691128118503, 0.695828256493212, 0.632189573212067, 0.406978502161301, 0.329518394077942, 0.675578172183995, 0.218805892437208, 0.656497223454040]])\n\nScaled Covariance Matrix:\nMatrix([[-0.0146954545027412, 0.000291658971537895, 0.00752983801481814, 0.0360567207467232, 0.0535434494144494, 0.0628724638963662, 0.0492361223019654, 0.00610539819960796, 0.0606108632474756, 0.0226984852443858], [-0.00450679067271194, -0.00638921034600390, 0.0182149683928819, 0.0303996857460306, 0.0657042016325454, 0.0449795454495454, 0.0441108738960604, 0.0538375497707057, 0.0687049215082623, 0.0236940284732670], [0.0550265786345104, 0.0664305949952494, 0.000479987360124092, 0.0588130186270260, -0.00679465140192352, 0.00131724187888508, 0.0563918224578743, 0.0188726548036737, 0.0277891203760378, 0.0568416067847477], [0.0782726814748230, 0.0478478359045862, 0.0338176616299420, 0.0286999816034040, 0.0642240778753075, 0.0218750682686730, 0.0157469812518705, 0.0710799290178159, 0.0249465404543446, 0.0151415110278029], [0.00398995603663185, 0.0435775741308127, -0.00303818335815267, 0.00516491902346935, 0.0161339769098201, 0.0370916178959441, 0.0382287217507867, -0.00534600197811772, 0.00511304931131059, 0.00432515663193304], [0.0531107458802730, 0.0470665450024198, 0.0461442672857798, 0.00235924704394780, 0.0493288812213494, -0.00995632616115749, -0.00939073487766125, 0.0537678806871431, 0.0527103552412540, -0.00969615496591645], [0.0574270595199215, 0.0777582490141528, 0.0198852939016597, 0.0471972405983996, 0.0685398851486581, 0.000659715168600762, 0.0215868273506748, 0.0541069660218488, 0.0475087735921058, 0.0384066159825812], [0.0681282891291157, 0.00461152736985611, 0.0633111961047954, 0.0595913215793696, 0.0213234201365171, 0.0739565459805624, 0.0829112506287463, 0.0353097968353479, 0.00571089749438385, 0.0648133347045442], [0.0705029255021786, 0.0285577192375169, 0.0798712113523569, 0.0841996601210061, 0.0207683594398726, 0.0132089575879811, 0.0658272830401707, 0.0806918640264855, 0.00867028263225348, 0.0180763063789134], [0.0678026902835047, 0.0193780110289275, 0.0507855169353199, 0.0606962792524484, 0.0436168571555085, 0.0329915816844139, 0.0291550974123510, 0.0476632487371235, 0.00528050153945189, 0.0457356677193075]])\n```\n:::\n:::\n\n\n#### Practice Problems\n\n**Problem 1: Basic Hadamard Product**\n\nGiven matrices:\n$$A=\\begin{bmatrix}1&2\\\\3&4\\end{bmatrix}$$\n$$B=\\begin{bmatrix}5&6\\\\7&8\\end{bmatrix}$$\n\nFind the Hadamard product $C=A\\circ B$.\n\n**Solution:**\n\n$$C=\\begin{bmatrix}\n1\\cdot5&2\\cdot6\\\\\n3\\cdot7&4\\cdot8\n\\end{bmatrix}=\n\\begin{bmatrix}\n5&12\\\\\n21&32\n\\end{bmatrix}$$\n\n**Problem 2: Hadamard Product with Identity Matrix**\n\nGiven matrices:\n$$A=\\begin{bmatrix}1&2&3\\\\4&5&6\\end{bmatrix}$$\n$$I=\\begin{bmatrix}1&0&0\\\\0&1&0\\end{bmatrix}$$\n\nFind the Hadamard product $C=A\\circ I$.\n\n**Solution:**\n\n$$C=\\begin{bmatrix}\n1\\cdot1&2\\cdot0&3\\cdot0\\\\\n4\\cdot0&5\\cdot1&6\\cdot0\n\\end{bmatrix}=\n\\begin{bmatrix}\n1&0&0\\\\\n0&5&0\n\\end{bmatrix}$$\n\n**Problem 3: Hadamard Product with Zero Matrix**\n\nGiven matrices:\n$$A=\\begin{bmatrix}3&4\\\\5&6\\end{bmatrix}$$\n$$Z=\\begin{bmatrix}0&0\\\\0&0\\end{bmatrix}$$\n\nFind the Hadamard product $C=A\\circ Z$.\n\n**Solution:**\n\n$$C=\\begin{bmatrix}\n3\\cdot0&4\\cdot0\\\\\n5\\cdot0&6\\cdot0\n\\end{bmatrix}=\n\\begin{bmatrix}\n0&0\\\\\n0&0\n\\end{bmatrix}$$\n\n**Problem 4: Hadamard Product of Two Identity Matrices**\n\nGiven identity matrices:\n$$I_2=\\begin{bmatrix}1&0\\\\0&1\\end{bmatrix}$$\n$$I_3=\\begin{bmatrix}1&0&0\\\\0&1&0\\\\0&0&1\\end{bmatrix}$$\n\nFind the Hadamard product $C=I_2\\circ I_3$ (extend $I_2$ to match dimensions of $I_3$).\n\n**Solution:**\n\nExtend $I_2$ to $I_3$:\n$$I_2=\\begin{bmatrix}1&0&0\\\\0&1&0\\\\0&0&0\\end{bmatrix}$$\n\n$$C=\\begin{bmatrix}\n1\\cdot1&0\\cdot0&0\\cdot0\\\\\n0\\cdot0&1\\cdot1&0\\cdot0\\\\\n0\\cdot0&0\\cdot0&0\\cdot1\n\\end{bmatrix}=\n\\begin{bmatrix}\n1&0&0\\\\\n0&1&0\\\\\n0&0&0\n\\end{bmatrix}$$\n\n**Problem 5: Hadamard Product with Random Matrices**\n\nGiven random matrices:\n$$A=\\begin{bmatrix}2&3\\\\1&4\\end{bmatrix}$$\n$$B=\\begin{bmatrix}0&5\\\\6&2\\end{bmatrix}$$\n\nFind the Hadamard product $C=A\\circ B$.\n\n**Solution:**\n\n$$C=\\begin{bmatrix}\n2\\cdot0&3\\cdot5\\\\\n1\\cdot6&4\\cdot2\n\\end{bmatrix}=\n\\begin{bmatrix}\n0&15\\\\\n6&8\n\\end{bmatrix}$$\n\n**Problem 6: Hadamard Product of 3x3 Matrices**\n\nGiven matrices:\n$$A=\\begin{bmatrix}1&2&3\\\\4&5&6\\\\7&8&9\\end{bmatrix}$$\n$$B=\\begin{bmatrix}9&8&7\\\\6&5&4\\\\3&2&1\\end{bmatrix}$$\n\nFind the Hadamard product $C=A\\circ B$.\n\n**Solution:**\n\n$$C=\\begin{bmatrix}\n1\\cdot9&2\\cdot8&3\\cdot7\\\\\n4\\cdot6&5\\cdot5&6\\cdot4\\\\\n7\\cdot3&8\\cdot2&9\\cdot1\n\\end{bmatrix}=\n\\begin{bmatrix}\n9&16&21\\\\\n24&25&24\\\\\n21&16&9\n\\end{bmatrix}$$\n\n**Problem 7: Hadamard Product of Column Vectors**\n\nGiven column vectors:\n$$u=\\begin{bmatrix}2\\\\3\\end{bmatrix}$$\n$$v=\\begin{bmatrix}5\\\\6\\end{bmatrix}$$\n\nFind the Hadamard product $w=u\\circ v$.\n\n**Solution:**\n\n$$w=\\begin{bmatrix}\n2\\cdot5\\\\\n3\\cdot6\n\\end{bmatrix}=\n\\begin{bmatrix}\n10\\\\\n18\n\\end{bmatrix}$$\n\n**Problem 8: Hadamard Product with Non-Square Matrices**\n\nGiven matrices:\n$$A=\\begin{bmatrix}1&2\\\\3&4\\\\5&6\\end{bmatrix}$$\n$$B=\\begin{bmatrix}7&8\\\\9&10\\end{bmatrix}$$\n\nFind the Hadamard product $C=A\\circ B$ (extend $B$ to match dimensions of $A$).\n\n**Solution:**\n\nExtend $B$ to match dimensions of $A$:\n$$B=\\begin{bmatrix}7&8\\\\9&10\\\\7&8\\end{bmatrix}$$\n\n$$C=\\begin{bmatrix}\n1\\cdot7&2\\cdot8\\\\\n3\\cdot9&4\\cdot10\\\\\n5\\cdot7&6\\cdot8\n\\end{bmatrix}=\n\\begin{bmatrix}\n7&16\\\\\n27&40\\\\\n35&48\n\\end{bmatrix}$$\n\n**Problem 9: Hadamard Product in Image Processing**\n\nGiven matrices representing image pixel values:\n$$A=\\begin{bmatrix}10&20\\\\30&40\\end{bmatrix}$$\n$$B=\\begin{bmatrix}0.5&1.5\\\\2.0&0.5\\end{bmatrix}$$\n\nFind the Hadamard product $C=A\\circ B$.\n\n**Solution:**\n\n$$C=\\begin{bmatrix}\n10\\cdot0.5&20\\cdot1.5\\\\\n30\\cdot2.0&40\\cdot0.5\n\\end{bmatrix}=\n\\begin{bmatrix}\n5&30\\\\\n60&20\n\\end{bmatrix}$$\n\n**Problem 10: Hadamard Product in Statistical Data**\n\nGiven matrices representing two sets of statistical data:\n\n$$A=\\begin{bmatrix}5&6&7\\\\8&9&10\\end{bmatrix}$$\n$$B=\\begin{bmatrix}1&2&3\\\\4&5&6\\end{bmatrix}$$\n\nFind the Hadamard product $C=A\\circ B$.\n\n**Solution:**\n\n$$C=\\begin{bmatrix}\n5\\cdot1&6\\cdot2&7\\cdot3\\\\\n8\\cdot4&9\\cdot5&10\\cdot6\n\\end{bmatrix}=\n\\begin{bmatrix}\n5&12&21\\\\\n32&45&60\n\\end{bmatrix}$$\n\n#### Inner Product of Matrices\n\nThe inner product of two matrices is a generalized extension of the dot product, where each matrix is treated as a vector in a high-dimensional space. For two matrices $A$ and $B$ of the same dimension $m \\times n$, the inner product is defined as the sum of the element-wise products of the matrices.\n\n::: {.callout-important}\n### Definition (Inner product)\n\nFor two matrices $A$ and $B$ of dimension $m \\times n$, the inner product $\\langle A, B \\rangle$ is given by:\n\n$$\\langle A, B \\rangle = \\sum_{i=1}^{m} \\sum_{j=1}^{n} A_{ij} \\cdot B_{ij}$$\n\nwhere $\\cdot$ denotes element-wise multiplication.\n:::\n\n\n::: {.callout-important}\n### Properties\n\n1.  **Commutativity**: \n  $$\\langle A, B \\rangle = \\langle B, A \\rangle$$\n  \n2.  **Linearity**: \n  $$\\langle A + C, B \\rangle = \\langle A, B \\rangle + \\langle C, B \\rangle$$\n  \n3.  **Positive Definiteness**: \n  $$\\langle A, A \\rangle \\geq 0$$\n  with equality if and only if $A$ is a zero matrix.\n:::\n\n\nSome simple examples showing the mathematical process of calculating the inner product is given bellow.\n\n**Example 1: Basic Inner Product**\n\nGiven matrices:\n\n$$A = \\begin{pmatrix}\n1 & 2 \\\\\n3 & 4\n\\end{pmatrix}, \\quad\nB = \\begin{pmatrix}\n5 & 6 \\\\\n7 & 8\n\\end{pmatrix}$$\n\nThe inner product $\\langle A, B \\rangle$ is:\n\n$$\\langle A, B \\rangle = 1 \\cdot 5 + 2 \\cdot 6 + 3 \\cdot 7 + 4 \\cdot 8 = 5 + 12 + 21 + 32 = 70$$\n\n**Example 2: Inner Product with Larger Matrices**\n\nGiven matrices:\n\n$$A = \\begin{pmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{pmatrix}, \\quad\nB = \\begin{pmatrix}\n9 & 8 & 7 \\\\\n6 & 5 & 4 \\\\\n3 & 2 & 1\n\\end{pmatrix}$$\n\nThe inner product $\\langle A, B \\rangle$ is calculated as:\n\\begin{align*}\n\\langle A, B \\rangle &= 1 \\cdot 9 + 2 \\cdot 8 + 3 \\cdot 7 + 4 \\cdot 6 + 5 \\cdot 5 + 6 \\cdot 4 + 7 \\cdot 3 + 8 \\cdot 2 + 9 \\cdot 1\\\\\n&= 9 + 16 + 21 + 24 + 25 + 24 + 21 + 16 + 9\\\\\n&= 175\n\\end{align*}\n\nNow let's look into the computational part of *inner product*.\n\n1. Compute Inner Product from Scratch (without Libraries)\n\nHere’s how you can compute the inner product from the scratch:\n\n::: {#1f7890c7 .cell execution_count=16}\n``` {.python .cell-code}\n# Define matrices A and B\nA = [[1, 2, 3], [4, 5, 6]]\nB = [[7, 8, 9], [10, 11, 12]]\n\n# Function to compute inner product\ndef inner_product(A, B):\n    # Get the number of rows and columns\n    num_rows = len(A)\n    num_cols = len(A[0])\n    \n    # Initialize the result\n    result = 0\n    \n    # Compute the inner product\n    for i in range(num_rows):\n        for j in range(num_cols):\n            result += A[i][j] * B[i][j]\n    \n    return result\n\n# Compute inner product\ninner_product_result = inner_product(A, B)\n\n# Display result\nprint(\"Inner Product (From Scratch):\")\nprint(inner_product_result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInner Product (From Scratch):\n217\n```\n:::\n:::\n\n\n2. Compute Inner Product Using `NumPy`\n\nHere’s how to compute the inner product using Numpy:\n\n::: {#127d20f2 .cell execution_count=17}\n``` {.python .cell-code}\nimport numpy as np\n# Define matrices A and B\nA = np.array([[1, 2, 3], [4, 5, 6]])\nB = np.array([[7, 8, 9], [10, 11, 12]])\n# calculating innerproduct\ninner_product = (A*B).sum() # calculate element-wise product, then column sum\n\nprint(\"Inner Product (Using numpy):\")\nprint(inner_product)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInner Product (Using numpy):\n217\n```\n:::\n:::\n\n\nThe same operation can be done using `SymPy` functions as follows.\n\n::: {#cffec16b .cell execution_count=18}\n``` {.python .cell-code}\nimport sympy as sp\nimport numpy as np  \n# Define matrices A and B\nA = sp.Matrix([[1, 2, 3], [4, 5, 6]])\nB = sp.Matrix([[7, 8, 9], [10, 11, 12]])\n\n# Compute element-wise product\nelementwise_product = A.multiply_elementwise(B)\n\n# Calculate sum of each column\ninner_product_sympy = np.sum(elementwise_product)\n\n# Display result\nprint(\"Inner Product (Using SymPy):\")\nprint(inner_product_sympy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInner Product (Using SymPy):\n217\n```\n:::\n:::\n\n\nA vector dot product (in Physics) can be calculated using `SymPy` `.dot()` function as shown below. \n\nLet $A=\\begin{pmatrix}1&2&3\\end{pmatrix}$ and $B=\\begin{pmatrix}4&5&6\\end{pmatrix}$, then the dot product, $A\\cdot B$ is computed as:\n\n::: {#6089b67e .cell execution_count=19}\n``` {.python .cell-code}\nimport sympy as sp\nA=sp.Matrix([1,2,3])\nB=sp.Matrix([4,5,6])\ndisplay(A.dot(B)) # calculate fot product of A and B\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown}\n$\\displaystyle 32$\n:::\n:::\n\n\n:::{.callout-warning}\n## A word of caution\nIn `SymPy` , `sp.Matrix([1,2,3])` create a column vector. But `np.array([1,2,3])` creates a row vector. So be careful while applying matrix/ dot product operations on these objects.\n:::\n\nThe same dot product using `numpy` object can be done as follows:\n\n::: {#65fa03ef .cell execution_count=20}\n``` {.python .cell-code}\nimport numpy as np\nA=np.array([1,2,3])\nB=np.array([4,5,6])\ndisplay(A.dot(B.T))# dot() stands for dot product B.T represents the transpose of B\n```\n\n::: {.cell-output .cell-output-display}\n```\nnp.int64(32)\n```\n:::\n:::\n\n\n**Practical Applications**\n\nApplication 1: Signal Processing\n\nIn signal processing, the inner product can be used to measure the similarity between two signals. Here the most popular measure of similarity is the `cosine` similarity. This measure is defined as:\n\n$$\\cos \\theta=\\dfrac{A\\cdot B}{||A|| ||B||}$$\n\nNow consider two digital signals are given. It's cosine similarity measure can be calculated with a simulated data as shown below.\n\n::: {#6704d7d5 .cell execution_count=21}\n``` {.python .cell-code}\nimport numpy as np\n\n# Simulated large signals (1D array) using NumPy\nsignal1 = np.sin(np.random.rand(1000))\nsignal2 = np.cos(np.random.rand(1000))\n\n# Compute inner product\ninner_product_signal = np.dot(signal1, signal2)\n#cosine_sim=np.dot(signal1,signal2)/(np.linalg.norm(signal1)*np.linalg.norm(signal2))\n# Display result\ncosine_sim=inner_product_signal/(np.sqrt(np.dot(signal1,signal1))*np.sqrt(np.dot(signal2,signal2)))\nprint(\"Inner Product (Using numpy):\")\nprint(inner_product_signal)\nprint(\"Similarity of signals:\")\nprint(cosine_sim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInner Product (Using numpy):\n393.66751133850624\nSimilarity of signals:\n0.877255220102341\n```\n:::\n:::\n\n\nApplication 2: Machine Learning - Feature Similarity\n\nIn machine learning, the inner product is used to calculate the similarity between feature vectors.\n\n::: {#510f49ec .cell execution_count=22}\n``` {.python .cell-code}\nimport numpy as np\n\n# Simulated feature vectors (2D array) using NumPy\nfeatures1 = np.random.rand(100, 10)\nfeatures2 = np.random.rand(100, 10)\n\n# Compute inner product for each feature vector\ninner_products = np.einsum('ij,ij->i', features1, features2) # use Einstien's sum\n\n# Display results\nprint(\"Inner Products of Feature Vectors:\")\ndisplay(inner_products)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInner Products of Feature Vectors:\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```\narray([1.32125158, 3.08930528, 3.06127363, 3.32783869, 3.48957507,\n       2.37847051, 2.68643297, 2.36247254, 2.33411246, 4.00755663,\n       2.31483087, 1.97569137, 3.03392836, 4.05261412, 3.71078458,\n       2.65314046, 2.05884485, 1.72618725, 2.15469622, 1.753202  ,\n       2.02037306, 1.6036377 , 3.2126779 , 2.24876131, 1.84152267,\n       3.41150214, 2.65147987, 3.40154203, 2.70887853, 2.57856013,\n       3.31011054, 1.8316361 , 1.50502306, 3.66219957, 2.72933327,\n       3.1467072 , 1.55087095, 1.92331354, 3.6988074 , 2.17828226,\n       2.48064129, 1.7994148 , 2.8441924 , 2.97497912, 4.10366145,\n       2.73930223, 2.39366648, 3.45920682, 3.50046537, 2.28277138,\n       2.74081667, 1.96520034, 2.72763798, 2.43225053, 1.51396413,\n       2.25162211, 2.42029047, 3.57359794, 3.03889426, 1.87324224,\n       1.40126451, 2.86394632, 2.31786427, 2.70852227, 2.39280399,\n       1.86584755, 0.58549252, 2.89346558, 3.54246857, 2.35303812,\n       2.64231698, 2.33856585, 1.36919208, 2.74685848, 2.53445165,\n       2.45700526, 2.62727037, 2.47537626, 2.43257179, 2.70047486,\n       2.85539249, 3.39910953, 2.7563934 , 2.27495201, 1.41575169,\n       1.66881984, 1.29104619, 1.51327116, 2.32285093, 1.79160177,\n       3.69947473, 3.1128937 , 1.24506993, 1.31459004, 3.74844099,\n       1.69901548, 2.40729289, 1.5569236 , 2.31208467, 1.53396872])\n```\n:::\n:::\n\n\nApplication 3: Covariance Matrix in Statistics\n\nThe inner product can be used to compute covariance matrices for statistical data analysis. If $X$ is a given distribution and $x=X-\\bar{X}$. Then the covariance of $X$ can be calculated as $cov(X)=\\dfrac{1}{n-1}(x\\cdot x^T)$ ^[Remember that the covariance of $X$ is defined as $Cov(X)=\\dfrac{\\sum (X-\\bar{X})^2}{n-1}$]. The python code a simulated data is shown below.\n\n::: {#89af22ae .cell execution_count=23}\n``` {.python .cell-code}\nimport sympy as sp\nimport numpy as np\n\n# Simulated large dataset (2D array) using NumPy\ndata = np.random.rand(100, 10)\n\n# Compute the mean of each column\nmean = np.mean(data, axis=0)\n\n# Center the data\ncentered_data = data - mean\n\n# Compute the covariance matrix using matrix product operation\ncov_matrix = (centered_data.T @ centered_data) / (centered_data.shape[0] - 1)\ncov_matrix_sympy = sp.Matrix(cov_matrix)\n\n# Display results\nprint(\"Covariance Matrix:\")\ndisplay(cov_matrix_sympy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCovariance Matrix:\n```\n:::\n\n::: {.cell-output .cell-output-display .cell-output-markdown}\n$\\displaystyle \\left[\\begin{matrix}0.092859432455806 & -0.00892514540956426 & 0.00800322374693364 & -0.00326086842290567 & 0.00896792629055868 & 0.00397171104267784 & -0.0145346804128874 & 0.007677009960847 & -0.00290350928069988 & 0.0129320174988748\\\\-0.00892514540956426 & 0.0763017078758014 & -0.00716270675043326 & -0.00502236852032592 & 0.010971508514071 & 0.00142670411078779 & -0.00511061351321378 & -0.000954677052047351 & -0.00871567993331217 & -0.0140893509047609\\\\0.00800322374693364 & -0.00716270675043326 & 0.0797688092280137 & 0.000569576428057195 & 0.0152367510386388 & 0.00615953073122207 & -0.0112246718888223 & 0.0106305287863417 & 0.0143384201041129 & 0.00289386171750357\\\\-0.00326086842290567 & -0.00502236852032592 & 0.000569576428057195 & 0.0816764031724086 & 0.00203922240562794 & 0.00371133846672395 & 0.00983583708345986 & 0.00837192892930223 & -0.00163865726626009 & -0.00156618765249662\\\\0.00896792629055868 & 0.010971508514071 & 0.0152367510386388 & 0.00203922240562794 & 0.0814567884538848 & -0.00520061275575775 & 0.000677678239690116 & 0.00157568194147207 & 0.0104580338957691 & -0.0113682248681441\\\\0.00397171104267784 & 0.00142670411078779 & 0.00615953073122207 & 0.00371133846672395 & -0.00520061275575775 & 0.0865750442841858 & -0.00181927976605309 & -0.0020070769667137 & -0.00808634833890603 & 0.0100099638559936\\\\-0.0145346804128874 & -0.00511061351321378 & -0.0112246718888223 & 0.00983583708345986 & 0.000677678239690116 & -0.00181927976605309 & 0.0755213947388462 & 0.00513834983380899 & -0.00612233130666787 & -0.0120555754638551\\\\0.007677009960847 & -0.000954677052047351 & 0.0106305287863417 & 0.00837192892930223 & 0.00157568194147207 & -0.0020070769667137 & 0.00513834983380899 & 0.0826465362452921 & 0.00314087672528021 & 0.0100228397571603\\\\-0.00290350928069988 & -0.00871567993331217 & 0.0143384201041129 & -0.00163865726626009 & 0.0104580338957691 & -0.00808634833890603 & -0.00612233130666787 & 0.00314087672528021 & 0.0906006526227422 & 0.00439264445474417\\\\0.0129320174988748 & -0.0140893509047609 & 0.00289386171750357 & -0.00156618765249662 & -0.0113682248681441 & 0.0100099638559936 & -0.0120555754638551 & 0.0100228397571603 & 0.00439264445474417 & 0.0856544861427362\\end{matrix}\\right]$\n:::\n:::\n\n\nThese examples demonstrate the use of inner product and dot product in various applications.\n\n#### Outer Product\n\nThe outer product of two vectors results in a matrix, and it is a way to combine these vectors into a higher-dimensional representation.\n\n:::{.callout-note}\n\n### Definition (Outer Product)\n\nFor two vectors $\\mathbf{u}$ and $\\mathbf{v}$ of dimensions $m$ and $n$ respectively, the outer product $\\mathbf{u} \\otimes \\mathbf{v}$ is an $m \\times n$ matrix defined as:\n\n$$(\\mathbf{u} \\otimes \\mathbf{v})_{ij} = u_i \\cdot v_j$$\n\nwhere $\\cdot$ denotes the outer product operation. In matrix notation, for two column vectors $u,v$, \n$$u\\otimes v=uv^T$$\n:::\n\n\n:::{.callout-note}\n### Properties\n\n1.  **Linearity**:\n  $$(\\mathbf{u} + \\mathbf{w}) \\otimes \\mathbf{v} = (\\mathbf{u} \\otimes \\mathbf{v}) + (\\mathbf{w} \\otimes \\mathbf{v})$$\n  \n2.  **Distributivity**:\n  $$\\mathbf{u} \\otimes (\\mathbf{v} + \\mathbf{w}) = (\\mathbf{u} \\otimes \\mathbf{v}) + (\\mathbf{u} \\otimes \\mathbf{w})$$\n  \n3.  **Associativity**:\n  $$(\\mathbf{u} \\otimes \\mathbf{v}) \\otimes \\mathbf{w} = \\mathbf{u} \\otimes (\\mathbf{v} \\otimes \\mathbf{w})$$\n\n:::\n\nSome simple examples of outer product is given below.\n\n**Example 1: Basic Outer Product**\n\nGiven vectors:\n\n$$\\mathbf{u} = \\begin{pmatrix}\n1 \\\\\n2\n\\end{pmatrix}, \\quad\n\\mathbf{v} = \\begin{pmatrix}\n3 \\\\\n4 \\\\\n5\\end{pmatrix}$$\n\nThe outer product $\\mathbf{u} \\otimes \\mathbf{v}$ is:\n\n$$\\mathbf{u} \\otimes \\mathbf{v} = \\begin{pmatrix}\n1 \\cdot 3 & 1 \\cdot 4 & 1 \\cdot 5 \\\\\n2 \\cdot 3 & 2 \\cdot 4 & 2 \\cdot 5\n\\end{pmatrix} = \\begin{pmatrix}\n3 & 4 & 5 \\\\\n6 & 8 & 10\n\\end{pmatrix}$$\n\n**Example 2: Outer Product with Larger Vectors**\n\nGiven vectors:\n$$\\mathbf{u} = \\begin{pmatrix}\n1 \\\\\n2 \\\\\n3\n\\end{pmatrix}, \\quad\n\\mathbf{v} = \\begin{pmatrix}\n4 \\\\\n5\n\\end{pmatrix}$$\n\nThe outer product $\\mathbf{u} \\otimes \\mathbf{v}$ is:\n\n$$\\mathbf{u} \\otimes \\mathbf{v} = \\begin{pmatrix}\n1 \\cdot 4 & 1 \\cdot 5 \\\\\n2 \\cdot 4 & 2 \\cdot 5 \\\\\n3 \\cdot 4 & 3 \\cdot 5\n\\end{pmatrix} = \\begin{pmatrix}\n4 & 5 \\\\\n8 & 10 \\\\\n12 & 15\n\\end{pmatrix}$$\n\n**1. Compute Outer Product of Vectors from Scratch (without Libraries)**\n\nHere’s how you can compute the outer product manually:\n\n::: {#ea8588ad .cell execution_count=24}\n``` {.python .cell-code}\n# Define vectors u and v\nu = [1, 2]\nv = [3, 4, 5]\n\n# Function to compute outer product\ndef outer_product(u, v):\n    # Initialize the result\n    result = [[a * b for b in v] for a in u]\n    return result\n\n# Compute outer product\nouter_product_result = outer_product(u, v)\n\n# Display result\nprint(\"Outer Product of Vectors (From Scratch):\")\nfor row in outer_product_result:\n    print(row)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOuter Product of Vectors (From Scratch):\n[3, 4, 5]\n[6, 8, 10]\n```\n:::\n:::\n\n\n**2. Compute Outer Product of Vectors Using SymPy**\n\nHere’s how to compute the outer product using `SymPy`:\n\n::: {#c12612c6 .cell execution_count=25}\n``` {.python .cell-code}\nimport sympy as sp\n\n# Define vectors u and v\nu = sp.Matrix([1, 2])\nv = sp.Matrix([3, 4, 5])\n\n# Compute outer product using SymPy\nouter_product_sympy = u * v.T\n\n# Display result\nprint(\"Outer Product of Vectors (Using SymPy):\")\ndisplay(outer_product_sympy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOuter Product of Vectors (Using SymPy):\n```\n:::\n\n::: {.cell-output .cell-output-display .cell-output-markdown}\n$\\displaystyle \\left[\\begin{matrix}3 & 4 & 5\\\\6 & 8 & 10\\end{matrix}\\right]$\n:::\n:::\n\n\n**Outer Product of Matrices**\n \nThe outer product of two matrices extends the concept from vectors to higher-dimensional tensors. For two matrices $A$ and $B$, the outer product results in a higher-dimensional tensor and is generally expressed as block matrices.\n\n:::{.callout-note}\n### Definition (Outer Product of Matrices)\n\nFor two matrices $A$ of dimension $m \\times p$ and $B$ of dimension $q \\times n$, the outer product $A \\otimes B$ results in a tensor of dimension $m \\times q \\times p \\times n$. The entries of the tensor are given by:\n\n$$(A \\otimes B)_{ijkl} = A_{ij} \\cdot B_{kl}$$\n\nwhere $\\cdot$ denotes the outer product operation.\n:::\n\n:::{.callout-note}\n\n### Properties\n\n1.  **Linearity**:\n  $$(A + C) \\otimes B = (A \\otimes B) + (C \\otimes B)$$\n  \n2.  **Distributivity**:\n  $$A \\otimes (B + D) = (A \\otimes B) + (A \\otimes D)$$\n  \n3. **Associativity**:\n\n  $$(A \\otimes B) \\otimes C = A \\otimes (B \\otimes C)$$\n:::\n\nHere are some simple examples to demonstrate the mathematical procedure to find outer product of matrices.\n\n**Example 1: Basic Outer Product of Matrices**\n\nGiven matrices:\n$$\nA = \\begin{pmatrix}\n1 & 2 \\\\\n3 & 4\n\\end{pmatrix}, \\quad\nB = \\begin{pmatrix}\n5 \\\\\n6\n\\end{pmatrix}$$\n\nThe outer product $A \\otimes B$ is:\n\n$$A \\otimes B = \\begin{pmatrix}\n1 \\cdot 5 & 1 \\cdot 6 \\\\\n2 \\cdot 5 & 2 \\cdot 6 \\\\\n3 \\cdot 5 & 3 \\cdot 6 \\\\\n4 \\cdot 5 & 4 \\cdot 6\n\\end{pmatrix} = \\begin{pmatrix}\n5 & 6 \\\\\n10 & 12 \\\\\n15 & 18 \\\\\n20 & 24\n\\end{pmatrix}$$\n\n**Example 2: Outer Product with Larger Matrices**\n\nGiven matrices:\n\n$$A = \\begin{pmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6\n\\end{pmatrix}, \\quad\nB = \\begin{pmatrix}\n7 \\\\\n8\n\\end{pmatrix}$$\n\nThe outer product $A \\otimes B$ is:\n\n$$A \\otimes B = \\begin{pmatrix}\n1 \\cdot 7 & 1 \\cdot 8 \\\\\n2 \\cdot 7 & 2 \\cdot 8 \\\\\n3 \\cdot 7 & 3 \\cdot 8 \\\\\n4 \\cdot 7 & 4 \\cdot 8 \\\\\n5 \\cdot 7 & 5 \\cdot 8 \\\\\n6 \\cdot 7 & 6 \\cdot 8\n\\end{pmatrix} = \\begin{pmatrix}\n7 & 8 \\\\\n14 & 16 \\\\\n21 & 24 \\\\\n28 & 32 \\\\\n35 & 40 \\\\\n42 & 48\n\\end{pmatrix}$$\n\nExample 3: Compute the outer product of the following vectors $\\mathbf{u} = [0, 1, 2]$ and $\\mathbf{v} = [2, 3, 4]$.\n\nTo find the outer product, we calculate each element $(i, j)$ as the product of the $(i)$-th element of $\\mathbf{u}$ and the $(j)$-th element of $\\mathbf{v}$. Mathematically:\n\n$$\\mathbf{u} \\otimes \\mathbf{v} = \\begin{bmatrix}\n0 \\cdot 2 & 0 \\cdot 3 & 0 \\cdot 4 \\\\\n1 \\cdot 2 & 1 \\cdot 3 & 1 \\cdot 4 \\\\\n2 \\cdot 2 & 2 \\cdot 3 & 2 \\cdot 4\n\\end{bmatrix}\n= \\begin{bmatrix}\n0 & 0 & 0 \\\\\n2 & 3 & 4 \\\\\n4 & 6 & 8\n\\end{bmatrix}$$\n\n**1. Compute Outer Product of Matrices from Scratch (without Libraries)**\n\nHere’s how you can compute the outer product manually:\n\n::: {#8df254fa .cell execution_count=26}\n``` {.python .cell-code}\n# Define matrices A and B\nA = [[1, 2], [3, 4]]\nB = [[5], [6]]\n\n# Function to compute outer product\ndef outer_product_matrices(A, B):\n    m = len(A)\n    p = len(A[0])\n    q = len(B)\n    n = len(B[0])\n    result = [[0] * (n * p) for _ in range(m * q)]\n\n    for i in range(m):\n        for j in range(p):\n            for k in range(q):\n                for l in range(n):\n                    result[i*q + k][j*n + l] = A[i][j] * B[k][l]\n\n    return result\n\n# Compute outer product\nouter_product_result_matrices = outer_product_matrices(A, B)\n\n# Display result\nprint(\"Outer Product of Matrices (From Scratch):\")\nfor row in outer_product_result_matrices:\n    print(row)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOuter Product of Matrices (From Scratch):\n[5, 10]\n[6, 12]\n[15, 20]\n[18, 24]\n```\n:::\n:::\n\n\nHere is the `Python` code to compute the outer product of these vectors using the `NumPy` function `.outer()`:\n\n::: {#b398be02 .cell execution_count=27}\n``` {.python .cell-code}\nimport numpy as np\n\n# Define vectors\nu = np.array([[1,2],[3,4]])\nv = np.array([[5],[4]])\n\n# Compute outer product\nouter_product = np.outer(u, v)\n\nprint(\"Outer Product of u and v:\")\ndisplay(outer_product)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOuter Product of u and v:\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```\narray([[ 5,  4],\n       [10,  8],\n       [15, 12],\n       [20, 16]])\n```\n:::\n:::\n\n\n**Example 3: Real-world Application in Recommendation Systems**\n\nIn recommendation systems, the outer product can represent user-item interactions. A simple context is here. Let the user preferences of items is given as $u=[4, 3, 5]$ and the item scores is given by $v=[2, 5, 4]$. Now the recommendation score can be calculated as the outer product of these two vectors. Calculation of this score is shown below.\nThe outer product $\\mathbf{u} \\otimes \\mathbf{v}$ is calculated as follows:\n\n$$\\mathbf{u} \\otimes \\mathbf{v} = \\begin{bmatrix}\n4 \\cdot 2 & 4 \\cdot 5 & 4 \\cdot 4 \\\\\n3 \\cdot 2 & 3 \\cdot 5 & 3 \\cdot 4 \\\\\n5 \\cdot 2 & 5 \\cdot 5 & 5 \\cdot 4\n\\end{bmatrix}\n= \\begin{bmatrix}\n8 & 20 & 16 \\\\\n6 & 15 & 12 \\\\\n10 & 25 & 20\n\\end{bmatrix}$$\n\nThe python code for this task is given below.\n\n::: {#235f5bdb .cell execution_count=28}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the user and product ratings vectors\nuser_ratings = np.array([4, 3, 5])\nproduct_ratings = np.array([2, 5, 4])\n\n# Compute the outer product\npredicted_ratings = np.outer(user_ratings, product_ratings)\n\n# Print the predicted ratings matrix\nprint(\"Predicted Ratings Matrix:\")\ndisplay(predicted_ratings)\n\n# Plot the result\nplt.imshow(predicted_ratings, cmap='coolwarm', interpolation='nearest')\nplt.colorbar()\nplt.title('Predicted Ratings Matrix (Recommendation System)')\nplt.xlabel('Product Ratings')\nplt.ylabel('User Ratings')\nplt.xticks(ticks=np.arange(len(product_ratings)), labels=product_ratings)\nplt.yticks(ticks=np.arange(len(user_ratings)), labels=user_ratings)\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPredicted Ratings Matrix:\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```\narray([[ 8, 20, 16],\n       [ 6, 15, 12],\n       [10, 25, 20]])\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](module_2_files/figure-epub/cell-29-output-3.png){}\n:::\n:::\n\n\n:::{.callout-note}\n### Additional Properties & Definitions\n\n1. **Definition and Properties**\n\n   Given two vectors:\n   - $\\mathbf{u} \\in \\mathbb{R}^m$\n   - $\\mathbf{v} \\in \\mathbb{R}^n$\n\n   The outer product $\\mathbf{u} \\otimes \\mathbf{v}$ results in an $m \\times n$ matrix where each element $(i, j)$ of the matrix is calculated as:\n   $$(\\mathbf{u} \\otimes \\mathbf{v})_{ij} = u_i \\cdot v_j$$\n\n2. **Non-Symmetry**\n\n   The outer product is generally not symmetric. For vectors $\\mathbf{u}$ and $\\mathbf{v}$, the matrix $\\mathbf{u} \\otimes \\mathbf{v}$ is not necessarily equal to $\\mathbf{v} \\otimes \\mathbf{u}$:\n   $$\\mathbf{u} \\otimes \\mathbf{v} \\neq \\mathbf{v} \\otimes \\mathbf{u}$$\n\n3. **Rank of the Outer Product**\n\n   The rank of the outer product matrix $\\mathbf{u} \\otimes \\mathbf{v}$ is always 1, provided neither $\\mathbf{u}$ nor $\\mathbf{v}$ is a zero vector. This is because the matrix can be expressed as a single rank-1 matrix.\n\n4. **Distributive Property**\n\n   The outer product is distributive over vector addition. For vectors $\\mathbf{u}_1, \\mathbf{u}_2 \\in \\mathbb{R}^m$ and $\\mathbf{v} \\in \\mathbb{R}^n$:\n   $$(\\mathbf{u}_1 + \\mathbf{u}_2) \\otimes \\mathbf{v} = (\\mathbf{u}_1 \\otimes \\mathbf{v}) + (\\mathbf{u}_2 \\otimes \\mathbf{v})$$\n\n5. **Associativity with Scalar Multiplication**\n\n   The outer product is associative with scalar multiplication. For a scalar $\\alpha$ and vectors $\\mathbf{u} \\in \\mathbb{R}^m$ and $\\mathbf{v} \\in \\mathbb{R}^n$:\n   $$\\alpha (\\mathbf{u} \\otimes \\mathbf{v}) = (\\alpha \\mathbf{u}) \\otimes \\mathbf{v} = \\mathbf{u} \\otimes (\\alpha \\mathbf{v})$$\n\n6. **Matrix Trace**\n\n   The trace of the outer product of two vectors is given by:\n   $$\\text{tr}(\\mathbf{u} \\otimes \\mathbf{v}) = (\\mathbf{u}^T \\mathbf{v}) \\cdot (\\mathbf{v}^T \\mathbf{u})$$\n   Here, $\\text{tr}$ denotes the trace of a matrix, which is the sum of its diagonal elements.\n\n7. **Matrix Norm**\n\n   The Frobenius norm of the outer product matrix can be expressed in terms of the norms of the original vectors:\n   $$\\| \\mathbf{u} \\otimes \\mathbf{v} \\|_F = \\| \\mathbf{u} \\|_2 \\cdot \\| \\mathbf{v} \\|_2$$\n   where $\\| \\cdot \\|_2$ denotes the Euclidean norm.\n\n:::\n\n**Example Calculation in `Python`**\n\nHere’s how to compute and visualize the outer product properties using `Python`:\n\n::: {#cell-fig-op .cell execution_count=29}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define vectors\nu = np.array([1, 2, 3])\nv = np.array([4, 5])\n\n# Compute outer product\nouter_product = np.outer(u, v)\n\n# Display results\nprint(\"Outer Product Matrix:\")\nprint(outer_product)\n\n# Compute and display rank\nrank = np.linalg.matrix_rank(outer_product)\nprint(f\"Rank of Outer Product Matrix: {rank}\")\n\n# Compute Frobenius norm\nfrobenius_norm = np.linalg.norm(outer_product, 'fro')\nprint(f\"Frobenius Norm: {frobenius_norm}\")\n\n# Plot the result\nplt.imshow(outer_product, cmap='viridis', interpolation='nearest')\nplt.colorbar()\nplt.title('Outer Product Matrix')\nplt.xlabel('Vector v')\nplt.ylabel('Vector u')\nplt.xticks(ticks=np.arange(len(v)), labels=v)\nplt.yticks(ticks=np.arange(len(u)), labels=u)\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOuter Product Matrix:\n[[ 4  5]\n [ 8 10]\n [12 15]]\nRank of Outer Product Matrix: 1\nFrobenius Norm: 23.958297101421877\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![Demonstration of Outer Product and its Properties](module_2_files/figure-epub/fig-op-output-2.png){#fig-op}\n:::\n:::\n\n\n#### Kronecker Product\n\nIn mathematics, the Kronecker product, sometimes denoted by $\\otimes$, is an operation on two matrices of arbitrary size resulting in a *block matrix*. It is a specialization of the tensor product (which is denoted by the same symbol) from vectors to matrices and gives the matrix of the tensor product linear map with respect to a standard choice of basis. The Kronecker product is to be distinguished from the usual matrix multiplication, which is an entirely different operation. The Kronecker product is also sometimes called *matrix direct product*.\n\n:::{.callout-note}\nIf $A$ is an $m \\times n$ matrix and $B$ is a $p \\times q$ matrix, then the Kronecker product $A\\otimes B$ is the $pm \\times qn$ block matrix defined as: Each\n$a_{ij}$ of $A$ is replaced by the matrix $a_{ij}B$. Symbolically this will result in a block matrix defined by:\n\n$$A\\otimes B=\\begin{bmatrix}A \\otimes B = \\begin{bmatrix}\na_{11}B & a_{12}B & \\cdots & a_{1n}B \\\\\na_{21}B & a_{22}B & \\cdots & a_{2n}B \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m1}B & a_{m2}B & \\cdots & a_{mn}B\n\\end{bmatrix} \\end{bmatrix}$$\n:::\n\n:::{.callout-note}\n\n#### Properties of the Kronecker Product\n\n1. **Associativity**\n\n   The Kronecker product is associative. For matrices $A \\in \\mathbb{R}^{m \\times n}$, $B \\in \\mathbb{R}^{p \\times q}$, and $C \\in \\mathbb{R}^{r \\times s}$:\n   $$(A \\otimes B) \\otimes C = A \\otimes (B \\otimes C)$$\n\n2. **Distributivity Over Addition**\n\n   The Kronecker product distributes over matrix addition. For matrices $A \\in \\mathbb{R}^{m \\times n}$, $B \\in \\mathbb{R}^{p \\times q}$, and $C \\in \\mathbb{R}^{p \\times q}$:\n   $$A \\otimes (B + C) = (A \\otimes B) + (A \\otimes C)$$\n\n3. **Mixed Product Property**\n\n   The Kronecker product satisfies the mixed product property with the matrix product. For matrices $A \\in \\mathbb{R}^{m \\times n}$, $B \\in \\mathbb{R}^{p \\times q}$, $C \\in \\mathbb{R}^{r \\times s}$, and $D \\in \\mathbb{R}^{r \\times s}$:\n   $$(A \\otimes B) (C \\otimes D) = (A C) \\otimes (B D)$$\n\n4. **Transpose**\n\n   The transpose of the Kronecker product is given by:\n   $$(A \\otimes B)^T = A^T \\otimes B^T$$\n\n5. **Norm**\n\n   The Frobenius norm of the Kronecker product can be computed as:\n  $$\\| A \\otimes B \\|_F = \\| A \\|_F \\cdot \\| B \\|_F$$\n   where $\\| \\cdot \\|_F $ denotes the Frobenius norm.\n  :::\n\n:::{.callout-tip}\n\n----\n\n#### Frobenius Norm\n\nThe Frobenius norm, also known as the Euclidean norm for matrices, is a measure of a matrix's magnitude. It is defined as the square root of the sum of the absolute squares of its elements. Mathematically, for a matrix $A$ with elements $a_{ij}$, the Frobenius norm is given by:\n\n$$\\|A\\|_F = \\sqrt{\\sum_{i,j} |a_{ij}|^2}$$\n:::\n\nExample 1: Calculation of Frobenius Norm\n\nConsider the matrix $A$:\n\n$$A = \\begin{bmatrix}\n1 & 2 \\\\\n3 & 4\n\\end{bmatrix}$$\n\nTo compute the Frobenius norm:\n\n$$\\|A\\|_F = \\sqrt{1^2 + 2^2 + 3^2 + 4^2}\n= \\sqrt{1 + 4 + 9 + 16}\n= \\sqrt{30}\n\\approx 5.48$$\n\nExample 2: Frobenius Norm of a Sparse Matrix\n\nConsider the sparse matrix $B$:\n\n$$B = \\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 5 & 0 \\\\\n0 & 0 & 0\n\\end{bmatrix}$$\n\nTo compute the Frobenius norm:\n\n$$\\|B\\|_F = \\sqrt{0^2 + 0^2 + 0^2 + 5^2 + 0^2 + 0^2}\n= \\sqrt{25}\n= 5$$\n\nExample 3: Frobenius Norm in a Large Matrix\n\nConsider the matrix $C$ of size $3 \\times 3 $:\n\n$$C = \\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{bmatrix}$$\n\nTo compute the Frobenius norm:\n\n\\begin{align*}\n\\|C\\|_F &= \\sqrt{1^2 + 2^2 + 3^2 + 4^2 + 5^2 + 6^2 + 7^2 + 8^2 + 9^2}\\\\\n&= \\sqrt{1 + 4 + 9 + 16 + 25 + 36 + 49 + 64 + 81}\n&= \\sqrt{285}\n&\\approx 16.88\n\\end{align*}\n\n**Applications of the Frobenius Norm**\n\n- *Application 1: Image Compression:* In image processing, the Frobenius norm can measure the difference between the original and compressed images, indicating how well the compression has preserved the original image quality.\n\n- *Application 2: Matrix Factorization:* In numerical analysis, Frobenius norm is used to evaluate the error in matrix approximations, such as in Singular Value Decomposition (SVD). A lower Frobenius norm of the error indicates a better approximation.\n\n- *Application 3: Error Measurement in Numerical Solutions:* In solving systems of linear equations, the Frobenius norm can be used to measure the error between the true solution and the computed solution, providing insight into the accuracy of numerical methods.\n\nThe `linalg` sub module of `NumPy` library can be used to calculate various norms. Basically norm is the generalized form of Euclidean distance.\n\n::: {#76b9b5a3 .cell execution_count=30}\n``` {.python .cell-code}\nimport numpy as np\n\n# Example 1: Simple Matrix\nA = np.array([[1, 2], [3, 4]])\nfrobenius_norm_A = np.linalg.norm(A, 'fro')\nprint(f\"Frobenius Norm of A: {frobenius_norm_A:.2f}\")\n\n# Example 2: Sparse Matrix\nB = np.array([[0, 0, 0], [0, 5, 0], [0, 0, 0]])\nfrobenius_norm_B = np.linalg.norm(B, 'fro')\nprint(f\"Frobenius Norm of B: {frobenius_norm_B:.2f}\")\n\n# Example 3: Large Matrix\nC = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nfrobenius_norm_C = np.linalg.norm(C, 'fro')\nprint(f\"Frobenius Norm of C: {frobenius_norm_C:.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFrobenius Norm of A: 5.48\nFrobenius Norm of B: 5.00\nFrobenius Norm of C: 16.88\n```\n:::\n:::\n\n\n**Frobenius norm of Kronecker product**\n\nLet us consider two matrices,\n\n$$A = \\begin{bmatrix}\n1 & 2 \\\\\n3 & 4\n\\end{bmatrix}$$\n\nand\n\n$$B = \\begin{bmatrix}\n0 & 5 \\\\\n6 & 7\n\\end{bmatrix}$$\n\nThe Kronecker product $C = A \\otimes B$ is:\n\n$$C = \\begin{bmatrix}\n1 \\cdot B & 2 \\cdot B \\\\\n3 \\cdot B & 4 \\cdot B\n\\end{bmatrix}\n= \\begin{bmatrix}\n\\begin{bmatrix}\n0 & 5 \\\\\n6 & 7\n\\end{bmatrix} & \\begin{bmatrix}\n0 \\cdot 2 & 5 \\cdot 2 \\\\\n6 \\cdot 2 & 7 \\cdot 2\n\\end{bmatrix} \\\\\n\\begin{bmatrix}\n0 \\cdot 3 & 5 \\cdot 3 \\\\\n6 \\cdot 3 & 7 \\cdot 3\n\\end{bmatrix} & \\begin{bmatrix}\n0 \\cdot 4 & 5 \\cdot 4 \\\\\n6 \\cdot 4 & 7 \\cdot 4\n\\end{bmatrix}\n\\end{bmatrix}$$\n\nThis expands to:\n\n$$C = \\begin{bmatrix}\n0 & 5 & 0 & 10 \\\\\n6 & 7 & 12 & 14 \\\\\n0 & 15 & 0 & 20 \\\\\n18 & 21 & 24 & 28\n\\end{bmatrix}$$\n\n*Computing the Frobenius Norm*\n\nTo compute the Frobenius norm of $C$:\n\n$$\\|C\\|_F = \\sqrt{\\sum_{i=1}^{4} \\sum_{j=1}^{4} |c_{ij}|^2}$$\n\n$$\\|C\\|_F = \\sqrt{0^2 + 5^2 + 0^2 + 10^2 + 6^2 + 7^2 + 12^2 + 14^2 + 0^2 + 15^2 + 0^2 + 20^2 + 18^2 + 21^2 + 24^2 + 28^2}$$\n\n$$\\|C\\|_F = \\sqrt{0 + 25 + 0 + 100 + 36 + 49 + 144 + 196 + 0 + 225 + 0 + 400 + 324 + 441 + 576 + 784}$$\n\n$$\\|C\\|_F = \\sqrt{2896}$$\n$$\\|C\\|_F \\approx 53.87$$\n\n----\n\nIn the previous block we have discussed the Frobenius norm and its applications. Now came back to the discussions on the Kronecker product. The Kronecker product is particularly useful in scenarios where interactions between different types of data need to be modeled comprehensively. In recommendation systems, it allows us to integrate user preferences with item relationships to improve recommendation accuracy.\n\nIn addition to recommendation systems, Kronecker products are used in various fields such as:\n\n-  Signal Processing: For modeling multi-dimensional signals.\n- Machine Learning: In building features for complex models.\n- Communication Systems: For modeling network interactions.\n\nBy understanding the Kronecker product and its applications, we can extend it to solve complex problems and enhance systems across different domains. To understand the practical use of Kronecker product in a Machine Learning scenario let us consider the following problem statement and its solution.\n\n:::{.callout-note}\n### Problem statement\nIn the realm of recommendation systems, predicting user preferences for various product categories based on past interactions is a common challenge. Suppose we have data on user preferences for different products and categories. We can use this data to recommend the best products for each user by employing mathematical tools such as the Kronecker product. The User Preference and Category relationships are given in @tbl-UPM and @tbl-CRM\n.\n\n\n| User/Item  | Electronics | Clothing | Books |\n|------------|-------------|----------|-------|\n| User 1     | 5           | 3        | 4     |\n| User 2     | 2           | 4        | 5     |\n| User 3     | 3           | 4        | 4     |\n\n: User Preference {#tbl-UPM}\n\n\n| Category/Feature | Feature 1 | Feature 2 | Feature 3 |\n|------------------|-----------|-----------|-----------|\n| Electronics      | 1         | 0         | 0         |\n| Clothing         | 0         | 1         | 1         |\n| Books            | 0         | 1         | 1         |\n\n: Category Relationships {#tbl-CRM}\n\n Predict user preferences for different product categories using the Kronecker product matrix.\n:::\n\n>**Solution Procedure**\n\n1. *Compute the Kronecker Product:*\n   Calculate the Kronecker product of matrices $U$ and $C$ to obtain matrix $K$.\n\n   To model the problem, we use the Kronecker product of the user preference matrix $U$ and the category relationships matrix $C$. This product allows us to predict the user’s rating for each category by combining their preferences with the category features.\n\n  *Formulating Matrices*\n\n   User Preference Matrix (U):\n   - Dimension: $3\\times 3$ (3 users, 3 items)\n   - from the User preference data, we can create the User Preference Matrix as follows:\n\n  $$U = \\begin{pmatrix}5 & 3 & 4 \\\\2 & 4 & 5 \\\\3 & 4 & 4 \\end{pmatrix}$$\n\n   Category Relationships Matrix (C):\n   - Dimension: $3 \\times 3$ (3 categories)\n   - from the Category Relationships data, we can create the Category Relationship Matrix as follows:\n\n  $$C = \\begin{pmatrix}1 & 0 & 0 \\\\ 0 & 1 & 1 \\\\ 0 & 1 & 1\\end{pmatrix}$$\n\n  *Kronecker Product Calculation*\n\n    The Kronecker product $K$ of $U$ and $C$ is calculated as follows:\n\n  1. **Matrix Dimensions:**\n   - $U$ is $3 \\times 3$ (3 users, 3 items).\n   - $C$ is $3 \\times 3$ (3 categories, 3 features).\n\n  2. **Calculate Kronecker Product:**\n   - For each element $u_{ij}$ in $U$, multiply by the entire matrix $C$.\n\n   The Kronecker product $K$ is computed as:\n\n  $$K = U \\otimes C$$\n\n   Explicitly, the Kronecker product $K$ is:\n\n  $$K = \\begin{pmatrix}5 \\cdot C & 3 \\cdot C & 4 \\cdot C \\\\ 2 \\cdot C & 4 \\cdot C & 5 \\cdot C \\\\    3 \\cdot C & 4 \\cdot C & 4 \\cdot C\\end{pmatrix}$$\n\n   As an example the blocks in first row are:\n\n  $$5 \\cdot C = \\begin{pmatrix}\n   5 & 0 & 0 \\\\\n   0 & 5 & 5 \\\\\n   0 & 5 & 5\n   \\end{pmatrix}, \\quad\n   3 \\cdot C = \\begin{pmatrix}\n   3 & 0 & 0 \\\\\n   0 & 3 & 3 \\\\\n   0 & 3 & 3\n   \\end{pmatrix}, \\quad\n   4 \\cdot C = \\begin{pmatrix}\n   4 & 0 & 0 \\\\\n   0 & 4 & 4 \\\\\n   0 & 4 & 4\n   \\end{pmatrix}$$\n\n   Combining these blocks:\n\n  $$K = \\begin{pmatrix}\n   5 & 0 & 0 & 3 & 0 & 0 & 4 & 0 & 0\\\\\n   0 & 5 & 5 & 0 & 3 & 3 & 0 & 4 & 4\\\\\n   0 & 5 & 5 & 0 & 3 & 3 & 0 & 4 & 4\\\\\n   2 & 0 & 0 & 4 & 0 & 0 & 5 & 0 & 0\\\\\n   0 & 2 & 2 & 0 & 4 & 4 & 0 & 5 & 5\\\\\n   0 & 2 & 2 & 0 & 4 & 4 & 0 & 5 & 5\\\\\n   3 & 0 & 0 & 4 & 0 & 0 & 4 & 0 & 0\\\\\n   0 & 3 & 3 & 0 & 4 & 4 & 0 & 4 & 4\\\\\n   0 & 3 & 3 & 0 & 4 & 4 & 0 & 4 & 4\\end{pmatrix}$$\n\n2. **Interpret the Kronecker Product Matrix:**\n   The resulting matrix $K$ represents all possible combinations of user preferences and category features.\n\n3. **Predict Ratings:**\n   For each user, use matrix $K$ to predict the rating for each category by summing up the values in the corresponding rows.\n\n4. **Generate Recommendations:**\n   Identify the top categories with the highest predicted ratings for each user.\n\nThe `python` code to solve this problem computationally is given below.\n\n::: {#fae6e6a6 .cell execution_count=31}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Define the matrices\nU = np.array([[5, 3, 4],\n              [2, 4, 5],\n              [3, 4, 4]])\n\nC = np.array([[1, 0, 0],\n              [0, 1, 1],\n              [0, 1, 1]])\n\n# Compute the Kronecker product\nK = np.kron(U, C)\n\n# Create a DataFrame to visualize the Kronecker product matrix\ndf_K = pd.DataFrame(K, \n                    columns=['Electronics_F1', 'Electronics_F2', 'Electronics_F3', \n                             'Clothing_F1', 'Clothing_F2', 'Clothing_F3', \n                             'Books_F1', 'Books_F2', 'Books_F3'],\n                    index=['User 1 Electronics', 'User 1 Clothing', 'User 1 Books', \n                           'User 2 Electronics', 'User 2 Clothing', 'User 2 Books', \n                           'User 3 Electronics', 'User 3 Clothing', 'User 3 Books'])\n\n# Print the Kronecker product matrix\nprint(\"Kronecker Product Matrix (K):\\n\", df_K)\n\n# Predict ratings and create recommendations\ndef recommend(user_index, top_n=3):\n    \"\"\" Recommend top_n categories for a given user based on Kronecker product matrix. \"\"\"\n    user_ratings = K[user_index * len(C):(user_index + 1) * len(C), :]\n    predicted_ratings = np.sum(user_ratings, axis=0)\n    recommendations = np.argsort(predicted_ratings)[::-1][:top_n]\n    return recommendations\n\n# Recommendations for User 1\nuser_index = 0  # User 1\ntop_n = 3\nrecommendations = recommend(user_index, top_n)\n\nprint(f\"\\nTop {top_n} recommendations for User {user_index + 1}:\")\nfor rec in recommendations:\n    print(df_K.columns[rec])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nKronecker Product Matrix (K):\n                     Electronics_F1  Electronics_F2  Electronics_F3  \\\nUser 1 Electronics               5               0               0   \nUser 1 Clothing                  0               5               5   \nUser 1 Books                     0               5               5   \nUser 2 Electronics               2               0               0   \nUser 2 Clothing                  0               2               2   \nUser 2 Books                     0               2               2   \nUser 3 Electronics               3               0               0   \nUser 3 Clothing                  0               3               3   \nUser 3 Books                     0               3               3   \n\n                    Clothing_F1  Clothing_F2  Clothing_F3  Books_F1  Books_F2  \\\nUser 1 Electronics            3            0            0         4         0   \nUser 1 Clothing               0            3            3         0         4   \nUser 1 Books                  0            3            3         0         4   \nUser 2 Electronics            4            0            0         5         0   \nUser 2 Clothing               0            4            4         0         5   \nUser 2 Books                  0            4            4         0         5   \nUser 3 Electronics            4            0            0         4         0   \nUser 3 Clothing               0            4            4         0         4   \nUser 3 Books                  0            4            4         0         4   \n\n                    Books_F3  \nUser 1 Electronics         0  \nUser 1 Clothing            4  \nUser 1 Books               4  \nUser 2 Electronics         0  \nUser 2 Clothing            5  \nUser 2 Books               5  \nUser 3 Electronics         0  \nUser 3 Clothing            4  \nUser 3 Books               4  \n\nTop 3 recommendations for User 1:\nElectronics_F2\nElectronics_F3\nBooks_F3\n```\n:::\n:::\n\n\nA simple visualization of this recomendation system is shown in [Fig @fig-reco].\n\n::: {#cell-fig-reco .cell execution_count=32}\n``` {.python .cell-code}\n# Visualization\ndef plot_recommendations(user_index):\n    \"\"\" Plot the predicted ratings for each category for a given user. \"\"\"\n    user_ratings = K[user_index * len(C):(user_index + 1) * len(C), :]\n    predicted_ratings = np.sum(user_ratings, axis=0)\n    categories = df_K.columns\n    plt.figure(figsize=(6, 5))\n    plt.bar(categories, predicted_ratings)\n    plt.xlabel('Categories')\n    plt.ylabel('Predicted Ratings')\n    plt.title(f'Predicted Ratings for User {user_index + 1}')\n    plt.xticks(rotation=45)\n    plt.show()\n\n# Plot recommendations for User 1\nplot_recommendations(user_index)\n```\n\n::: {.cell-output .cell-output-display}\n![EDA for the Recommendation System](module_2_files/figure-epub/fig-reco-output-1.png){#fig-reco}\n:::\n:::\n\n\nThis micro project illustrate one of the popular use of Kronecker product on ML application.\n\n### Matrix Measures of Practical Importance\n\nMatrix measures, such as rank and determinant, play crucial roles in linear algebra. While both rank and determinant provide valuable insights into the properties of a matrix, they serve different purposes. Understanding their roles and applications is essential for solving complex problems in computer science, engineering, and applied mathematics.\n\n#### Determinant\n\nDeterminant of a $2\\times 2$ matrix $A=\\begin{pmatrix}a&b\\\\c&d\\end{pmatrix}$ is defined as $|A|=ad-bc$. Determinant of higher order square matrices can be found using the Laplace method or Sarrus method.\n\nThe determinant of a matrix provides information about the matrix's invertibility and scaling factor for volume transformation. Specifically:\n\n1. *Invertibility:* A matrix is invertible if and only if its determinant is non-zero.\n\n2. *Volume Scaling:* The absolute value of the determinant gives the scaling factor by which the matrix transforms volume.\n3. *Parallelism:* If the determinant of a matrix composed of vectors is zero, the vectors are linearly dependent, meaning they are parallel or redundant.\n4. *Redundancy:*  A zero determinant indicates that the vectors span a space of lower dimension than the number of vectors, showing redundancy.\n\n:::{.callout-important}\n## Least Possible Values of Determinant\n\n1. *Least Positive Determinant:* For a $1\\times 1$ matrix, the smallest non-zero determinant is any positive value, typically $\\epsilon$, where  $\\epsilon$ is a small positive number.\n2. Least Non-Zero Determinant: For higher-dimensional matrices, the smallest non-zero determinant is a non-zero value that represents the smallest area or volume spanned by the matrix's rows or columns. For example a $2\\times 2$ matrix with determinant $\\epsilon$ could be:\n$$B=\\begin{pmatrix}\\epsilon&0\\\\ 0&\\epsilon\\end{pmatrix}$$\nHere, $\\epsilon$ is a small positive number, indicating a very small but *non-zero* area.\n:::\n\nNow let's look into the most important matrix measure for advanced application in Linear Algebra.\n\nAs we know the matrix is basically a representation tool that make things abstract- remove unnecessary details. Then the matrix itself can be represented in many ways. This is the real story telling with this most promising mathematical structure. Consider a context of collecting feedback about a product in three aspects- cost, quality and practicality. For simplicity in calculation, we consider responses from 3 customers only. The data is shown in @tbl-RT.\n\n| User   | Cost | Quality | Practicality |\n|--------|------|---------|--------------|\n| User-1 | 1    | 4       | 5            |\n| User-2 | 3    | 2       | 5            |\n| User-3 | 2    | 1       | 3            |\n\n: User rating of a consumer product {#tbl-RT}\n\nIt's perfect and nice looking. But both mathematics and a computer can't handle this table as it is. So we create an abstract representation of this data- the rating matrix. Using the traditional approach, let's represent this rating data as:\n$$A=\\begin{bmatrix}1&4&5\\\\3&2&5\\\\2&1&3\\end{bmatrix}$$\n\nNow both the column names and row indices were removed and the data is transformed into the abstract form. This representation has both advantages and disadvantages. Be positive! So we are focused only in the advantages.\n\nJust consider the product. Its sales fully based on its features. So the product sales perspective will be represented in terms of the features- cost, quality and practicality. These features are columns of our rating matrix. Definitly peaple will have different rating for these features. Keeping all these in mind let's introduce the concept of *linear combination*. This leads to a new matrix product as shown below.\n\\begin{align*}\nAx&=\\begin{bmatrix}1&4&5\\\\3&2&5\\\\2&1&3\\end{bmatrix}x\\\\\n&=\\begin{bmatrix}1&4&5\\\\3&2&5\\\\2&1&3\\end{bmatrix}\\cdot\\begin{bmatrix}x_1\\\\x_2\\\\x_3\\end{bmatrix}\\\\\n&=\\begin{bmatrix}1\\\\3\\\\2\\end{bmatrix}x_1+\\begin{bmatrix}1\\\\3\\\\2\\end{bmatrix}x_1+\\begin{bmatrix}4\\\\2\\\\1\\end{bmatrix}x_2+\\begin{bmatrix}5\\\\5\\\\3\\end{bmatrix}x_3\n\\end{align*}\n\nAs the number of users increases, the product sales perspective become more informative. In short the span of the features define the feature space of the product. In real cases, a manufacture wants to know what are the features really inflence the customers. This new matrix product will help the manufactures to identify that features! \n\nSo we are going to define this new matrix product as the feature space, that will provide more insights to this context as:\n\n$$A=CR$$\n\nWhere $C$ is the column space and $R$ is the row reduced Echelon form of $A$. But the product is not the usual scalar projection, Instead the weight of linear combination of elements in the column space.\n\nLet's formally illustrate this in our example. From the first observation itself, it is clear that last column is just the sum of first and second columns (That is in our context the feature 'practicality' is just depends on 'cost' and 'quality'. meaningful?). So only first columns are independent and so spans the column space. \n\n$$C=\\begin{bmatrix}1&4\\\\3&2\\\\2&1\\end{bmatrix}$$\n\nNow look into the matrix $R$. Applying elementary row tansformations, $A$ will transformed into:\n\n$$R=\\begin{bmatrix}1&0&1\\\\0&1&1\\\\0&0&0\\end{bmatrix}$$\n\nHence we can form a decomposition for the given rating matrix, $A$ as:\n\\begin{align*}\nA&=CR\\\\\n&=\\begin{bmatrix}1&4\\\\3&2\\\\2&1\\end{bmatrix}\\begin{bmatrix}1&0&1\\\\0&1&1\\\\\\mbox{}&&\\end{bmatrix}\n\\end{align*}\n\n\nThis decomposition says that there are only two independent features (columns) and the third feature (column) is the sum of first two features (columns). \n\n:::{.callout-important}\n#### Interpretation of the $R$ matrix\n\nEach column in the $R$ matrix represents the weights for linear combination of vectors in the column space to get that column in $A$. In this example, third column of $R$ is $\\begin{bmatrix}1\\\\1\\end{bmatrix}$. This means that third column of $A$ will be $1\\times C_1+1\\times C_2$ of the column space, $C$!\n:::\n\nThis first matrix decompostion donate a new type of matrix product (outer product) and a new measure- the number of independent columns and number of independent rows. This count is called the *rank* of the matrix $A$. In the case of features, if the rank of the column space is less than the number of features then definitly a less number of feature set will perfectly represent the data. This will help us to reduce the dimension of the dataset and there by reducing computational complexities in data analysis and machine Learning jobs.\n\nIn the above discussion, we consider only the columns of $A$. Now we will mention the row space. It is the set of all linearly independent rows of $A$. For any matrix $A$, both the row space and column space are of same rank. This correspondance is a helpful result in many practical applications. \n\nNow we consider a stable equation, $Ax=0$. With the usual notation of dot product, it implies that $x$ is orthogonal to $A$. Set of all those independent vectors which are orthogonal to $A$ constitute a new space of interest. It is called the *null space* of $A$. If $A$ represents a linear transformation, then the null space will be populated by those non-zero vectors which are *nullified* by the transformation $A$. As a summary of this discussion, the row space and null space of a matrix $A$ creates an orthogonal system. Considering the relationship between $A$ and $A^T$, it is clear that row space of $A$ is same as the column space of $A^T$ and vice verse are. So we can restate the orthogonality as: 'the null space of $A$ is orthogonal to the column space of $A^T$' and 'the null space of $A^T$ is orthogonal to the column space of $A$'. Mathematically this property can be represents as follows.\n\n::: {#note-ortho .callout-note}\n\n\\begin{align*}\n\\mathcal{N}(A)&\\perp \\mathcal{C}(A^T)\\\\\n\\mathcal{N}(A^T)&\\perp \\mathcal{C}(A)\n\\end{align*}\n:::\n\nIn the given example, solving $Ax=0$  we get $x=\\begin{bmatrix}1&1&-1\\end{bmatrix}^T$. \n\nSo the rank of $\\mathcal{N}(A)=1$. Already we have rank of $A=2$. This leads to an interesting result:\n\n$$\\text{Rank}(A)+\\text{Rank}(\\mathcal{N}(A))=3$$\n\nThis observation can be framed as a theorem.\n\n### Rank Nullity Theorem\n\nThe rank-nullity theorem is a fundamental theorem in linear algebra that is important for understanding the connections between mathematical operations in engineering, physics, and computer science. It states that the sum of the rank and nullity of a matrix equals the number of columns in the matrix. The rank is the maximum number of linearly independent columns, and the nullity is the dimension of the nullspace. \n\n:::{#thm-RNT }\n\n#### Rank Nullitty Theorem\n\nThe Rank-Nullity Theorem states that for any $m \\times n$ matrix $A$, the following relationship holds:\n\n$$\n\\text{Rank}(A) + \\text{Nullity}(A) = n\n$$\n\nwhere:\n- **Rank** of $A$ is the dimension of the column space of $A$, which is also equal to the dimension of the row space of $A$.\n- **Nullity** of $A$ is the dimension of the null space of $A$, which is the solution space to the homogeneous system $A \\mathbf{x} = \\mathbf{0}$.\n:::\n\n*Steps to Formulate for Matrix $A$*\n\n1. **Find the Rank of $A$**:\n   The rank of a matrix is the maximum number of linearly independent columns (or rows). It can be determined by transforming $A$ into its row echelon form or reduced row echelon form (RREF).\n\n2. **Find the Nullity of $A$**:\n   The nullity is the dimension of the solution space of $A \\mathbf{x} = \\mathbf{0}$. This can be found by solving the homogeneous system and counting the number of free variables.\n\n3. **Apply the Rank-Nullity Theorem**:\n   Use the rank-nullity theorem to verify the relationship.\n\n-----\n\n*Example 1:* Calculate the rank and nullity of $A=\\begin{bmatrix}\n   1 & 4 & 5 \\\\\n   3 & 2 & 5 \\\\\n   2 & 1 & 3\n   \\end{bmatrix}$ and verify the rank nullity theorem.\n\n1. **Row Echelon Form**:\n\n   Perform Gaussian elimination on $A$:\n\n   $$A = \\begin{bmatrix}\n   1 & 4 & 5 \\\\\n   3 & 2 & 5 \\\\\n   2 & 1 & 3\n   \\end{bmatrix}$$\n\n   Perform row operations to get it to row echelon form:\n\n   - Subtract 3 times row 1 from row 2:\n     $$\\begin{bmatrix}\n     1 & 4 & 5 \\\\\n     0 & -10 & -10 \\\\\n     2 & 1 & 3\n     \\end{bmatrix}$$\n\n   - Subtract 2 times row 1 from row 3:\n     $$\\begin{bmatrix}\n     1 & 4 & 5 \\\\\n     0 & -10 & -10 \\\\\n     0 & -7 & -7\n     \\end{bmatrix}$$\n\n   - Add $\\frac{7}{10}$ times row 2 to row 3:\n     $$\\begin{bmatrix}\n     1 & 4 & 5 \\\\\n     0 & -10 & -10 \\\\\n     0 & 0 & 0\n     \\end{bmatrix}$$\n\n   The matrix is now in row echelon form.\n\n   **Rank** is the number of non-zero rows, which is 2.\n\n2. **Find the Nullity**:\n   The matrix $A$ has 3 columns. The number of free variables in the solution of $A \\mathbf{x} = \\mathbf{0}$ is $3 - \\text{Rank}$. \n\n   So,\n   $$\\text{Nullity}(A) = 3 - 2 = 1$$\n\n3. **Apply the Rank-Nullity Theorem**:\n   $$\\text{Rank}(A) + \\text{Nullity}(A) = 2 + 1 = 3$$\n\n   This matches the number of columns of $A$, confirming the theorem.\n\n### Fundamental Subspaces\n\nIn section @note-ortho, we have seen that for any matrix $A$, there is two pairs of inter-related orthogonal spaces. This leads to the concept of Fundamental sup spaces. \n\nMatrices are not just arrays of numbers; they can represent linear transformations too. A linear transformation maps vectors from one vector space to another while preserving vector addition and scalar multiplication. The matrix $A$ can be viewed as a representation of a linear transformation $T$ from $\\mathbb{R}^m$ to $\\mathbb{R}^m$ where:\n\n$$T(\\mathbf{x}) = A \\mathbf{x}$$\n\nIn this context:\n\n- The column space of $A$ represents the range of $T$, which is the set of all possible outputs.\n- The null space of $A$ represents the kernel of $T$, which is the set of vectors that are mapped to the zero vector.\n\n**The Four Fundamental Subspaces**\n\nUnderstanding the four fundamental subspaces helps in analyzing the properties of a linear transformation. These subspaces are:\n\n:::{#def-FFS}\n#### Four Fundamental Subspaces\n\nLet $T:\\mathbb{R^n}\\longrightarrow \\mathbb{R^m}$ be a linear transformation and $A$ represents the matrix of transformation. The four fundamental subspaces are defined as:\n\n1. **Column Space (Range)**: The set of all possible outputs of the transformation. For matrix $A$, this is the span of its columns. It represents the image of $\\mathbb{R}^n$ under $T$.\n\n2. **Null Space (Kernel)**: The set of all vectors that are mapped to the zero vector by the transformation. For matrix $A$, this is the solution space of $A \\mathbf{x} = \\mathbf{0}$.\n\n3. **Row Space**: The span of the rows of $A$. This space is crucial because it helps in understanding the rank of $A$. The dimension of the row space is equal to the rank of $A$, which represents the maximum number of linearly independent rows.\n\n4. **Left Null Space**: The set of all vectors $\\mathbf{y}$ such that $A^T \\mathbf{y} = \\mathbf{0}$. It provides insight into the orthogonal complement of the row space.\n:::\n\n\n\n\n\n\n\n\n```{mermaid}\ngraph TD\n    MatrixA[Matrix A] -->|Contains Columns| ColumnSpace[Column Space]\n    MatrixA -->|Contains Rows| RowSpace[Row Space]\n    MatrixA -->|Contains Vectors Mapping to Zero| NullSpace[Null Space]\n    MatrixA -->|Contains Vectors Orthogonal to Row Space| LeftNullSpace[Left Null Space]\n    ColumnSpace -->|Orthogonal Complement| NullSpace\n    RowSpace -->|Orthogonal Complement| LeftNullSpace\n```\n\n\n\n\n\n\n\nThis idea is depicted as a 'Big picture of the four sub spaces of a matrix' in the Strang's text book on Linear algebra for every one [@strang2020linear]. This 'Big Picture' is shown in [Fig- @fig-big-pic].\n\n![The Big Pictue of Fundamental Subspaces](https://i.pinimg.com/originals/fb/c5/f9/fbc5f91d82681dd7341dda6915d11e92.png){#fig-big-pic fig-align=\"center\" width=80% .lightbox}\n\nA video session from Strang's session is here:\n\n\n\n\n\n\n\n\n{{< video https://youtu.be/rwLOfdfc4dw?si=DsJb8KJTF05hHc76 >}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### Practice Problems\n\n#### Rank and Solution of System of Linear Equations\n\nIn linear algebra, the rank of a matrix is a crucial concept for understanding the structure of a system of linear equations. It provides insight into the solutions of these systems, helping us determine the number of independent equations and the nature of the solution space.\n\n:::{#def-soln}\n\n#### Rank and System Consistency\n\nThe rank of a matrix $A$ is defined as the maximum number of linearly independent rows or columns. When solving a system of linear equations represented by $A\\mathbf{x} = \\mathbf{b}$, where $A$ is an $m \\times n$ matrix and $\\mathbf{b}$ is a vector, the rank of $A$ plays a crucial role in determining the solution's existence and uniqueness.\n\n**Consistency of the System**\n\n1. **Consistent System:** A system of linear equations is consistent if there exists at least one solution. This occurs if the rank of the coefficient matrix $A$ is equal to the rank of the augmented matrix \\([A|\\mathbf{b}]\\). Mathematically, this can be expressed as:\n   $$\\text{rank}(A) = \\text{rank}([A|\\mathbf{b}])$$\n   If this condition is met, the system has solutions. The solutions can be:\n   - **Unique** if the rank equals the number of variables.\n   - **Infinitely many** if the rank is less than the number of variables.\n\n2. **Inconsistent System:** A system is inconsistent if there are no solutions. This occurs when:\n   $$\\text{rank}(A) \\ne \\text{rank}([A|\\mathbf{b}])$$\n   In this case, the equations represent parallel or conflicting constraints that cannot be satisfied simultaneously.\n   :::\n\n",
    "supporting": [
      "module_2_files\\figure-epub"
    ],
    "filters": [],
    "engineDependencies": {
      "jupyter": [
        {
          "jsWidgets": false,
          "jupyterWidgets": false,
          "htmlLibraries": []
        }
      ]
    }
  }
}